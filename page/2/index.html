<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BingcaiHuang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BingcaiHuang&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BingcaiHuang&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>BingcaiHuang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BingcaiHuang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/Qt中文乱码问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/Qt中文乱码问题/" itemprop="url">Qt中文乱码问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:47:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index">
                    <span itemprop="name">Qt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/Qt中文乱码问题/" class="leancloud_visitors" data-flag-title="Qt中文乱码问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Qt中文乱码问题"><a href="#Qt中文乱码问题" class="headerlink" title="Qt中文乱码问题"></a>Qt中文乱码问题</h2><h3 id="VC2010下Qt5的中文乱码问题"><a href="#VC2010下Qt5的中文乱码问题" class="headerlink" title="VC2010下Qt5的中文乱码问题"></a>VC2010下Qt5的中文乱码问题</h3><blockquote>
<p>参考文章：<br><a href="https://my.oschina.net/chai2010/blog/119833" target="_blank" rel="noopener">VC2010下Qt5的中文乱码问题</a></p>
</blockquote>
<p>要搞清楚这个问题，先要弄明白编码。但是编码问题实在太复杂，这里肯定讲不开。</p>
<p>我先找一个例子，比如：”中文” 的 Unicode 码点/UTF8编码/GBK 分别是多少。</p>
<p>先去这个网站，输入 “中文” 查询对应的 Unicode 码点/UTF8编码： <a href="http://www.mytju.com/classcode/tools/encode_utf8.asp" target="_blank" rel="noopener">http://www.mytju.com/classcode/tools/encode_utf8.asp</a></p>
<p>Unicode的码点分别是(十进制)：中(20013)，文(25991)。 对应的UTF8编码分别(16进制): 中(E4B8AD)，文(E69687)。</p>
<p>然后再去下面这个网站，输入 “中文” 查询对应的 GBK 编码： <a href="http://www.mytju.com/classcode/tools/encode_gb2312.asp" target="_blank" rel="noopener">http://www.mytju.com/classcode/tools/encode_gb2312.asp</a></p>
<p>GBK编码16进制(GBK内码)分别是：中(D6D0)，文(CEC4)。</p>
<p>现在已经知道了”中文”的UTF8和GBK编码的具体值。 我们再看看VC2010是怎么处理的。</p>
<h4 id="先看无-BOM-的-UTF8-编码的代码-utf8-no-bom-cpp"><a href="#先看无-BOM-的-UTF8-编码的代码-utf8-no-bom-cpp" class="headerlink" title="先看无 BOM 的 UTF8 编码的代码 (utf8_no_bom.cpp)"></a>先看无 BOM 的 UTF8 编码的代码 (utf8_no_bom.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// utf8 no bom</span><br><span class="line">// 文件中包含不能在当前代码页（936）中表示的字符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xe4 0xb8 0xad 0xe6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：0xe4 0xb8 0xad 0xe6。 感觉好像是对的。</p>
<p>但是，先别急：VC编译时输出了一条警告信息： utf8_no_bom.cpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。 请将该文件保存为 Unicode 格式以防止数据丢失。</p>
<p>潜台词就是，你这个代码有GBK不能表示的字符，请用Unicode方式保存。 VC根本就没把 代码(utf8_no_bom.cpp) 当作UTF8，VC只是把它作为GBK处理罢了。</p>
<p>那为什么又输出了正确的结果呢？</p>
<p>因为 VC 把 (utf8_no_bom.cpp) 当作 GBK，而编译时也要转换为本地编码(也是GBK)。 因此，UTF8编码的 “中文”，被VC当作编码为 “0xe4 0xb8 0xad 0xe6” 的其他中文处理了。 VC已经不知道 “0xe4 0xb8 0xad 0xe6” 是对应 “中文” 字面值了。</p>
<p>但是在GBK(实际是无BOM的UTF8)转GBK的过程中，发现了一些UTF8编码的字符并不是 GBK能表达的合理方式，因此就出现了那个C4819编译警告。</p>
<h4 id="再看带BOM的UTF8是怎么处理的-utf8-with-bom-cpp"><a href="#再看带BOM的UTF8是怎么处理的-utf8-with-bom-cpp" class="headerlink" title="再看带BOM的UTF8是怎么处理的 (utf8_with_bom.cpp)"></a>再看带BOM的UTF8是怎么处理的 (utf8_with_bom.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// utf8 with bom</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xd6 0xd0 0xce 0xc4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译没有警告，但是输出有问题：0xd6 0xd0 0xce 0xc4。</p>
<p>源文件明明是 UTF8 编码的格式”0xe4 0xb8 0xad 0xe6”， 怎么变成了 “0xd6 0xd0 0xce 0xc4” (这个是GBK编码)？</p>
<p>这就是VC私下干的好事：它自作聪明的将UTF8源代码转换为GBK处理了！</p>
<p>VC为何要做这样蠢事？</p>
<p>原因是为了兼容老的VC版本。 因为以前的VC不能处理UTF8，都是用本地编码处理的。</p>
<h4 id="在看看真的GBK是怎么处理的-gbk-cpp"><a href="#在看看真的GBK是怎么处理的-gbk-cpp" class="headerlink" title="在看看真的GBK是怎么处理的 (gbk.cpp)"></a>在看看真的GBK是怎么处理的 (gbk.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// gbk</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xd6 0xd0 0xce 0xc4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有编译错误，输出也和源代码一致：”0xd6 0xd0 0xce 0xc4”。</p>
<p>因为源文件就是GBK，cl在编译时GBK转化为GBK，没有改变字符串。</p>
<p>只是，现在很多人不想用GBK了（因为只能在中国地区用，不能表示全球字符）。</p>
<hr>
<p>到这里，可以初步小结一下：</p>
<ol>
<li>VC编辑器和VC编译器是2个概念，VC编辑器支持UTF8并不能表示VC编译器也支持UTF8</li>
<li>VC编辑器从2008?开始支持带BOM的UTF8(不带BOM的暂时没戏，因为会本地编码冲突)</li>
<li>VC编译器从2010开始重要可以支持UTF8了(虽然支持方式很不优雅)</li>
</ol>
<hr>
<h4 id="看看VC2010是怎么处理带BOM的UTF8的-utf8-with-bom-2010-cpp"><a href="#看看VC2010是怎么处理带BOM的UTF8的-utf8-with-bom-2010-cpp" class="headerlink" title="看看VC2010是怎么处理带BOM的UTF8的 (utf8_with_bom_2010.cpp)"></a>看看VC2010是怎么处理带BOM的UTF8的 (utf8_with_bom_2010.cpp)</h4><p>VC2010重要增加了UTF8的编译支持(#pragma execution_character_set(“utf-8”)), 具体查看:</p>
<p><a href="http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/2f328917-4e99-40be-adfa-35cc17c9cdec" target="_blank" rel="noopener">http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/2f328917-4e99-40be-adfa-35cc17c9cdec</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// utf8 with bom (VC2010), 这句是重点！</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xe4 0xb8 0xad 0xe6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有编译错误，输出也和源代码一致：”0xe4 0xb8 0xad 0xe6”。</p>
<p>UTF8编码，UTF8输出。完美!</p>
<hr>
<h4 id="回到-Qt5-的中文输出问题。"><a href="#回到-Qt5-的中文输出问题。" class="headerlink" title="回到 Qt5 的中文输出问题。"></a>回到 Qt5 的中文输出问题。</h4><p>Qt默认支持 VS2010/MinGW/Gcc 等编译器，而它们现在都已经真正支持UTF8了。</p>
<p>当然，VS2010 对UTF8的支持会入侵代码(#pragma execution_character_set(“utf-8”))。</p>
<p>看看Qt官方论坛别人是怎么说的： <a href="http://qt-project.org/forums/viewthread/17617" target="_blank" rel="noopener">http://qt-project.org/forums/viewthread/17617</a></p>
<blockquote>
<p>Nothing special need to do, it will works by default. If the exec-charset of your your compiler is UTF-8.</p>
</blockquote>
<p>简单的说，从Qt5开始，源代码就是默认UTF8编码的。</p>
<p>当然，VC2010编辑器对带BOM的UTF8也是认识，只可惜VC2010编译器根本承认它是UTF8！</p>
<p>在继续看官方论坛的回复：</p>
<blockquote>
<p>You can write a simple example like this</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">  #if _MSC_VER &gt;= 1600</span><br><span class="line">  #pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">  int main(int argc, char *argv[])</span><br><span class="line">  &#123;</span><br><span class="line">      QApplication a(argc, argv);</span><br><span class="line">      QLabel label(&quot;ąśćółęńżź&quot;);</span><br><span class="line">      label.show();</span><br><span class="line"></span><br><span class="line">      return a.exec();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If other people can reproduce your problem, you can file a bug.</p>
</blockquote>
<p>教完整的解决方案(增加了Qt4/Qt5和非VC环境的判断):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Coding: UTF-8(BOM)</span><br><span class="line">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)</span><br><span class="line"># pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	QApplication app(argc, argv);</span><br><span class="line"></span><br><span class="line">#if QT_VERSION &lt; QT_VERSION_CHECK(5,0,0)</span><br><span class="line">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1600)</span><br><span class="line">	QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;GB18030-0&quot;));</span><br><span class="line">#else</span><br><span class="line">	QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;UTF-8&quot;));</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	QLabel *label = new QLabel(QObject::tr(&quot;你好！&quot;));</span><br><span class="line">	label-&gt;show();</span><br><span class="line"></span><br><span class="line">	return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有以下几种类型(源代码必须是带BOM的UTF8):</p>
<ul>
<li>Qt5+/VC2010+: 包含了 # pragma execution_character_set(“utf-8”) 已经支持中文</li>
<li>Qt5/VC2008-: 这个暂时误解(我还没找到方法)</li>
<li>Qt4+/VC2008-: 采用以前老的方式, 指定代码为 “GB18030-0” 编码</li>
<li>Qt4/Qt5/Linux: 只要是默认的UTF8环境, 应该都没问题</li>
</ul>
<p>其实这个问题不是Qt特有的, 追根溯源还是C/C++和编译器的问题.</p>
<p>即使是支持UTF16的Java也同样难逃此问题.</p>
<h3 id="Qt5中解决中文乱码的方法"><a href="#Qt5中解决中文乱码的方法" class="headerlink" title="Qt5中解决中文乱码的方法"></a>Qt5中解决中文乱码的方法</h3><blockquote>
<p>文章：<a href="https://blog.csdn.net/liyuanbhu/article/details/72596952" target="_blank" rel="noopener">Qt5中解决中文乱码的方法</a></p>
</blockquote>
<p>在 Qt 4 的时代，解决中文乱码挺麻烦。要考虑用的是什么编译器，具体的可以参考下面这篇文章：<br><a href="http://blog.csdn.net/brave_heart_lxl/article/details/7186631" target="_blank" rel="noopener">http://blog.csdn.net/brave_heart_lxl/article/details/7186631</a></p>
<p>到了 Qt 5 的年代，这个问题变得简单了些。因为根据 Qt 的文档：<br><a href="http://doc.qt.io/qt-5.6/qstring.html#QString-7" target="_blank" rel="noopener">http://doc.qt.io/qt-5.6/qstring.html#QString-7</a></p>
<p>中规定 QString 的 const char* 构造函数是调用 fromUtf8() 构造的。所以要求字符串字面量是 UTF-8 编码的字节。</p>
<p>这里先要解释一下下面两个概念：</p>
<ul>
<li>源码字符集(the source character set)：源码文件是使用何种编码保存的</li>
<li>执行字符集(the execution character set)：可执行程序内保存的是何种编码(程序执行时内存中字符串编码)</li>
</ul>
<p>源码字符集很容易理解，就是我们源代码的编码。为了我们的代码能够跨平台，源文件要保存为带 BOM 的 utf-8。</p>
<p>执行字符集就麻烦多了。比如我们下面的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>即使这个文件存为 utf-8 格式了，编译成 exe 文件时，编译器也可能对这个字符串常量进行转码，转为别的编码格式。</p>
<p>在 gcc 中，控制这个转码操作的命令行参数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fexec-charset=charset</span><br></pre></td></tr></table></figure></p>
<p>如果不指定的话默认是 utf-8。所以我们用 gcc 时很少关注这个问题。</p>
<p>Viual Stdio 中就麻烦多了。这里先说 Visual stdio 2015，这个是我现在用的编译环境。VS2015 中如果源代码是 utf-8的，执行字符集默认是本地 Locale 字符集，对于简体中文的 windows 系统来说，这个 本地Locale字符集是 gb18030。所以直接显示汉字会全是乱码。解决这个乱码有三个办法，第一个办法是编译时加入命令行参数，在 Qt 的 pro 文件中可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msvc:QMAKE_CXXFLAGS += -execution-charset:utf-8</span><br></pre></td></tr></table></figure></p>
<p>第二个办法是在源文件中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></p>
<p>更好的办法是源代码写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString  str(u8&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>当然，这里要求编译器支持 C++11，因此上面的代码在 VS2005、VS2008 上是无法编译通过的。</p>
<p>另外，如果源代码保存为不带 BOM 的 utf-8。那需要告诉 VS2015 我们的编码格式是 utf-8，可以在 pro 文件中加入如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msvc:QMAKE_CXXFLAGS += -source-charset:utf-8</span><br></pre></td></tr></table></figure></p>
<p>另外再说说 VS2005、VS2008 下该如何设置。首先这两个编译器都不支持 C++11，也不支持执行字符集的设置，执行字符集就是默认的本地 Locale 字符集。所以我们的代码只能写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = QString::fromLocal8Bit(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/Qt-Plugin框架结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/Qt-Plugin框架结构/" itemprop="url">Qt Plugin框架结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:08:10+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index">
                    <span itemprop="name">Qt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/Qt-Plugin框架结构/" class="leancloud_visitors" data-flag-title="Qt Plugin框架结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Qt-Plugin框架结构"><a href="#Qt-Plugin框架结构" class="headerlink" title="Qt Plugin框架结构"></a>Qt Plugin框架结构</h2><blockquote>
<p>参考文章：<br><a href="http://yleesun.blog.163.com/blog/static/2941340220093246562218/" target="_blank" rel="noopener">基于QT Plugin框架结构</a></p>
</blockquote>
<h3 id="qt-plugin-介绍"><a href="#qt-plugin-介绍" class="headerlink" title="qt plugin 介绍"></a>qt plugin 介绍</h3><pre><code>Qt Plugin和其他类型的插件一样，是一种计算机应用程序，它和主应用程序(host application)互相交互，以提供特定的功能。应用程序支持Plugin有许多原因，一些主要原因包括：使得第三方开发者有能力扩展应用程序，以提供无法先期预料的特色；减小应用程序的大小；由于软件版权之间的不兼容性将源代码和应用程序分享。Qt Plugin 分动态插件和静态插件两种。
</code></pre><h3 id="qt-plugin-创建和使用方法"><a href="#qt-plugin-创建和使用方法" class="headerlink" title="qt plugin 创建和使用方法"></a>qt plugin 创建和使用方法</h3><p>Qt有两种与插件有关的API。一种用来扩展Qt本身的功能，如自定义数据库驱动，图像格式，文本编解码，自定义分格，等等，称为Higher-Level API。另一种用于应用程序的功能扩展，称为Lower-Level API。前一种是建立在后一种的基础之上的。这里讨论的是后一种，即用来扩展应用程序的Lower-level API。</p>
<p>让应用程序支持插件扩展的步骤：</p>
<ol>
<li><p>定义一个接口集(只有纯虚函数的类)，用来与插件交流。</p>
</li>
<li><p>用宏Q_DECLARE_INTERFACE()将该接口告诉Qt元对象系统。</p>
<p>Q_DECLARE_INTERFACE(BrushInterface,”com.trolltech.PlugAndPaint.BrushInterface/1.0”)</p>
</li>
<li><p>应用程序中用QPluginLoader来装载插件。</p>
</li>
<li><p>用宏qobject_cast()来确定一个插件是否实现了接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject *obj = new QTimer;</span><br><span class="line">QTimer *timer = qobject_cast&lt;QTimer *&gt;(obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>写一个插件的步骤：</p>
<ol>
<li><p>声明插件类，该类从QObject和该插件希望实现的接口继承而来。</p>
</li>
<li><p>用宏Q_INTERFACES()将该接口告诉Qt元对象系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BasicToolsPlugin : public QObject,</span><br><span class="line">                         public BrushInterface,</span><br><span class="line">                         public ShapeInterface,</span><br><span class="line">                         public FilterInterface</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用宏Q_EXPORT_PLUGIN2()导出插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q_EXPORT_PLUGIN2 ( PluginName, ClassName )</span><br></pre></td></tr></table></figure>
</li>
<li><p>用适当的.pro文件构建插件。</p>
</li>
</ol>
<p>下面的代码声明了一个接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FilterInterface</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">        virtual ~FilterInterface() &#123;&#125;</span><br><span class="line">        virtual QStringList filters() const = 0;</span><br><span class="line">        virtual QImage filterImage(const QString &amp;filter, const QImage &amp;image, QWidget* parent)=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Q_DECLARE_INTERFACE(FilterInterface, &quot;com.trolltech.PlugAndPaint.FilterInterface/1.0&quot;)</span><br></pre></td></tr></table></figure>
<p>这里是实现该接口的插件类的定义：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line">#include &lt;QStringList&gt;</span><br><span class="line">#include &lt;QImage&gt;</span><br><span class="line">#include &lt;plugandpaint/interfaces.h&gt;</span><br><span class="line"></span><br><span class="line">class ExtraFiltersPlugin : public QObject, public FilterInterface</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">Q_INTERFACES(FilterInterface)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QStringList filters() const;</span><br><span class="line">    QImage filterImage(const QString &amp;filter, const QImage &amp;image,</span><br><span class="line">    QWidget *parent);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据插件的类型不同，pro文件中配置上有不同。下面是pro文件分析：</p>
<p>TEMPLATE      = lib                                  // 声明为lib，动态和静态插件一样。</p>
<p>CONFIG       += plugin static                // 声明为plugin，带static表面为静态，否则为动态。</p>
<p>INCLUDEPATH  += ../..</p>
<p>HEADERS       = basictoolsplugin.h</p>
<p>SOURCES       = basictoolsplugin.cpp</p>
<p>TARGET        = $$qtLibraryTarget(pnp_basictools)           // 指明插件的名称</p>
<p>DESTDIR       = ../../plugandpaint/plugins</p>
<p>加载插件的主应用程序默认在当前目录下的plugins文件夹中寻找可用插件，如果是动态插件，则直接放在plugins文件夹中便可，如果是静态，则需要在主应用程序的main函数的开始的地方用宏：Q_IMPORT_PLUGIN(pluginname(和pro文件中声明的一致))声明需要加载的插件并在工程配置中指明插件的lib位置。</p>
<h3 id="基于qt-plugin-技术的框架结构设想"><a href="#基于qt-plugin-技术的框架结构设想" class="headerlink" title="基于qt plugin 技术的框架结构设想"></a>基于qt plugin 技术的框架结构设想</h3><ol>
<li><p>愿景<br>由于我们目前系统功能多，模块多，缺乏系统的整体性。我们想借助Qt Plugin技术，把各个独立的功能模块实现为一个个插件，统一在主体框架中，并能根据不同地方的用户的不同需求，在主框架中加载不同的功能模块，以实现整个系统的功能集中，体现出系统的整体性。</p>
</li>
<li><p>plugin 接口<br>通过技术验证得出，目前我们采用动态插件，各个功能的插件实现定义的统一接口，具体功能放在插件界面中实现，此部分就像开发独立的应用程序，只是需要注意的是：</p>
<ul>
<li>功能部分的主界面需要继承至插件界面基类：PluginWidget，插件接口中用具体的实现类指针给插件界面基类指针赋值，在加载插件的主框架中通过插件接口中定义的基类指针统一调用，利用C++动态技术动态识别具体指向的实现类。</li>
<li>插件界面类必须实现基类的虚函数：CreateActions()用于创建Action</li>
<li>创建Action需要使用基类的方法newAction创建，在此函数中加入了保存创建的Action功能。</li>
</ul>
</li>
</ol>
<p>插件接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class QPluginInterface</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 析构函数</span><br><span class="line">    virtual ~QPluginInterface() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 插件名称</span><br><span class="line">    virtual QString PluginName() = 0;</span><br><span class="line"></span><br><span class="line">    // 插件显示在主框架中的图标文件路径</span><br><span class="line">    virtual QString PluginIconurl() = 0;</span><br><span class="line"></span><br><span class="line">    //　插件提供的对外操作接口集</span><br><span class="line">    virtual QList&lt;QAction*&gt;* Actions() = 0;</span><br><span class="line"></span><br><span class="line">    // 创建插件提供的操作方法</span><br><span class="line">    virtual void CreateActions()=0;</span><br><span class="line"></span><br><span class="line">    // 插件的主界面</span><br><span class="line">    virtual QWidget* Widget() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // 插件的主界面基类</span><br><span class="line">    PluginWidget *pluginWidget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插件界面基类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class PluginWidget :public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    PluginWidget(QWidget*parent=0);</span><br><span class="line">    ~PluginWidget();</span><br><span class="line">    QList&lt;QAction*&gt;* Actions();</span><br><span class="line">    virtual void CreateActions()&#123;&#125;</span><br><span class="line">    QAction *newAction(const QIcon &amp;icon,const QString &amp;text,QObject*parent);</span><br><span class="line">    QAction *newAction(const QString &amp;text,QObject*parent);</span><br><span class="line">    void AppendAction(QAction*act);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // action链表</span><br><span class="line">    QList&lt;QAction*&gt; *m_actlist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下图是一个实现案例中各类之间的关系图：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151586951.png" alt=""></p>
<ol start="3">
<li>插件调用</li>
</ol>
<p>插件在主框架中动态加载，目前考虑主框架基本结构是继承至QMainWindow，工具栏上显示当前加载的插件的功能键，并留有返回键可以回退到上一级。主工作区是一个QStackWidget,保存插件的界面，并把插件序号和插件对应的界面建立映射，保存在QMap&lt;int,QWidget&gt;中。通过序号到QStackWidget中切换界面。</p>
<p>下图是把DBManager做成插件加载到主框架的运行界面：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151601388.png" alt=""></p>
<p>下图是把一个简单的绘图程序做成了插件，加载到主框架的运行界面：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151609060.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前只是通过实现两个动态插件在主框架中运行，基本算是功能性的验证，离具体实施还有很多工作需要进一步的研究，比如主框架的风格，插件的管理等等。由于本人的能力有限，可能有很多认识不够的地方，请指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/模式PK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/模式PK/" itemprop="url">模式PK</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T08:54:42+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/模式PK/" class="leancloud_visitors" data-flag-title="模式PK">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模式PK"><a href="#模式PK" class="headerlink" title="模式PK"></a>模式PK</h2><p>一张记住图例的图片</p>
<p><img src="/2018/08/13/模式PK/1534121798715.png" alt=""></p>
<h3 id="抽象工厂模式VS建造者模式"><a href="#抽象工厂模式VS建造者模式" class="headerlink" title="抽象工厂模式VS建造者模式"></a>抽象工厂模式VS建造者模式</h3><blockquote>
<p><a href="https://www.cnblogs.com/ChinaHook/p/7471736.html" target="_blank" rel="noopener">抽象工厂模式VS建造者模式</a></p>
</blockquote>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品，两者的区别还是比较明显的。</p>
<p>现代化的汽车工厂能够批量生产汽车（不考虑手工打造的豪华车）。不同的工厂生产不同的汽车，宝马工厂生产宝马牌子的车，奔驰工厂生产奔驰牌子的车。车不仅具有不同品牌，还有不同的用途分类，如商务车Van，运动型车SUV等，我们按照两种设计模式分别实现车辆的生产过程。</p>
<h4 id="抽象工厂模式生产车辆"><a href="#抽象工厂模式生产车辆" class="headerlink" title="抽象工厂模式生产车辆"></a>抽象工厂模式生产车辆</h4><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>按照抽象工厂模式，首先需要定义一个抽象的产品接口即汽车接口，然后宝马和奔驰分别实现该接口，由于它们只具有了一个品牌属性，还没有定义一个具体的型号，属于对象的抽象层次，每个具体车型由其子类实现，如R系列的奔驰车是商务车，X系列的宝马车属于SUV，我们来看类图。</p>
<p><img src="/2018/08/13/模式PK/1534121926220.png" alt=""></p>
<p>在类图中，产品类很简单，我们从两个维度看产品：品牌和车型，每个品牌下都有两个车型，如宝马SUV，宝马商务车等，同时我们又建造了两个工厂，一个专门生产宝马车的宝马工厂BMWFactory，一个是生产奔驰车的奔驰车生产工厂BenzFactory。当然，汽车工厂也有两个不同的维度，可以建立这样两个工厂：一个专门生产SUV车辆的生产工厂，生产宝马SUV和奔驰SUV，另外一个工厂专门生成商务车，分别是宝马商务车和奔驰商务车，这样设计在技术上是完全可行的，但是在业务上是不可行的，为什么？这是因为你看到过有一个工厂既能生产奔驰SUV也能生产宝马SUV吗？这是不可能的，因为业务受限，除非是国内的山寨工厂。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h5 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CICar()&#123;&#125;;</span><br><span class="line">    ~CICar()&#123;&#125;;</span><br><span class="line">    //汽车的生产商， 也就是牌子</span><br><span class="line">    virtual string msGetBand() = 0;</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在产品接口中我们定义了车辆有两个可以查询的属性：品牌和型号，奔驰车和宝马车是两个不同品牌的产品，但不够具体，只是知道它们的品牌而已，还不能够实例化，因此还是一个抽象类。</p>
<h5 id="抽象宝马车"><a href="#抽象宝马车" class="headerlink" title="抽象宝马车"></a>抽象宝马车</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAbsBMW :public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAbsBMW() &#123; msBand = &quot;宝马汽车&quot;; &#125;</span><br><span class="line">    ~CAbsBMW()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //宝马车</span><br><span class="line">    string msGetBand()&#123; return msBand; &#125;</span><br><span class="line"></span><br><span class="line">    // 型号由具体的实现类实现</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抽象产品类中实现了产品的类型定义，车辆的型号没有实现，两实现类分别实现商务车和运动型车。</p>
<h5 id="宝马商务车"><a href="#宝马商务车" class="headerlink" title="宝马商务车"></a>宝马商务车</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBMWVan : public CAbsBMW</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWVan()&#123; msModel = &quot;7系列车型商务车&quot;; &#125;;</span><br><span class="line">    ~CBMWVan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="宝马SUV"><a href="#宝马SUV" class="headerlink" title="宝马SUV"></a>宝马SUV</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBMWSuv : public CAbsBMW</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWSuv()&#123; msModel = &quot;X系列车型SUV&quot;; &#125;;</span><br><span class="line">    ~CBMWSuv()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰抽象类"><a href="#奔驰抽象类" class="headerlink" title="奔驰抽象类"></a>奔驰抽象类</h5><p>奔驰车与宝马车类似，都已经有清晰品牌定义，但是型号还没有确认，也是一个抽象的产品类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAbsBenz :public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAbsBenz() &#123; msBand = &quot;奔驰汽车&quot;; &#125;</span><br><span class="line">    ~CAbsBenz()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //奔驰车</span><br><span class="line">    string msGetBand()&#123; return msBand; &#125;</span><br><span class="line"></span><br><span class="line">    // 型号由具体的实现类实现</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰商务车"><a href="#奔驰商务车" class="headerlink" title="奔驰商务车"></a>奔驰商务车</h5><p>由于分类的标准是相同的，因此奔驰车也应该有商务车和运动车两个类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBenzVan : public CAbsBenz</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzVan()&#123; msModel = &quot;R系列商务车&quot;; &#125;;</span><br><span class="line">    ~CBenzVan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰SUV"><a href="#奔驰SUV" class="headerlink" title="奔驰SUV"></a>奔驰SUV</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBenzSuv : public CAbsBenz</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzSuv()&#123; msModel = &quot;G系列SUV&quot;; &#125;;</span><br><span class="line">    ~CBenzSuv()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>所有的产品类都已经实现了，剩下的工作就是要定义工厂类进行生产，由于产品类型多样，也导致了必须有多个工厂类来生产不同产品，首先就需要定义一个抽象工厂，声明每个工厂必须完成的职责。<br>抽象工厂定义了每个工厂必须生产两个类型车：SUV（运动车）和VAN（商务车），否则一个工厂就不能被实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CICarFactory()&#123;&#125;;</span><br><span class="line">    ~CICarFactory()&#123;&#125;;</span><br><span class="line">    virtual CICar * mopCreateSuv() = 0;</span><br><span class="line">    virtual CICar * mopCreateVan() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="宝马车工厂"><a href="#宝马车工厂" class="headerlink" title="宝马车工厂"></a>宝马车工厂</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CBMWFactory : public CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWFactory()&#123;&#125;;</span><br><span class="line">    ~CBMWFactory()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产SUV</span><br><span class="line">    CICar * mopCreateSuv() &#123; return new CBMWSuv; &#125;</span><br><span class="line"></span><br><span class="line">    //生产商务车</span><br><span class="line">    CICar * mopCreateVan() &#123; return new CBMWVan; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单，你要我生产宝马商务车，没问题，直接产生一个宝马商务车对象，返回给调用者，这对调用者来说根本不需要关心到底是怎么生产的，它只要找到一个宝马工厂，即可生产出自己需要的产品（汽车）。</p>
<h5 id="奔驰车工厂"><a href="#奔驰车工厂" class="headerlink" title="奔驰车工厂"></a>奔驰车工厂</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CBenzFactory : public CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzFactory()&#123;&#125;;</span><br><span class="line">    ~CBenzFactory()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产SUV</span><br><span class="line">    CICar * mopCreateSuv() &#123; return new CBenzSuv; &#125;</span><br><span class="line"></span><br><span class="line">    //生产商务车</span><br><span class="line">    CICar * mopCreateVan() &#123; return new CBenzVan; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用场景"><a href="#调用场景" class="headerlink" title="调用场景"></a>调用场景</h5><p>产品和工厂都具备了，剩下的工作就是建立一个场景类模拟调用者调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //要求生产一辆奔驰SUV</span><br><span class="line">    cout &lt;&lt; &quot;===要求生产一辆奔驰SUV===&quot; &lt;&lt; endl;</span><br><span class="line">    //首先找到生产奔驰车的工厂</span><br><span class="line">    cout &lt;&lt; &quot;A、 找到奔驰车工厂&quot; &lt;&lt; endl;</span><br><span class="line">    CICarFactory *op_factory = new CBenzFactory;</span><br><span class="line">    //开始生产奔驰SUV</span><br><span class="line">    cout &lt;&lt; &quot;B、 开始生产奔驰SUV&quot; &lt;&lt; endl;</span><br><span class="line">    CICar *op_benz_suv = op_factory-&gt;mopCreateSuv();</span><br><span class="line">    //生产完毕， 展示一下车辆信息</span><br><span class="line">    cout &lt;&lt; &quot;C、 生产出的汽车如下： &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;汽车品牌： &quot; &lt;&lt; op_benz_suv-&gt;msGetBand().c_str() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;汽车型号： &quot; &lt;&lt; op_benz_suv-&gt;msGetModel().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/2018/08/13/模式PK/1534121943512.png" alt=""></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>对外界调用者来说，只要更换一个具备相同结构的对象，即可发生非常大的改变，如我们原本使用BenzFactory生产汽车，但是过了一段时间后，我们的系统需要生产宝马汽车，这对系统来说不需要很大的改动，只要把工厂类使用BMWFactory代替即可，立刻可以生产出宝马车，注意这里生产的是一辆完整的车，对于一个产品，只要给出产品代码（车类型）即可生产，抽象工厂模式把一辆车认为是一个完整的、不可拆分的对象。它注重完整性，一个产品一旦找到一个工厂生产，那就是固定的型号，不会出现一个宝马工厂生产奔驰车的情况。</p>
<h4 id="造者模式生产车辆"><a href="#造者模式生产车辆" class="headerlink" title="造者模式生产车辆"></a>造者模式生产车辆</h4><p>那现在的问题是我们就想要一辆混合的车型，如奔驰的引擎，宝马的车轮，那该怎么处理呢？使用我们的建造者模式！</p>
<h5 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h5><p>按照建造者模式设计一个生产车辆需要把车辆进行拆分，拆分成引擎和车轮两部分，然后由建造者进行建造，想要什么车，你只要有设计图纸就成，马上可以制造一辆车出来。它注重的是对零件的装配、组合、封装，它从一个细微构件装配角度看待一个对象。我们来看生产车辆的类图。</p>
<p><img src="/2018/08/13/模式PK/1534121951198.png" alt=""></p>
<p>注意看我们类图中的蓝图类Blueprint，它负责对产品建造过程定义。既然要生产产品，那必然要对产品进行一个描述，在类图中我们定义了一个接口来描述汽车。<br>车辆产品描述，我们定义一辆车必须有车轮和引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //汽车车轮</span><br><span class="line">    virtual string msGetWheel() = 0;</span><br><span class="line">    //汽车引擎</span><br><span class="line">    virtual string msGetEngine() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><h5 id="具体车辆"><a href="#具体车辆" class="headerlink" title="具体车辆"></a>具体车辆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CCar : public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CCar(const string &amp;sEngine, const string &amp;sWheel)</span><br><span class="line">    &#123;</span><br><span class="line">        msEngine = sEngine;</span><br><span class="line">        msWheel = sWheel;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~CCar()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //汽车车轮</span><br><span class="line">    string msGetWheel()  &#123; return msWheel;  &#125;;</span><br><span class="line">    //汽车引擎</span><br><span class="line">    string msGetEngine() &#123; return msEngine;  &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetInfo()&#123; return &quot;车的轮子是： &quot; + msWheel + &quot;\n车的引擎是： &quot; + msEngine; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //汽车引擎</span><br><span class="line">    string msEngine;</span><br><span class="line">    //汽车车轮</span><br><span class="line">    string msWheel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单定义产品的属性，明确对产品的描述。我们继续来思考，因为我们的产品是比较抽象的，它没有指定引擎的型号，也没有指定车轮的牌子，那么这样的组合方式有很多，完全要靠建造者来建造，建造者说要生产一辆奔驰SUV那就得用奔驰的引擎和奔驰的车轮，该建造者对于一个具体的产品来说是绝对的权威，我们来描述一下建造者。</p>
<h5 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CCarBuilder() &#123;&#125;;</span><br><span class="line">    ~CCarBuilder()&#123;&#125;;</span><br><span class="line">    // 接收一份设计蓝图</span><br><span class="line">    void mvSetBlueprint(CBlueprint *opBlueprint)&#123; mopBluprint = opBlueprint; &#125;;</span><br><span class="line">    CCar *mopBuildCar() &#123; return new CCar(msBuildEngine(), msBuildWheel()); &#125;;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // 查看蓝图， 只有真正的建造者才可以查看蓝图</span><br><span class="line">    CBlueprint *mopGetBlueprint() &#123; return mopBluprint; &#125;;</span><br><span class="line">    virtual string msBuildWheel() = 0;</span><br><span class="line">    virtual string msBuildEngine() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    //设计蓝图</span><br><span class="line">    CBlueprint *mopBluprint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到Blueprint类了，它中文的意思是“蓝图”，你要建造一辆车必须有一个设计样稿或者蓝图吧，否则怎么生产？怎么装配？该类就是一个可参考的生产样本。</p>
<h5 id="生产蓝图"><a href="#生产蓝图" class="headerlink" title="生产蓝图"></a>生产蓝图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CBlueprint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string msGetWheel()&#123; return msWheel; &#125;</span><br><span class="line">    void mvSetWheel(const string &amp;sWheel)&#123; msWheel = sWheel; &#125;</span><br><span class="line"></span><br><span class="line">    string msGetEngine()&#123; return msEngine; &#125;</span><br><span class="line">    void mvSetEngine(const string &amp;sEngine) &#123; msEngine = sEngine; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msWheel;</span><br><span class="line">    string msEngine;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这和一个具体的产品Car类是一样的？错，不一样！它是一个蓝图，是一个可以参考的模板，有一个蓝图可以设计出非常多的产品，如有一个R系统的奔驰商务车设计蓝图，我们就可以生产出一系列的奔驰车。它指导我们的产品生产，而不是一个具体的产品。我们来看宝马车建造车间。</p>
<h5 id="宝马车建造车间"><a href="#宝马车建造车间" class="headerlink" title="宝马车建造车间"></a>宝马车建造车间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBMWBuilder : public CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWBuilder()&#123;&#125;;</span><br><span class="line">    ~CBMWBuilder()&#123;&#125;;</span><br><span class="line">    string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125;</span><br><span class="line">    string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是非常简单的类。只要获得一个蓝图，然后按照蓝图制造引擎和车轮即可，剩下的事情就交给抽象的建造者进行装配。奔驰车间与此类似。</p>
<h5 id="奔驰车建造车间"><a href="#奔驰车建造车间" class="headerlink" title="奔驰车建造车间"></a>奔驰车建造车间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBenzBuilder : public CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzBuilder()&#123;&#125;;</span><br><span class="line">    ~CBenzBuilder()&#123;&#125;;</span><br><span class="line">    string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125;</span><br><span class="line">    string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个建造车间都已经完成，那现在的问题就变成了怎么让车间运作，谁来编写蓝图？谁来协调生产车间？谁来对外提供最终产品？于是导演类出场了，它不仅仅有每个车间需要的设计蓝图，还具有指导不同车间装配顺序的职责。</p>
<h5 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class CDirector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDirector()</span><br><span class="line">    &#123;</span><br><span class="line">        mopBenzBuilder = new CBenzBuilder;</span><br><span class="line">        mopBMWBuilder = new CBMWBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~CDirector()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产奔驰SUV</span><br><span class="line">    CCar *mopCreateBenzSuv()</span><br><span class="line">    &#123;</span><br><span class="line">        //制造出汽车</span><br><span class="line">        return mopCreateCar(mopBenzBuilder, &quot;benz的引擎&quot;, &quot;benz的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生产出一辆宝马商务车</span><br><span class="line">    CCar *mopCreateBMWVan()</span><br><span class="line">    &#123;</span><br><span class="line">        return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;BMW的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生产出一个混合车型</span><br><span class="line">    CCar *mopCreateComplexCar()</span><br><span class="line">    &#123;</span><br><span class="line">        return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;benz的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">     // 生产车辆</span><br><span class="line">     CCar *mopCreateCar(CCarBuilder *opCarBuilder, const string &amp;sEngine, const string &amp;sWheel)</span><br><span class="line">     &#123;</span><br><span class="line">        //导演怀揣蓝图</span><br><span class="line">         CBlueprint *op_bp = new CBlueprint();</span><br><span class="line">         op_bp-&gt;mvSetEngine(sEngine);</span><br><span class="line">         op_bp-&gt;mvSetWheel(sWheel);</span><br><span class="line">        opCarBuilder-&gt;mvSetBlueprint(op_bp);</span><br><span class="line"></span><br><span class="line">        return opCarBuilder-&gt;mopBuildCar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CCarBuilder *mopBenzBuilder;</span><br><span class="line">    CCarBuilder *mopBMWBuilder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有一个私有方法mopCreateCar，其作用是减少导演类中的方法对蓝图的依赖，全部由该方法来完成。</p>
<h5 id="场景调用"><a href="#场景调用" class="headerlink" title="场景调用"></a>场景调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义出导演类</span><br><span class="line">    CDirector o_director;</span><br><span class="line"></span><br><span class="line">    //给我一辆奔驰车SUV</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆奔驰SUV===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_benz_suv = o_director.mopCreateBenzSuv();</span><br><span class="line">    cout &lt;&lt; op_benz_suv-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //给我一辆宝马商务车</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆宝马商务车===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_bmw_van = o_director.mopCreateBMWVan();</span><br><span class="line">    cout &lt;&lt; op_bmw_van-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //给我一辆混合车型</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆混合车===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_complex_car = o_director.mopCreateComplexCar();</span><br><span class="line">    cout &lt;&lt; op_complex_car-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h5><p>场景类只要找到导演类（也就是车间主任了）说给我制造一辆这样的宝马车，车间主任马上通晓你的意图，设计了一个蓝图，然后命令建造车间拼命加班加点建造，最终返回给你一件最新出品的产品，运行结果如下所示</p>
<p><img src="/2018/08/13/模式PK/1534122001067.png" alt=""></p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>注意最后一个运行结果片段，我们可以立刻生产出一辆混合车型，只要有设计蓝图，这非常容易实现。反观我们的抽象工厂模式，它是不可能实现该功能的，因为它更关注的是整体，而不关注到底用的是奔驰引擎还是宝马引擎，而我们的建造者模式却可以很容易地实现该设计，市场信息变更了，我们就可以立刻跟进，生产出客户需要的产品。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>注意看上面的描述，我们在抽象工厂模式中使用“工厂”来描述构建者，而在建造者模式中使用“车间”来描述构建者，其实我们已经在说它们两者的区别了，抽象工厂模式就好比是一个一个的工厂，宝马车工厂生产宝马SUV和宝马VAN，奔驰车工厂生产奔驰车SUV和奔驰VAN，它是从一个更高层次去看对象的构建，具体到工厂内部还有很多的车间，如制造引擎的车间、装配引擎的车间等，但这些都是隐藏在工厂内部的细节，对外不公布。也就是对领导者来说，他只要关心一个工厂到底是生产什么产品的，不用关心具体怎么生产。而建造者模式就不同了，它是由车间组成，不同的车间完成不同的创建和装配任务，一个完整的汽车生产过程需要引擎制造车间、引擎装配车间的配合才能完成，它们配合的基础就是设计蓝图，而这个蓝图是掌握在车间主任（导演类）手中，它给建造车间什么蓝图就能生产什么产品，建造者模式更关心建造过程。虽然从外界看来一个车间还是生产车辆，但是这个车间的转型是非常快的，只要重新设计一个蓝图，即可产生不同的产品，这有赖于建造者模式的功劳。</p>
<p>相对来说，抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。</p>
<h3 id="工厂模式VS建造者模式"><a href="#工厂模式VS建造者模式" class="headerlink" title="工厂模式VS建造者模式"></a>工厂模式VS建造者模式</h3><blockquote>
<p><a href="http://www.cnblogs.com/ChinaHook/p/7471470.html" target="_blank" rel="noopener">工厂模式VS建造者模式</a><br>Create by bingcaihaung</p>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，才能创造一个超人。</p>
<h4 id="工厂方法建造超人"><a href="#工厂方法建造超人" class="headerlink" title="工厂方法建造超人"></a>工厂方法建造超人</h4><h5 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h5><p>首先我们按照工厂方法创造超人，我们来看类图。类图中我们按照年龄段把超人分为两种类型：成年超人（如克拉克、超能先生）和未成年超人（如Dash、Jack）。这是一个非常正宗的工厂方法模式，定义一个产品的接口，然后再定义两个实现，通过超人制造工厂制造超人。</p>
<p><img src="/2018/08/13/模式PK/1534122092060.png" alt=""></p>
<h5 id="抽象超人"><a href="#抽象超人" class="headerlink" title="抽象超人"></a>抽象超人</h5><p>想想看我们对超人最大印象是什么？当然是他的超能力，我们以specialTalent（特殊天赋）方法来代表，先看抽象产品类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISuperMan()&#123;&#125;;</span><br><span class="line">    ~CISuperMan()&#123;&#125;;</span><br><span class="line">    virtual void mvSpecialTalent() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="成年超人"><a href="#成年超人" class="headerlink" title="成年超人"></a>成年超人</h5><p>产品的接口定义好了，我们再来看具体的产品。先看成年超人，很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CAdultSuperMan : public CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAdultSuperMan()&#123;&#125;;</span><br><span class="line">    ~CAdultSuperMan()&#123;&#125;;</span><br><span class="line">    void mvSpecialTalent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;超人力大无穷&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="未成年超人"><a href="#未成年超人" class="headerlink" title="未成年超人"></a>未成年超人</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ChildSuperMan : public CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ChildSuperMan()&#123;&#125;;</span><br><span class="line">    ~ChildSuperMan()&#123;&#125;;</span><br><span class="line">    void mvSpecialTalent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;小超人的能力是刀枪不入、 快速运动&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h5><p>产品都具备，那我们编写一个工厂类，其意图就是生产超人，具体是成年超人还是未成年超人，则由客户端决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class CSuperManFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CSuperManFactory()&#123;&#125;;</span><br><span class="line">    ~CSuperManFactory()&#123;&#125;;</span><br><span class="line">    CISuperMan *mopCreateSuperMan(string sType)</span><br><span class="line">    &#123;</span><br><span class="line">        if (&quot;adult&quot; == sType)</span><br><span class="line">        &#123;</span><br><span class="line">            return new CAdultSuperMan;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (&quot;child&quot; == sType)</span><br><span class="line">        &#123;</span><br><span class="line">            return new CChildSuperMan;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>产品有了，工厂类也有了，剩下的工作就是开始生产超人。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CSuperManFactory o_factory;</span><br><span class="line">    CISuperMan *op_super = o_factory.mopCreateSuperMan(&quot;adult&quot;);</span><br><span class="line">    op_super-&gt;mvSpecialTalent();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>建立了一个超人生产工厂，年复一年地生产超人，对于具体生产出的产品，不管是成年超人还是未成年超人，都是一个模样：深蓝色紧身衣、胸前S标记、内裤外穿，没有特殊的地方。但是我们的目的达到了——生产出超人，这就是我们的意图。具体怎么生产、怎么组装，这不是工厂方法模式要考虑的，也就是说，工厂模式关注的是一个产品整体，生产出的产品应该具有相似的功能和架构。</p>
<p>注意：通过工厂方法模式生产出对象，然后由客户端进行对象的其他操作，但是并不代表所有生产出的对象都必须具有相同的状态和行为，它是由产品所决定。</p>
<h4 id="建造者模式建造超人"><a href="#建造者模式建造超人" class="headerlink" title="建造者模式建造超人"></a>建造者模式建造超人</h4><h5 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h5><p>我们在抽象建造者上使用了模板方法模式，每一个建造者都必须返回一个产品，但是产品是如何制造的，则由各个建造者自己负责。</p>
<p><img src="/2018/08/13/模式PK/1534122128745.png" alt=""></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><h5 id="产品类-1"><a href="#产品类-1" class="headerlink" title="产品类"></a>产品类</h5><p>超人这个产品是由三部分组成：躯体、特殊技能、身份标记，这就类似于电子产品，首先生产出一个固件，然后再安装一个灵魂（软件驱动），最后再打上产品标签。一个崭新的产品就诞生。我们的超人也是这样生产的，先生产一个普通的躯体，然后注入特殊技能，最后打上S标签，一个超人生产完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CSuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CSuperMan()&#123;&#125;;</span><br><span class="line">    ~CSuperMan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetBody() &#123; return msBody; &#125;;</span><br><span class="line">    void mvSetBody(const string &amp;sBody) &#123; msBody = sBody; &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetSpecialTalent() &#123; return msSpecialTalent; &#125;;</span><br><span class="line">    void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; msSpecialTalent = sSpecialTalent; &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetSpecialSymbol() &#123; return msSpecialSymbol; &#125;;</span><br><span class="line">    void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; msSpecialSymbol = sSpecialSymbol; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBody;             //超人的躯体</span><br><span class="line">    string msSpecialTalent;    //超人的特殊技能</span><br><span class="line">    string msSpecialSymbol;    //超人的标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象建造者-1"><a href="#抽象建造者-1" class="headerlink" title="抽象建造者"></a>抽象建造者</h5><p>一个典型的模板方法模式，超人的各个部件（躯体、灵魂、标志）都准备好了，具体怎么组装则是由实现类来决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CBuilder</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    CBuilder() &#123; mopSuperMan = new CSuperMan; &#125;;</span><br><span class="line">    ~CBuilder();</span><br><span class="line"></span><br><span class="line">    void mvSetBody(const string &amp;sBody) &#123; this-&gt;mopSuperMan-&gt;mvSetBody(sBody); &#125;;</span><br><span class="line">    void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialTalent(sSpecialTalent); &#125;;</span><br><span class="line">    void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialSymbol(sSpecialSymbol); &#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual CSuperMan  *mopGetSuperMan() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    CSuperMan *mopSuperMan;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="成年超人-1"><a href="#成年超人-1" class="headerlink" title="成年超人"></a>成年超人</h5><p>设计模式只是提供了一个解决问题的意图：复杂对象的构建与它的表示分离，而没有具体定出一个设计模式必须是这样的实现，必须是这样的代码，灵活运用模式才是其根本，我们通过模版方法加上建造者模式来建造超人。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAdultSuperManBuilder : public CBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAdultSuperManBuilder()&#123;&#125;;</span><br><span class="line">    ~CAdultSuperManBuilder()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CSuperMan  *mopGetSuperMan()</span><br><span class="line">    &#123;</span><br><span class="line">        mvSetBody(&quot;强壮的躯体&quot;);</span><br><span class="line">        mvSetSpecialTalent(&quot;会飞行&quot;);</span><br><span class="line">        mvSetSpecialSymbol(&quot;胸前带S标记&quot;);</span><br><span class="line"></span><br><span class="line">        return mopSuperMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="未成年超人-1"><a href="#未成年超人-1" class="headerlink" title="未成年超人"></a>未成年超人</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CChildSuperManBuilder : public CBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CChildSuperManBuilder()&#123;&#125;;</span><br><span class="line">    ~CChildSuperManBuilder()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CSuperMan  *mopGetSuperMan()</span><br><span class="line">    &#123;</span><br><span class="line">        mvSetBody(&quot;强壮的躯体&quot;);</span><br><span class="line">        mvSetSpecialTalent(&quot;刀枪不入&quot;);</span><br><span class="line">        mvSetSpecialSymbol(&quot;胸前带S标记&quot;);</span><br><span class="line"></span><br><span class="line">        return mopSuperMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大家注意看我们这两个具体的建造者，它们都关注了产品的各个部分，在某些应用场景下甚至会关心产品的构建顺序，即使是相同的部件，装配顺序不同，产生的结果也不同，这也正是建造者模式的意图：通过不同的部件、不同装配产生不同的复杂对象。</p>
<h5 id="导演类-1"><a href="#导演类-1" class="headerlink" title="导演类"></a>导演类</h5><p>导演类很简单就不多说了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CDirector &#123;</span><br><span class="line">public:</span><br><span class="line">    CDirector()&#123;&#125;;</span><br><span class="line">    ~CDirector()&#123;&#125;;</span><br><span class="line">    //两个建造者的应用</span><br><span class="line">    CBuilder *mopAdultBuilder = new CAdultSuperManBuilder();</span><br><span class="line">    //未成年超人的建造者</span><br><span class="line">    CBuilder *CChildBuilder = new CChildSuperManBuilder();</span><br><span class="line">    //建造一个成年、 会飞行的超人</span><br><span class="line">    CSuperMan *mopGetAdultSuperMan()&#123; return mopAdultBuilder-&gt;mopGetSuperMan();     &#125;</span><br><span class="line">    // 建造一个未成年、 刀枪不入的超人</span><br><span class="line">    CSuperMan *mopGetChildSuperMan()&#123; return CChildBuilder-&gt;mopGetSuperMan(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="场景调用-1"><a href="#场景调用-1" class="headerlink" title="场景调用"></a>场景调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CDirector o_director;</span><br><span class="line"></span><br><span class="line">    //建造一个成年超人</span><br><span class="line">    CSuperMan *op_adult = o_director.mopGetAdultSuperMan();</span><br><span class="line"></span><br><span class="line">    // 展示超人信息</span><br><span class="line">    cout &lt;&lt; op_adult-&gt;msGetSpecialTalent().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个场景类的写法与工厂方法模式是相同的，但是你可以看到，在建立超人的过程中，建造者必须关注超人的各个部件，而工厂方法模式则只关注超人的整体，这就是两者的区别。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>工厂方法模式和建造者模式都属于对象创建类模式，都用来创建类的对象。但它们之间的区别还是比较明显的。</p>
<ul>
<li>意图不同</li>
</ul>
<p>在工厂方法模式里，我们关注的是一个产品整体，如超人整体，无须关心产品的各部分是如何创建出来的；但在建造者模式中，一个具体产品的产生是依赖各个部件的产生以及装配顺序，它关注的是“由零件一步一步地组装出产品对象”。简单地说，工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注的是产品组成部分的创建过程。</p>
<ul>
<li>产品的复杂度不同</li>
</ul>
<p>工厂方法模式创建的产品一般都是单一性质产品，如成年超人，都是一个模样，而建造者模式创建的则是一个复合产品，它由各个部件复合而成，部件不同产品对象当然不同。这不是说工厂方法模式创建的对象简单，而是指它们的粒度大小不同。一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。</p>
<p>两者的区别有了，那在具体的应用中，我们该如何选择呢？是用工厂方法模式来创建对象，还是用建造者模式来创建对象，这完全取决于我们在做系统设计时的意图，如果需要详细关注一个产品部件的生产、安装步骤，则选择建造者，否则选择工厂方法模式。</p>
<h3 id="装饰模式VS适配器模式"><a href="#装饰模式VS适配器模式" class="headerlink" title="装饰模式VS适配器模式"></a>装饰模式VS适配器模式</h3><blockquote>
<p><a href="http://www.cnblogs.com/ChinaHook/p/7475540.html" target="_blank" rel="noopener">装饰模式VS适配器模式</a></p>
</blockquote>
<h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。</p>
<p>大家都应该听过丑小鸭的故事吧，我们今天就用这两种模式分别讲述丑小鸭的故事。话说鸭妈妈有5个孩子，其中4个孩子都是黄白相间的颜色，而最小的那只也就是叫做丑小鸭的那只，是纯白色的，与兄弟姐妹不相同，在遭受了诸多的嘲讽和讥笑后，最终丑小鸭变成了一只美丽的天鹅。那我们如何用两种不同模式来描述这一故事呢？</p>
<h4 id="装饰模式描述丑小鸭"><a href="#装饰模式描述丑小鸭" class="headerlink" title="装饰模式描述丑小鸭"></a>装饰模式描述丑小鸭</h4><h5 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h5><p>用装饰模式来描述丑小鸭，首先就要肯定丑小鸭是一只天鹅，只是因为她小或者是鸭妈妈的无知才没有被认出是天鹅，经过一段时间后，它逐步变成一个漂亮、自信、优美的白天鹅。根据分析我们可以这样设计，先设计一个丑小鸭，然后根据时间先后来进行不同的美化处理，怎么美化呢？先长出漂亮的羽毛，然后逐步展现出异于鸭子的不同行为，如飞行，最终在具备了所有的行为后，它就成为一只纯粹的白天鹅了。类图比较简单，非常标准的装饰模式。</p>
<p><img src="/2018/08/13/模式PK/1534122187586.png" alt=""></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="天鹅接口"><a href="#天鹅接口" class="headerlink" title="天鹅接口"></a>天鹅接口</h5><p>我们按照故事的情节发展一步一步地实现程序。初期的时候，丑小鸭表现得很另类，叫声不同，外形不同，致使周围的亲戚、朋友都对她鄙视，那我们来建立这个过程，由于丑小鸭的本质就是一个天鹅，我们就先生成一个天鹅的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISwan()&#123;&#125;;</span><br><span class="line">    ~CISwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //天鹅会飞</span><br><span class="line">    virtual  void mvFly() = 0;</span><br><span class="line">    //天鹅会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line">    //天鹅都有漂亮的外表</span><br><span class="line">    virtual void mvDesAppaearance() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="丑小鸭"><a href="#丑小鸭" class="headerlink" title="丑小鸭"></a>丑小鸭</h5><p>我们定义了天鹅的行为，都会飞行、会叫，并且可以描述她们漂亮的外表。丑小鸭是一只白天鹅，是”is-a”的关系，也就是需要实现这个接口了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CUglyDuckling : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CUglyDuckling()&#123;&#125;;</span><br><span class="line">    ~CUglyDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //丑小鸭的叫声</span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    //丑小鸭的外形</span><br><span class="line">    void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是脏兮兮的白色， 毛茸茸的大脑袋&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    //丑小鸭还比较小，不能飞</span><br><span class="line">    void mvFly()&#123; cout &lt;&lt; &quot;不能飞行&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象装饰类"><a href="#抽象装饰类" class="headerlink" title="抽象装饰类"></a>抽象装饰类</h5><p>丑小鸭具备了天鹅的所有行为和属性，因为她本来就是一只白天鹅，只是因为她太小了还不能飞行，也不能照顾自己，所以丑丑的，在经过长时间的流浪生活后，丑小鸭长大了。终于有一天，她发现自己竟然变成了一只美丽的白天鹅，有着漂亮、洁白的羽毛，而且还可以飞行，这完全是一种升华行为。我们来看看她的行为（飞行）和属性（外形）是如何加强的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CDecorator : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDecorator(CISwan *opSwan)&#123; mopSwan = opSwan; &#125;;</span><br><span class="line">    ~CDecorator()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual void mvCry() &#123; mopSwan-&gt;mvCry(); &#125;</span><br><span class="line">    virtual void mvFly() &#123; mopSwan-&gt;mvFly(); &#125;</span><br><span class="line">    virtual void mvDesAppaearance() &#123; mopSwan-&gt;mvDesAppaearance(); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CISwan *mopSwan;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="外形装饰"><a href="#外形装饰" class="headerlink" title="外形装饰"></a>外形装饰</h5><p>这是一个非常简单的代理模式。我们再来看丑小鸭是如何开始变得美丽的，变化是由外及里的，有了漂亮的外表才有内心的实质变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBeautifyAppearance : public CDecorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBeautifyAppearance(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 外表美化处理</span><br><span class="line">    void mvDesAppaearance() override &#123; cout &lt;&lt; &quot;外表是纯白色的，非常惹人喜爱！&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="行为装饰"><a href="#行为装饰" class="headerlink" title="行为装饰"></a>行为装饰</h5><p>丑小鸭最后发现自己还能飞行，这是一个行为突破，是对原有行为“不会飞行”的一种强化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CStrongBehavior : public CDecorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CStrongBehavior(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;;</span><br><span class="line">    ~CStrongBehavior()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 会飞行了</span><br><span class="line">    void mvFly() override &#123; cout &lt;&lt; &quot;会飞行了！&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="场景调用-2"><a href="#场景调用-2" class="headerlink" title="场景调用"></a>场景调用</h5><p>所有的故事元素我们都具备了，就等有人来讲故事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //很久很久以前， 这里有一个丑陋的小鸭子</span><br><span class="line">    cout &lt;&lt; &quot;===很久很久以前， 这里有一只丑陋的小鸭子===&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CISwan *op_duck = new CUglyDuckling;</span><br><span class="line">    //展示一下小鸭子</span><br><span class="line">    op_duck-&gt;mvDesAppaearance();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvFly();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;===小鸭子终于发现自己是一只天鹅====&quot; &lt;&lt; endl;</span><br><span class="line">    //首先外形变化了</span><br><span class="line">    op_duck = new CBeautifyAppearance(op_duck);</span><br><span class="line">    //其次行为也发生了改变</span><br><span class="line">    op_duck = new CStrongBehavior(op_duck);</span><br><span class="line">    //虽然还是叫丑小鸭， 但是已经发生了很大变化</span><br><span class="line">    op_duck-&gt;mvDesAppaearance();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvFly();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/2018/08/13/模式PK/1534122227827.png" alt=""></p>
<p>使用装饰模式描述丑小鸭蜕变的过程是如此简单，它关注了对象功能的强化，是对原始对象的行为和属性的修正和加强，把原本被人歧视、冷落的丑小鸭通过两次强化处理最终转变为受人喜爱、羡慕的白天鹅。</p>
<h4 id="适配器模式实现丑小鸭"><a href="#适配器模式实现丑小鸭" class="headerlink" title="适配器模式实现丑小鸭"></a>适配器模式实现丑小鸭</h4><h5 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h5><p>采用适配器模式实现丑小鸭变成白天鹅的过程要从鸭妈妈的角度来分析，鸭妈妈有5个孩子，它认为这5个孩子都是她的后代，都是鸭类，但是实际上是有一只（也就是丑小鸭）不是真正的鸭类，她是一只小白天鹅，因为太小，差别太细微，很难分辨，导致鸭妈妈认为她是一只鸭子，从鸭子的审美观来看，丑小鸭是丑陋的。通过分析，我们要做的就是要设计两个对象：鸭和天鹅，然后鸭妈妈把一只天鹅看成了小鸭子，最终时间到来的时候丑小鸭变成了白天鹅。</p>
<p><img src="/2018/08/13/模式PK/1534122243332.png" alt=""></p>
<p>类图非常简单，我们定义了两个接口：鸭类接口和天鹅类接口，然后建立了一个适配器UglyDuckling，把一只白天鹅封装成了小鸭子。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><h5 id="鸭类接口"><a href="#鸭类接口" class="headerlink" title="鸭类接口"></a>鸭类接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CIDuck()&#123;&#125;;</span><br><span class="line">    ~CIDuck()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line"></span><br><span class="line">    //鸭子的外形</span><br><span class="line">    virtual void mvDesAppearance() = 0;</span><br><span class="line"></span><br><span class="line">    //描述鸭子的其他行为</span><br><span class="line">    virtual void mvDesBehavior() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>鸭类有3个行为，一个是鸭会叫，一个是外形描述，还有一个是综合性的其他行为描述，例如会游泳等。</p>
<h5 id="小鸭子"><a href="#小鸭子" class="headerlink" title="小鸭子"></a>小鸭子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CDuckling : public CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDuckling()&#123;&#125;;</span><br><span class="line">    ~CDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是嘎——嘎——嘎&quot; &lt;&lt; endl;  &#125;;</span><br><span class="line">    void mvDesAppearance() &#123; cout &lt;&lt; &quot;外形是黄白相间，嘴长&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    // 鸭子的其他行为， 如游泳</span><br><span class="line">    void mvDesBehavior() &#123; cout &lt;&lt; &quot;会游泳&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="白天鹅"><a href="#白天鹅" class="headerlink" title="白天鹅"></a>白天鹅</h5><p>4只正宗的小鸭子形象已经清晰地定义出来了。鸭妈妈还有一个孩子，就是另类的丑小鸭，她实际是一只白天鹅。我们先定义出白天鹅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISwan()&#123;&#125;;</span><br><span class="line">    ~CISwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //天鹅会飞</span><br><span class="line">    virtual  void mvFly() = 0;</span><br><span class="line">    //天鹅会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line">    //天鹅都有漂亮的外表</span><br><span class="line">    virtual void mvDesAppaearance() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CWhiteSwan : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CWhiteSwan()&#123;&#125;;</span><br><span class="line">    ~CWhiteSwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //白天鹅的叫声</span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    //白天鹅的外形</span><br><span class="line">    void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是纯白色，惹人喜爱&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    //天鹅是能够飞行的</span><br><span class="line">    void mvFly()&#123; cout &lt;&lt; &quot;能够飞行&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="当成鸭子的白天鹅"><a href="#当成鸭子的白天鹅" class="headerlink" title="当成鸭子的白天鹅"></a>当成鸭子的白天鹅</h5><p>但是，鸭妈妈却不认为自己这个另类的孩子是白天鹅，它从自己的观点出发，认为她很丑陋，有碍自己的脸面，于是驱赶她——鸭妈妈把这只小天鹅误认为一只鸭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class CUglyDuckling : public CWhiteSwan, public CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CUglyDuckling()&#123;&#125;;</span><br><span class="line">    ~CUglyDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    void mvCry() &#123; CWhiteSwan::mvCry(); &#125;;</span><br><span class="line">    void mvDesAppearance() &#123; CWhiteSwan::mvDesAppaearance(); &#125;;</span><br><span class="line">    void mvDesBehavior()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;会游泳！&quot; &lt;&lt; endl;</span><br><span class="line">        CWhiteSwan::mvFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h5><p>天鹅被看成了鸭子，有点暴殄天物的感觉。我们再来创建一个场景类来描述这一场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //鸭妈妈有5个孩子， 其中4个都是一个模样</span><br><span class="line">    cout &lt;&lt; &quot;===妈妈有五个孩子， 其中四个模样是这样的： ===&quot; &lt;&lt; endl;</span><br><span class="line">    CIDuck *op_duck = new CDuckling();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvDesAppearance();</span><br><span class="line">    op_duck-&gt;mvDesBehavior();</span><br><span class="line">    cout &lt;&lt; &quot;===一只独特的小鸭子， 模样是这样的： ===&quot; &lt;&lt; endl;</span><br><span class="line">    CIDuck *op_ugly_duck = new CUglyDuckling;</span><br><span class="line">    op_ugly_duck-&gt;mvCry();</span><br><span class="line">    op_ugly_duck-&gt;mvDesAppearance();</span><br><span class="line">    op_ugly_duck-&gt;mvDesBehavior();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/2018/08/13/模式PK/1534122278770.png" alt=""></p>
<p>小天鹅被认为是一只丑陋的小鸭子…采用适配器模式讲述丑小鸭的故事，我们首先观察到的是鸭与天鹅的不同点，建立了不同的接口以实现不同的物种，然后在需要的时候（根据故事情节）把一个物种伪装成另外一个物种，实现不同物种的相同处理过程，这就是适配器模式的设计意图。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>我们用两个模式实现了丑小鸭的美丽蜕变。我们发现：这两个模式有较多的不同点。</p>
<ul>
<li>意图不同</li>
</ul>
<p>装饰模式的意图是加强对象的功能，例子中就是把一个怯弱的小天鹅强化成了一个美丽、自信的白天鹅，它不改变类的行为和属性，只是增加（当然了，减弱类的功能也是可能存在的）功能，使美丽更加美丽，强壮更加强壮，安全更加安全；而适配器模式关注的则是转化，它的主要意图是两个不同对象之间的转化，它可以把一个天鹅转化为一个小鸭子看待，也可以把一只小鸭子看成是一只天鹅，它关注转换。</p>
<ul>
<li>施与对象不同</li>
</ul>
<p>装饰模式装饰的对象必须是自己的同宗，也就是相同的接口或父类，只要在具有相同的属性和行为的情况下，才能比较行为是增加还是减弱；适配器模式则必须是两个不同的对象，因为它着重于转换，只有两个不同的对象才有转换的必要，如果是相同对象还转换什么？！</p>
<ul>
<li>场景不同</li>
</ul>
<p>装饰模式在任何时候都可以使用，只要是想增强类的功能，而适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用。</p>
<ul>
<li>扩展性不同</li>
</ul>
<p>装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/C-编译器知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/C-编译器知识/" itemprop="url">C++编译器知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T00:41:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/C-编译器知识/" class="leancloud_visitors" data-flag-title="C++编译器知识">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LLVM、Clang介绍"><a href="#LLVM、Clang介绍" class="headerlink" title="LLVM、Clang介绍"></a>LLVM、Clang介绍</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>在正式开始之前，插播一段编译器和链接器。<br>编译器主要用于将源代码从高级语言翻译成低级语言（汇编语言、目标代码、机器码），输出目标文件。<br>链接器主要用于将一个或多个目标文件（obj）与库文件（lib）合并成一个可执行文件（exe）或者库文件（lib、dll等）。</p>
<p>编译器可分为前端（front end）和后端（back end），两者以中间代码（IR，Intermediate Representation）为分界。</p>
<p>也可划分成前端、中端和后端，这里的中端主要完成对IR的优化工作，输出仍为IR。</p>
<h3 id="LLVM与Clang"><a href="#LLVM与Clang" class="headerlink" title="LLVM与Clang"></a>LLVM与Clang</h3><p>LLVM全称为Low Level Virtual Machine，按wiki的说法，它是“a collection of modular and reusable compiler and toolchain technologies”，起初只支持C/C++，现已支持多种语言。提及LLVM可能指代的是LLVM project/infrastructure（框架，编译器各个环节对应项目的集合）、An LLVM-based compiler、LLVM libraries（库）、LLVM core（编译器的后端）、The LLVM IR，具体如下：</p>
<blockquote>
<ul>
<li><strong>The LLVM project/infrastructure</strong>: This is an umbrella for several projects that, together, form a complete compiler: frontends, backends, optimizers, assemblers, linkers, libc++, compiler-rt, and a JIT engine. The word “LLVM” has this meaning, for example, in the following sentence: “LLVM is comprised of several projects”.</li>
<li><strong>An LLVM-based compiler</strong>: This is a compiler built partially or completely with the LLVM infrastructure. For example, a compiler might use LLVM for the frontend and backend but use GCC and GNU system libraries to perform the final link. LLVM has this meaning in the following sentence, for example: “I used LLVM to compile C programs to a MIPS platform”.</li>
<li><strong>LLVM libraries</strong>: This is the reusable code portion of the LLVM infrastructure. For example, LLVM has this meaning in the sentence: “My project uses LLVM to generate code through its Just-in-Time compilation framework”.</li>
<li><strong>LLVM core</strong>: The optimizations that happen at the intermediate language level and the backend algorithms form the LLVM core where the project started. LLVM has this meaning in the following sentence: “LLVM and Clang are two different projects”.</li>
<li><strong>The LLVM IR</strong>: This is the LLVM compiler intermediate representation. LLVM has this meaning when used in sentences such as “I built a frontend that translates my own language to LLVM”.<br>——What exactly is LLVM</li>
</ul>
</blockquote>
<p>而Clang呢？Clang是a C language family frontend for LLVM，是C-like语言的编译器前端，支持C, C++, Objective C/C++, OpenCL C等。后端使用LLVM，现已兼容GCC——Clang.LLVM。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/我所理解的设计模式（C-实现）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/我所理解的设计模式（C-实现）/" itemprop="url">我所理解的设计模式（C++实现）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T12:37:53+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/09/我所理解的设计模式（C-实现）/" class="leancloud_visitors" data-flag-title="我所理解的设计模式（C++实现）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="我所理解的设计模式（C-实现）"><a href="#我所理解的设计模式（C-实现）" class="headerlink" title="我所理解的设计模式（C++实现）"></a>我所理解的设计模式（C++实现）</h2><p>###“一句话总结”和索引</p>
<blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/12117349" target="_blank" rel="noopener">“一句话总结”和索引</a></p>
</blockquote>
<p>我所理解的设计模式系列已经全部完成，在写该系列的过程中收获很多。俗话说得好，好记性不如烂笔头，写出来不单单可以增加自己对知识的理解，也可以很好的分享给大家，大家共同学习。这里是最后一篇，来给所有的设计模式来个一句话总结，在让我们“过电影”般在过一遍。</p>
<p><strong>按照目的来分，设计模式可以分为创建型模式、结构型模式和行为型模式。</strong></p>
<p>创建型模式用来处理对象的创建过程；结构型模式用来处理类或者对象的组合；行为型模式用来对类或对象怎样交互和怎样分配职责进行描述。</p>
<p><strong>创建型模式用来处理对象的创建过程，主要包含以下5种设计模式：</strong></p>
<ol>
<li>工厂方法模式（Factory Method Pattern）的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</li>
<li>抽象工厂模式（Abstract Factory Pattern）的意图是提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。</li>
<li>建造者模式（Builder Pattern）的意图是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li>
<li>原型模式（Prototype Pattern）是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li>
<li>单例模式（Singleton Pattern）是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
</ol>
<p><strong>结构型模式用来处理类或者对象的组合，主要包含以下7种设计模式：</strong></p>
<ol start="6">
<li>适配器模式（Adapter Pattern）是将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>桥接模式（Bridge Pattern）是将抽象部分与实际部分分离，使它们都可以独立的变化。</li>
<li>组合模式（Composite Pattern）是将对象组合成树形结构以表示“部分–整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。</li>
<li>装饰者模式（Decorator Pattern）动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。</li>
<li>外观模式（Facade Pattern）是为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>
<li>享元模式（Flyweight Pattern）是以共享的方式高效的支持大量的细粒度的对象。</li>
<li>代理模式（Proxy Pattern）就是为其他对象提供一种代理以控制对这个对象的访问。</li>
</ol>
<p><strong>行为型模式用来对类或对象怎样交互和怎样分配职责进行描述，主要包含以下11种设计模式：</strong></p>
<ol start="13">
<li>责任链模式（Chain of Responsibility Pattern），在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>
<li>命令模式（Command Pattern）是将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</li>
<li>解释器模式（Interpreter Pattern）就是描述了如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。</li>
<li>迭代器模式（Iterator Pattern）是提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li>
<li>中介者模式（Mediator Pattern）就是定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。</li>
<li>备忘录模式（Memento Pattern）是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li>
<li>观察者模式（Observer Pattern）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li>
<li>状态模式（State Pattern）就是允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。</li>
<li>策略模式（Strategy Pattern）就是准备一组算法，并将每一个算法封装起来，使得它们可以互换。</li>
<li>模板方法模式（Template Method Pattern）使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li>访问者模式（Visitor Pattern）就是表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。  </li>
</ol>
<h3 id="工厂方法模式（Factory-Method-Pattern）"><a href="#工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="工厂方法模式（Factory Method Pattern）"></a>工厂方法模式（Factory Method Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8712834" target="_blank" rel="noopener">工厂方法模式（Factory Method Pattern）</a></p>
</blockquote>
<p>工厂方法模式不同于简单工厂模式的地方在于工厂方法模式把对象的创建过程放到里子类里。这样工厂父对象和产品父对象一样，可以是抽象类或者接口，只定义相应的规范或操作，不涉及具体的创建或实现细节。</p>
<p>其类图如下：</p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789664935.png" alt=""></p>
<p>实例代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">class IProduct  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IProduct(void);  </span><br><span class="line">    virtual ~IProduct(void);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">#pragma once  </span><br><span class="line">#include &quot;iproduct.h&quot;  </span><br><span class="line">class IPad :  </span><br><span class="line">    public IProduct  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IPad(void);  </span><br><span class="line">    ~IPad(void);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">#pragma once  </span><br><span class="line">#include &quot;iproduct.h&quot;  </span><br><span class="line">class IPhone :  </span><br><span class="line">    public IProduct  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IPhone(void);  </span><br><span class="line">    ~IPhone(void);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">#include&quot;IProduct.h&quot;  </span><br><span class="line"></span><br><span class="line">class IFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IFactory(void);  </span><br><span class="line">    virtual ~IFactory(void);  </span><br><span class="line"></span><br><span class="line">    virtual IProduct* getProduct();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma once  </span><br><span class="line">#include &quot;ifactory.h&quot;  </span><br><span class="line">class IPadFactory :  </span><br><span class="line">    public IFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IPadFactory(void);  </span><br><span class="line">    ~IPadFactory(void);  </span><br><span class="line"></span><br><span class="line">    virtual IProduct* getProduct();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma once  </span><br><span class="line">#include &quot;ifactory.h&quot;  </span><br><span class="line">class IPhoneFactory :  </span><br><span class="line">    public IFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    IPhoneFactory(void);  </span><br><span class="line">    ~IPhoneFactory(void);  </span><br><span class="line"></span><br><span class="line">    virtual IProduct* getProduct();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;StdAfx.h&quot;  </span><br><span class="line">#include &quot;IPadFactory.h&quot;  </span><br><span class="line">#include&quot;IPad.h&quot;  </span><br><span class="line"></span><br><span class="line">IPadFactory::IPadFactory(void)  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IPadFactory::~IPadFactory(void)  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IProduct* IPadFactory::getProduct()  </span><br><span class="line">&#123;  </span><br><span class="line">    return new IPad();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#include &quot;StdAfx.h&quot;  </span><br><span class="line">#include &quot;IPhoneFactory.h&quot;  </span><br><span class="line">#include&quot;IPhone.h&quot;  </span><br><span class="line"></span><br><span class="line">IPhoneFactory::IPhoneFactory(void)  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IPhoneFactory::~IPhoneFactory(void)  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">IProduct* IPhoneFactory::getProduct()  </span><br><span class="line">&#123;  </span><br><span class="line">    return new IPhone();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include&quot;IFactory.h&quot;  </span><br><span class="line">#include&quot;IPadFactory.h&quot;  </span><br><span class="line">#include&quot;IPhoneFactory.h&quot;  </span><br><span class="line">#include&quot;IProduct.h&quot;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    IFactory *fac = new IPadFactory();  </span><br><span class="line">    IProduct *pro = fac-&gt;getProduct();  </span><br><span class="line"></span><br><span class="line">    fac = new IPhoneFactory();  </span><br><span class="line">    pro = fac-&gt;getProduct();  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h3><p><strong>解决的问题：</strong><br>在系统里a,b,c三个组件必须同时使用，但是a的同类 a1和a2这三种方法有共同特点但是是互斥的，b,b1,b2和c,c1,c2和a/a1/a2是一样的。就比如说创建在不同操作系统的视窗环境下都能够运行的系统时，Unix下面有unixButton和 unixText，Win下面也有winButton和winText，unixButton和unixText必须在一个系统unix里面用，而winButton和winText只能在Win下面用。但是winButton和unixButton这两种东西都是有相同的特点的，比如说按下去之后会触发事件，比如说他上面有文字描述等等，但是winButton和unixButton却又是不可以混用的。</p>
<p>那么此问题就可以用抽象工厂很好的解决：<br>在抽象工厂模式中如何选择使用 winButton ,winText，有具体的工厂类winFactory来负责，因为他们含有选择合适的产品对象的逻辑，所以是与应用系统的商业逻辑紧密相关的。而抽象工厂类来负责定义接口，他才是抽象工厂模式的核心。<br>而winButton/macButton则是一种产品族，有共同的特点，他们具体特点有抽象产品类或者接口来定义和描述。但是他们具体的实现有具体的产品类负责，这些是客户端最终想要的东西，所以其内部一定充满了应用系统的商业逻辑（触发逻辑/样式逻辑等）。</p>
<p>类图结构：  </p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789694008.png" alt=""></p>
<p>样例实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">// CplusplusAbstractFactory.cpp : Defines the entry point for the console application.  </span><br><span class="line">//  </span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include&lt;typeinfo&gt;  </span><br><span class="line">// &quot;AbstractProductA&quot; 草食动物  </span><br><span class="line">class Herbivore  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;AbstractProductB&quot; 食肉动物  </span><br><span class="line">class Carnivore  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    virtual void Eat( Herbivore *h ) &#123;&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ProductA1&quot;  </span><br><span class="line">class Wildebeest : public Herbivore  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ProductA2&quot;  </span><br><span class="line">class Bison : public Herbivore  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ProductB1&quot;  </span><br><span class="line">class Lion : public Carnivore  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    void Eat( Herbivore *h )  </span><br><span class="line">    &#123;  </span><br><span class="line">        // eat wildebeest      </span><br><span class="line">        printf(&quot;Lion eats %s\n&quot;,typeid(h).name());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ProductB2&quot;  </span><br><span class="line">class Wolf : public Carnivore  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    void Eat( Herbivore *h )  </span><br><span class="line">    &#123;  </span><br><span class="line">        // Eat bison  </span><br><span class="line">        printf(&quot;Wolf eats %s\n&quot;,typeid(h).name());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;AbstractFactory&quot;  </span><br><span class="line">class ContinentFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    virtual Herbivore* CreateHerbivore()  </span><br><span class="line">    &#123;  </span><br><span class="line">        return new Herbivore();  </span><br><span class="line">    &#125;  </span><br><span class="line">    virtual Carnivore* CreateCarnivore()  </span><br><span class="line">    &#123;  </span><br><span class="line">        return new Carnivore();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ConcreteFactory1&quot;  </span><br><span class="line">class AfricaFactory : public ContinentFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    Herbivore* CreateHerbivore()  </span><br><span class="line">    &#123;   </span><br><span class="line">        return new Wildebeest();   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Carnivore* CreateCarnivore()  </span><br><span class="line">    &#123;   </span><br><span class="line">        return new Lion();   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">// &quot;ConcreteFactory2&quot;  </span><br><span class="line">class AmericaFactory : public ContinentFactory  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    // Methods  </span><br><span class="line">    Herbivore* CreateHerbivore()  </span><br><span class="line">    &#123;   </span><br><span class="line">        return new Bison();   </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    Carnivore* CreateCarnivore()  </span><br><span class="line">    &#123;   </span><br><span class="line">        return new Wolf();   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// &quot;Client&quot;  </span><br><span class="line">class AnimalWorld  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    // Fields  </span><br><span class="line">    Herbivore* herbivore;  </span><br><span class="line">    Carnivore* carnivore;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    // Constructors  </span><br><span class="line">    AnimalWorld( ContinentFactory *factory )  </span><br><span class="line">    &#123;  </span><br><span class="line">        carnivore = factory-&gt;CreateCarnivore();  </span><br><span class="line">        herbivore = factory-&gt;CreateHerbivore();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // Methods  </span><br><span class="line">    void RunFoodChain()  </span><br><span class="line">    &#123;   </span><br><span class="line">        carnivore-&gt;Eat(herbivore);   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    // Create and run the Africa animal world  </span><br><span class="line">    ContinentFactory *africa = new AfricaFactory();  </span><br><span class="line">    AnimalWorld *world = new AnimalWorld( africa );  </span><br><span class="line">    world-&gt;RunFoodChain();  </span><br><span class="line"></span><br><span class="line">    // Create and run the America animal world  </span><br><span class="line">    ContinentFactory *america = new AmericaFactory();  </span><br><span class="line">    world = new AnimalWorld( america );  </span><br><span class="line">    world-&gt;RunFoodChain();  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>“开放-封闭”原则：</strong><br>抽象工厂可以很好的应对增加新产品族的问题（即a4/b4/c4），且符合“开放-封闭”原则，但是若是增加新的产品结构的话（即d/d1/d2），就是说a/b/c/d这4中方法必须同时使用了，那就必须修改工厂角色。不符合“开放-封闭”原则。综合来讲，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，而不能为新的产品结构的增加提供这样的方便。</p>
<p><strong>实现要点：</strong></p>
<ul>
<li>在抽象工厂模式中，选用哪种产品族的问题，需要采用工厂方法或简单工厂模式来配合解决。</li>
<li>抽象工厂模式和工厂方法模式一样，都把对象的创建延迟到了他的子类中。</li>
<li>具体的工厂类可以设计成单例类，他只向外界提供自己唯一的实例。</li>
</ul>
<p><strong>与其他工厂模式的联系和异同：</strong></p>
<ul>
<li>抽象工厂模式中的具体工厂负责生产一个产品族的产品。而产品族的增加只需要增加与其对应的具体工厂。</li>
<li>3种工厂模式都是创建型模式，都是创建对象的，但都把产品具体创建的过程给隐藏了。</li>
<li>工厂方法模式是针对一种产品结构，而抽象工厂模式是针对多种产品结构。</li>
</ul>
<p><strong>适用性：</strong><br>在以下情况下应当考虑使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</li>
<li>这个系统有多于一个的产品族，而系统只消费其中某一产品族。</li>
<li>同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>支持多种观感标准的用户界面工具箱（Kit）。</li>
<li>游戏开发中的多风格系列场景，比如道路，房屋，管道等。</li>
</ul>
<h3 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h3><p><strong>解决的问题：</strong><br>我创建的这个对象比较复杂，且该对象里面的成员函数用不同的实现来表示不同的实例，换句话说就是同样的对象构建过程可以有不同的表示。比如我那天去吃过桥米线，他们有不同的套餐，套餐里包含的种类是一样的，都有一碗米线，一份凉菜，一杯饮料。但是不同的套餐里这3样又都不是全部一样的。此时我们就可以用建造者模式。</p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789725745.png" alt=""></p>
<p>1．建造者（Builder）角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者（Concrete Builder）角色。具体建造者类必须实现这个接口所要求的方法：一个是建造方法，另一个是结果返还方法。此时就是米线店的员工，按照收银员的要求的去准备具体的套餐，放入适当的米线，凉菜和饮料。</p>
<p>2．具体建造者（Concrete Builder）角色：担任这个角色的是于应用程序紧密相关的类，它们在应用程序调用下创建产品实例。这个角色主要完成的任务包括：实现Builder角色提供的接口，一步一步完成创建产品实例的过程。在建造过程完成后，提供产品的实例。是具体的做某个套餐的员工。</p>
<p>3．指导者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者对象。是收银员，他知道我想要什么套餐，他会告诉里面的米线店员工去准备什么套餐。</p>
<p>4．产品（Product）角色：产品便是建造中的复杂对象。指导者角色是于客户端打交道的角色。导演者角色将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但却不为客户端所知。就是最后的套餐，所有东西放到一起端过来。</p>
<p><strong>样例实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">// CplusplusBuild.cpp : Defines the entry point for the console application.  </span><br><span class="line">//  </span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">//product  </span><br><span class="line">class Food  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    vector&lt;string&gt; mFoodName;  </span><br><span class="line">    vector&lt;int&gt; mFoodPrice;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    void add(string foodName,int price)  </span><br><span class="line">    &#123;  </span><br><span class="line">        mFoodName.push_back(foodName);        </span><br><span class="line">        mFoodPrice.push_back(price);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    void show()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;Food List&quot; &lt;&lt;endl;  </span><br><span class="line">        cout&lt;&lt;&quot;-------------------&quot;&lt;&lt;endl;  </span><br><span class="line">        for(int i=0;i&lt;mFoodName.size();i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            cout&lt;&lt;mFoodName[i]&lt;&lt;&quot; &quot;&lt;&lt;mFoodPrice[i]&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//builder  </span><br><span class="line">class Builder  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual void BuildRiceNoodles() &#123;&#125;;  </span><br><span class="line">    virtual void BuildCoolDish()&#123;&#125;;  </span><br><span class="line">    virtual void BuildDrink()&#123;&#125;;  </span><br><span class="line">    virtual Food * getFood()&#123;return NULL;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//builderA  </span><br><span class="line">class BuilderA:public Builder  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    Food *food;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    BuilderA()&#123;food = new Food();&#125;  </span><br><span class="line">    void BuildRiceNoodles()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;RiceNoodlesA&quot;,20);  </span><br><span class="line">    &#125;  </span><br><span class="line">    void BuildCoolDish()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;CoolDishA&quot;,20);  </span><br><span class="line">    &#125;  </span><br><span class="line">    void BuildDrink()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;DrinkA&quot;,20);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Food * getFood()  </span><br><span class="line">    &#123;  </span><br><span class="line">        return food;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//builderB  </span><br><span class="line">class BuilderB:public Builder  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    Food *food;  </span><br><span class="line">public:  </span><br><span class="line">    BuilderB()&#123;food = new Food();&#125;  </span><br><span class="line">    void BuildRiceNoodles()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;RiceNoodlesB&quot;,10);  </span><br><span class="line">    &#125;  </span><br><span class="line">    void BuildCoolDish()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;CoolDishB&quot;,10);  </span><br><span class="line">    &#125;  </span><br><span class="line">    void BuildDrink()  </span><br><span class="line">    &#123;  </span><br><span class="line">        food-&gt;add(&quot;DrinkB&quot;,10);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Food * getFood()  </span><br><span class="line">    &#123;  </span><br><span class="line">        return food;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//director  </span><br><span class="line">class FoodManager  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    void Construct(Builder * builder)  </span><br><span class="line">    &#123;  </span><br><span class="line">        builder-&gt;BuildRiceNoodles();  </span><br><span class="line">        builder-&gt;BuildDrink();  </span><br><span class="line">        builder-&gt;BuildCoolDish();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//clent  </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    FoodManager *foodManager= new FoodManager();  </span><br><span class="line"></span><br><span class="line">    Builder * builder = new Builder();  </span><br><span class="line"></span><br><span class="line">    // the following code can use simple factory;  </span><br><span class="line">    char ch;  </span><br><span class="line">    cout&lt;&lt;&quot;input your food Type (A or B):&quot;;  </span><br><span class="line">    cin&gt;&gt;ch;  </span><br><span class="line">    if(ch==&apos;A&apos;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        builder = new BuilderA();  </span><br><span class="line">    &#125;else if(ch==&apos;B&apos;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        builder = new BuilderB();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    foodManager-&gt;Construct(builder);  </span><br><span class="line">    Food * food = builder-&gt;getFood();  </span><br><span class="line">    food-&gt;show();  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>建造者模式的扩展：</strong><br>建造者模式在使用过程中可以演化出多种形式：</p>
<p><strong>省略抽象建造者角色</strong><br>如果系统中只需要一个具体的建造者的话，可以省略掉抽象建造者。这是代码可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//director  </span><br><span class="line">class FoodManager  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    BuilderA * builder;  </span><br><span class="line">public:  </span><br><span class="line">    FoodManager() &#123;builder = new BuilderA();&#125;;  </span><br><span class="line">    void Construct()  </span><br><span class="line">    &#123;  </span><br><span class="line">        builder-&gt;BuildRiceNoodles();  </span><br><span class="line">        builder-&gt;BuildDrink();  </span><br><span class="line">        builder-&gt;BuildCoolDish();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>省略指导者角色</strong><br>在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略掉指导者角色，让Builder自己扮演指导者和建造者双重角色。这是代码可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//builder  </span><br><span class="line">class Builder  </span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    Food * food;  </span><br><span class="line">public:  </span><br><span class="line">     Builder()&#123;food = new Food();&#125;  </span><br><span class="line">     void BuildRiceNoodles() &#123;//..&#125;;  </span><br><span class="line">     void BuildCoolDish()&#123;//..&#125;;  </span><br><span class="line">     void BuildDrink()&#123;//..&#125;;  </span><br><span class="line">     Food * getFood()&#123;return food;&#125;  </span><br><span class="line">     void Construct()  </span><br><span class="line">     &#123;  </span><br><span class="line">         BuildRiceNoodles();  </span><br><span class="line">         BuildCoolDish();  </span><br><span class="line">         BuildDrink();  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时，客户端也需要进行相应的调整，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//client  </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    Builder * builder = new Builder();  </span><br><span class="line">    builder-&gt;Construct();  </span><br><span class="line">    Food *food = builder-&gt;getFood();  </span><br><span class="line">    food-&gt;show();  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C#中的StringBuilder就是这样一个例子。</p>
<p><strong>实现要点：</strong><br>1．建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“每个步骤”是一个稳定的算法，而复杂对象的各个步骤之间则经常变化。</p>
<p>2．上一篇所说的抽象工厂模式解决“系列对象”的需求变化，而建造者模式解决单个对象里“对象部分”的需求变化。</p>
<p>产品不需要抽象类，特别是由于创建对象的算法复杂而导致使用此模式的情况下或者此模式应用于产品的生成过程，其最终结果可能差异很大，不大可能提炼出一个抽象产品类。</p>
<p>3．创建者中的创建子部件的接口方法不是抽象方法而是空方法，不进行任何操作，具体的创建者只需要覆盖需要的方法就可以，但是这也不是绝对的，特别是类似文本转换这种情况下，缺省的方法将输入原封不动的输出是合理的缺省操作。</p>
<p><strong>适用性：</strong><br>以下情况应当使用建造者模式：<br>1、需要生成的产品对象有复杂的内部结构。<br>2、需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。<br>3、 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。</p>
<p><strong>效果</strong><br>1、建造者模式的使用使得产品的内部表象可以独立的变化。使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>2、每一个Builder都相对独立，而与其它的Builder无关。<br>3、可使对构造过程更加精细控制。<br>4、将构建代码和实现代码分开。<br>5、建造者模式的缺点在于难于应付“分步骤构建算法”的需求变动。</p>
<h3 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h3><p><strong>解决的问题：</strong><br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这个其实和C++的拷贝构造函数的作用是一致的，实际上就是动态抽取当前对象运行时的状态。</p>
<p><strong>类图结构：</strong></p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789749635.png" alt=""></p>
<p>客户（Client）角色：客户类提出创建对象的请求。<br>抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。<br>具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象原型角色所要求的接口。</p>
<p><strong>样例实现：</strong><br>例子参照wuzhekai1985的简历的例子，代码拷贝如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// CplusplusPrototype.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//父类  </span><br><span class="line">class Resume  </span><br><span class="line">&#123;  </span><br><span class="line">protected:  </span><br><span class="line">	char *name;  </span><br><span class="line">public:  </span><br><span class="line">	Resume() &#123;&#125;  </span><br><span class="line">	virtual ~Resume() &#123;&#125;  </span><br><span class="line">	virtual Resume* Clone() &#123; return NULL; &#125;  </span><br><span class="line">	virtual void Set(char *n) &#123;&#125;  </span><br><span class="line">	virtual void Show() &#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line">class ResumeA : public Resume  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	ResumeA(const char *str);  //构造函数  </span><br><span class="line">	ResumeA(const ResumeA &amp;r); //拷贝构造函数  </span><br><span class="line">	~ResumeA();                //析构函数  </span><br><span class="line">	ResumeA* Clone();          //克隆，关键所在  </span><br><span class="line">	void Show();               //显示内容  </span><br><span class="line">&#125;;  </span><br><span class="line">ResumeA::ResumeA(const char *str)   </span><br><span class="line">&#123;  </span><br><span class="line">	if(str == NULL) &#123;  </span><br><span class="line">		name = new char[1];   </span><br><span class="line">		name[0] = &apos;\0&apos;;   </span><br><span class="line">	&#125;  </span><br><span class="line">	else &#123;  </span><br><span class="line">		name = new char[strlen(str)+1];  </span><br><span class="line">		strcpy(name, str);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeA::~ResumeA() &#123; delete [] name;&#125;  </span><br><span class="line">ResumeA::ResumeA(const ResumeA &amp;r) &#123;  </span><br><span class="line">	name = new char[strlen(r.name)+1];  </span><br><span class="line">	strcpy(name, r.name);  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeA* ResumeA::Clone() &#123;  </span><br><span class="line">	return new ResumeA(*this);  </span><br><span class="line">&#125;  </span><br><span class="line">void ResumeA::Show() &#123;  </span><br><span class="line">	cout&lt;&lt;&quot;ResumeA name : &quot;&lt;&lt;name&lt;&lt;endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ResumeB : public Resume  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	ResumeB(const char *str);  //构造函数  </span><br><span class="line">	ResumeB(const ResumeB &amp;r); //拷贝构造函数  </span><br><span class="line">	~ResumeB();                //析构函数  </span><br><span class="line">	ResumeB* Clone();          //克隆，关键所在  </span><br><span class="line">	void Show();               //显示内容  </span><br><span class="line">&#125;;  </span><br><span class="line">ResumeB::ResumeB(const char *str)   </span><br><span class="line">&#123;  </span><br><span class="line">	if(str == NULL) &#123;  </span><br><span class="line">		name = new char[1];   </span><br><span class="line">		name[0] = &apos;\0&apos;;   </span><br><span class="line">	&#125;  </span><br><span class="line">	else &#123;  </span><br><span class="line">		name = new char[strlen(str)+1];  </span><br><span class="line">		strcpy(name, str);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeB::~ResumeB() &#123; delete [] name;&#125;  </span><br><span class="line">ResumeB::ResumeB(const ResumeB &amp;r) &#123;  </span><br><span class="line">	name = new char[strlen(r.name)+1];  </span><br><span class="line">	strcpy(name, r.name);  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeB* ResumeB::Clone() &#123;  </span><br><span class="line">	return new ResumeB(*this);  </span><br><span class="line">&#125;  </span><br><span class="line">void ResumeB::Show() &#123;  </span><br><span class="line">	cout&lt;&lt;&quot;ResumeB name : &quot;&lt;&lt;name&lt;&lt;endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	Resume *r1 = new ResumeA(&quot;A&quot;);  </span><br><span class="line">    Resume *r2 = new ResumeB(&quot;B&quot;);  </span><br><span class="line">    Resume *r3 = r1-&gt;Clone();  </span><br><span class="line">    Resume *r4 = r2-&gt;Clone();  </span><br><span class="line">    r1-&gt;Show(); r2-&gt;Show();  </span><br><span class="line">    //删除r1,r2  </span><br><span class="line">    delete r1; delete r2;     </span><br><span class="line">    r1 = r2 = NULL;  </span><br><span class="line">    //深拷贝所以对r3,r4无影响  </span><br><span class="line">    r3-&gt;Show(); r4-&gt;Show();  </span><br><span class="line">    delete r3; delete r4;  </span><br><span class="line">    r3 = r4 = NULL; 	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带Prototype Manager的原型模式：</p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789769404.png" alt=""></p>
<p>客户（Client）角色：客户端类向原型管理器提出创建对象的请求。<br>抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。<br>具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。<br>原型管理器（Prototype Manager）角色：创建具体原型类的对象，并记录每一个被创建的对象。<br>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">// CplusplusPrototype.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//父类  </span><br><span class="line">class Resume  </span><br><span class="line">&#123;  </span><br><span class="line">protected:  </span><br><span class="line">	char *name;  </span><br><span class="line">public:  </span><br><span class="line">	Resume() &#123;&#125;  </span><br><span class="line">	virtual ~Resume() &#123;&#125;  </span><br><span class="line">	virtual Resume* Clone() &#123; return NULL; &#125;  </span><br><span class="line">	virtual void Set(char *n) &#123;&#125;  </span><br><span class="line">	virtual void Show() &#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line">class ResumeA : public Resume  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	ResumeA(const char *str);  //构造函数  </span><br><span class="line">	ResumeA(const ResumeA &amp;r); //拷贝构造函数  </span><br><span class="line">	~ResumeA();                //析构函数  </span><br><span class="line">	ResumeA* Clone();          //克隆，关键所在  </span><br><span class="line">	void Show();               //显示内容  </span><br><span class="line">&#125;;  </span><br><span class="line">ResumeA::ResumeA(const char *str)   </span><br><span class="line">&#123;  </span><br><span class="line">	if(str == NULL) &#123;  </span><br><span class="line">		name = new char[1];   </span><br><span class="line">		name[0] = &apos;\0&apos;;   </span><br><span class="line">	&#125;  </span><br><span class="line">	else &#123;  </span><br><span class="line">		name = new char[strlen(str)+1];  </span><br><span class="line">		strcpy(name, str);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeA::~ResumeA() &#123; delete [] name;&#125;  </span><br><span class="line">ResumeA::ResumeA(const ResumeA &amp;r) &#123;  </span><br><span class="line">	name = new char[strlen(r.name)+1];  </span><br><span class="line">	strcpy(name, r.name);  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeA* ResumeA::Clone() &#123;  </span><br><span class="line">	return new ResumeA(*this);  </span><br><span class="line">&#125;  </span><br><span class="line">void ResumeA::Show() &#123;  </span><br><span class="line">	cout&lt;&lt;&quot;ResumeA name : &quot;&lt;&lt;name&lt;&lt;endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ResumeB : public Resume  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	ResumeB(const char *str);  //构造函数  </span><br><span class="line">	ResumeB(const ResumeB &amp;r); //拷贝构造函数  </span><br><span class="line">	~ResumeB();                //析构函数  </span><br><span class="line">	ResumeB* Clone();          //克隆，关键所在  </span><br><span class="line">	void Show();               //显示内容  </span><br><span class="line">&#125;;  </span><br><span class="line">ResumeB::ResumeB(const char *str)   </span><br><span class="line">&#123;  </span><br><span class="line">	if(str == NULL) &#123;  </span><br><span class="line">		name = new char[1];   </span><br><span class="line">		name[0] = &apos;\0&apos;;   </span><br><span class="line">	&#125;  </span><br><span class="line">	else &#123;  </span><br><span class="line">		name = new char[strlen(str)+1];  </span><br><span class="line">		strcpy(name, str);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeB::~ResumeB() &#123; delete [] name;&#125;  </span><br><span class="line">ResumeB::ResumeB(const ResumeB &amp;r) &#123;  </span><br><span class="line">	name = new char[strlen(r.name)+1];  </span><br><span class="line">	strcpy(name, r.name);  </span><br><span class="line">&#125;  </span><br><span class="line">ResumeB* ResumeB::Clone() &#123;  </span><br><span class="line">	return new ResumeB(*this);  </span><br><span class="line">&#125;  </span><br><span class="line">void ResumeB::Show() &#123;  </span><br><span class="line">	cout&lt;&lt;&quot;ResumeB name : &quot;&lt;&lt;name&lt;&lt;endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ResumeManager</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;Resume *&gt; mResume;</span><br><span class="line">public:</span><br><span class="line">	ResumeManager()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	void add(Resume * resume)</span><br><span class="line">	&#123;</span><br><span class="line">		mResume.push_back(resume);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 Resume * get(int index) const</span><br><span class="line">	&#123;</span><br><span class="line">		assert(index&gt;=0 &amp;&amp; index&lt;mResume.size());</span><br><span class="line">		return mResume[index];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	ResumeManager *manager = new ResumeManager();</span><br><span class="line">	Resume *r1 = new ResumeA(&quot;A&quot;);  </span><br><span class="line">    Resume *r2 = new ResumeB(&quot;B&quot;);  </span><br><span class="line">	manager-&gt;add(r1);</span><br><span class="line">	manager-&gt;add(r2);</span><br><span class="line">    manager-&gt;get(0)-&gt;Show();</span><br><span class="line">	manager-&gt;get(1)-&gt;Show();  </span><br><span class="line">	Resume *r3 = manager-&gt;get(0)-&gt;Clone();  </span><br><span class="line">    Resume *r4 = manager-&gt;get(1)-&gt;Clone();</span><br><span class="line"></span><br><span class="line">    //删除r1,r2  </span><br><span class="line">    delete r1; delete r2;     </span><br><span class="line">    r1 = r2 = NULL;  </span><br><span class="line">    //深拷贝所以对r3,r4无影响  </span><br><span class="line">    r3-&gt;Show(); r4-&gt;Show();  </span><br><span class="line">    delete r3; delete r4;  </span><br><span class="line">    r3 = r4 = NULL;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现要点：</strong></p>
<ol>
<li>使用原型管理器，体现在一个系统中原型数目不固定时，可以动态的创建和销毁。</li>
<li>实现克隆操作，在.NET中可以使用Object类的MemberwiseClone()方法来实现对象的浅表拷贝或通过序列化的方式来实现深拷贝，在C++中就是拷贝构造函数的作用。</li>
<li>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口。</li>
</ol>
<p><strong>效果：</strong></p>
<ol>
<li>它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。</li>
<li>Prototype模式允许客户只通过注册原型实例就可以将一个具体产品类并入到系统中，客户可以在运行时刻建立和删除原型。</li>
<li>减少了子类构造，Prototype模式是克隆一个原型而不是请求工厂方法创建一个，所以它不需要一个与具体产品类平行的Creater类层次。</li>
<li>Portotype模式具有给一个应用软件动态加载新功能的能力。由于Prototype的独立性较高，可以很容易动态加载新功能而不影响老系统。</li>
<li>产品类不需要非得有任何事先确定的等级结构，因为Prototype模式适用于任何的等级结构</li>
<li>Prototype模式的最主要缺点就是每一个类必须配备一个克隆方法。而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。</li>
</ol>
<p><strong>适用性：</strong></p>
<ol>
<li>当一个系统应该独立于他的产品创建、构成和表示时，需要使用原型模式</li>
<li>当要实例化的类是在运行时刻指定时，如通过动态装载</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆他们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ol>
<h3 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8709701" target="_blank" rel="noopener">单例模式（Singleton Pattern）</a></p>
</blockquote>
<p>单例模式，顾名思义，就是只能由一个实例，那么我们就必须保证</p>
<ol>
<li>该类不能被复制。</li>
<li>该类不能被公开的创造。</li>
</ol>
<p>那么对于C++来说，他的构造函数，拷贝构造函数和他的赋值函数都不能被公开调用。<br>但对于该私有的构造函数的构造时机上来说也可以分两种情况来构造：</p>
<ol>
<li>只有当需要该类的时候去构造（即为懒汉模式）</li>
<li>在程序开始之前我就先构造好，你到时候直接用就可（即为饿汉模式）</li>
</ol>
<p>那么我分别来说说这两种模式：</p>
<ul>
<li>懒汉模式，静态局部变量只会被初始化一次即第一次执行的时候，其生命周期与程序的生命周期是相同的。这个同样适用于多线程的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class single1  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    static single1&amp; getInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">        static single1 instance;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int helloSingle() &#123;return 1;&#125;  </span><br><span class="line">private:  </span><br><span class="line"></span><br><span class="line">private:  </span><br><span class="line">    single1()&#123;&#125;;  </span><br><span class="line">    single1(const single1&amp;);  </span><br><span class="line">    single1&amp; operator=(const single1&amp;);  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>饿汉模式，但是在main函数外面必须先调用其实例的构造，这个是静态实例的初始化，C/C++会保证其在进入main函数之前进行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class single2  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    static single2* getInstance()  </span><br><span class="line">    &#123;  </span><br><span class="line">        return mInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int helloSingle() &#123;return 1;&#125;  </span><br><span class="line"></span><br><span class="line">private:  </span><br><span class="line">    static single2* mInstance;  </span><br><span class="line"></span><br><span class="line">private:  </span><br><span class="line">    single2()&#123;&#125;;  </span><br><span class="line">    single2(const single2&amp;);  </span><br><span class="line">    single2&amp; operator=(const single2&amp;);  </span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line">single2* single2::mInstance = new single2;</span><br></pre></td></tr></table></figure>
<p>我们运用静态局部变量和静态实例的特性，使得我们的这两种模式都适用于多线程。</p>
<h3 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8780140" target="_blank" rel="noopener">适配器模式（Adapter Pattern）</a></p>
</blockquote>
<p><strong>解决的问题：</strong><br>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。比如说我的hp笔记本，美国产品，人家美国的电压是110V的，而我们中国的电压是220V，要在中国能使用，必须找个变压器转一下电压才可以。这个变压器就是个适配器。</p>
<p>适配器模式有类适配器和对象适配器两种模式，我们将分别讨论。</p>
<p><strong>类适配器：</strong></p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789814525.png" alt=""></p>
<p>由图中可以看出，Adaptee类没有Request方法，而客户期待这个方法。为了使客户能够使用Adaptee类，提供一个中间环节，即类Adapter类，Adapter类实现了Target接口，并继承自Adaptee，Adapter类的Request方法重新封装了Adaptee的SpecificRequest方法，实现了适配的目的。</p>
<p>因为Adapter与Adaptee是继承的关系，所以这决定了这个适配器模式是类的。</p>
<p>该适配器模式所涉及的角色包括：</p>
<p>目标（Target）角色：这是客户所期待的接口。因为C#不支持多继承，所以Target必须是接口，不可以是类。<br>源（Adaptee）角色：需要适配的类。<br>适配器（Adapter）角色：把源接口转换成目标接口。这一角色必须是类</p>
<p><strong>简单实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// &quot;ITarget&quot;</span><br><span class="line">class Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Methods</span><br><span class="line">	virtual void Request()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// &quot;Adaptee&quot;</span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Methods</span><br><span class="line">	void SpecificRequest()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Called SpecificRequest()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// &quot;Adapter&quot;</span><br><span class="line">class Adapter : public Adaptee, public Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Implements ITarget interface</span><br><span class="line">	void Request()</span><br><span class="line">	&#123;</span><br><span class="line">		// Possibly do some data manipulation</span><br><span class="line">		// and then call SpecificRequest  </span><br><span class="line">		this-&gt;SpecificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	// Create adapter and place a request</span><br><span class="line">	Target *t = new Adapter();</span><br><span class="line">	t-&gt;Request();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对象适配器：</strong></p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789840238.png" alt=""></p>
<p>从图中可以看出：客户端需要调用Request方法，而Adaptee没有该方法，为了使客户端能够使用Adaptee类，需要提供一个包装（Wrapper）类Adapter。这个包装类包装了一个Adaptee的实例，从而将客户端与Adaptee衔接起来。由于Adapter与Adaptee是委派关系，这决定了这个适配器模式是对象的。</p>
<p>该适配器模式所涉及的角色包括：</p>
<p>目标（Target）角色：这是客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。<br>源（Adaptee）角色：需要适配的类。<br>适配器（Adapter）角色：通过在内部包装（Wrap）一个Adaptee对象，把源接口转换成目标接口。</p>
<p><strong>简单实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// &quot;ITarget&quot;</span><br><span class="line">class Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Methods</span><br><span class="line">	virtual void Request()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// &quot;Adaptee&quot;</span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	// Methods</span><br><span class="line">	void SpecificRequest()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Called SpecificRequest()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// &quot;Adapter&quot;</span><br><span class="line">class Adapter : public Target</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	Adaptee *adaptee;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Adapter()</span><br><span class="line">	&#123;</span><br><span class="line">		adaptee = new Adaptee();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Implements ITarget interface</span><br><span class="line">	void Request()</span><br><span class="line">	&#123;</span><br><span class="line">		// Possibly do some data manipulation</span><br><span class="line">		// and then call SpecificRequest  </span><br><span class="line">		adaptee-&gt;SpecificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	// Create adapter and place a request</span><br><span class="line">	Target *t = new Adapter();</span><br><span class="line">	t-&gt;Request();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺省适配器：</strong><br>缺省适配器模式是一种特殊的适配器模式，但这个适配器是由一个抽象类实现的，并且在抽象类中要实现目标接口中所规定的所有方法，但很多方法的实现都是“平庸”的实现，也就是说，这些方法都是空方法。而具体的子类都要继承此抽象类。</p>
<p><strong>简单实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Target &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void f1()&#123;&#125;;</span><br><span class="line">	virtual void f2()&#123;&#125;;</span><br><span class="line">	virtual void f3()&#123;&#125;;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DefaultAdapter : public Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void f1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void f2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void f3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyInteresting :public DefaultAdapter</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">     void f3()&#123;       </span><br><span class="line">		cout&lt;&lt;&quot;呵呵，我就对f3()方法感兴趣，别的不管了！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	// Create adapter and place a request</span><br><span class="line">	Target *t = new MyInteresting();</span><br><span class="line">	t-&gt;f3();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现要点：</strong></p>
<ol>
<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</li>
<li>Adapter模式有对象适配器和类适配器两种形式的实现结构，但是类适配器采用“多继承”的实现方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li>
<li>Adapter模式的实现可以非常的灵活，不必拘泥于GOF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</li>
<li>Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便的适配。</li>
</ol>
<p><strong>使用场景：</strong><br>在以下各种情况下使用适配器模式：</p>
<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。</li>
<li>（对对象适配器而言）在设计里，需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。</li>
</ol>
<h3 id="桥模式（Bridge-Pattern）"><a href="#桥模式（Bridge-Pattern）" class="headerlink" title="桥模式（Bridge Pattern）"></a>桥模式（Bridge Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8710134" target="_blank" rel="noopener">桥模式（Bridge Pattern）</a></p>
</blockquote>
<p>桥模式，其作用就是让抽象与实现相分离，让两者都能够各自变化。</p>
<p>举例来说吧，画图，我可以画矩形，圆，三角形等等，在哪里画呢？我可以在pdf上画，也可以在doc上面画。画什么图和在哪里画都是可以独立变化的，此种情况就比较适合用桥模式。就是说设计中有超过一维的变化我们就可以用桥模式。如果只有一维在变化，那么我们用继承就可以圆满的解决问题。</p>
<p>我的图形定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include&quot;ImpShape.h&quot;</span><br><span class="line"></span><br><span class="line">class IShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	IShape(void);</span><br><span class="line">	virtual ~IShape(void);</span><br><span class="line"></span><br><span class="line">	virtual std::vector&lt;Point&gt; getDrawPoints();</span><br><span class="line"></span><br><span class="line">	void paint();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	ImpShape *implementor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他图形都继承之：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;ishape.h&quot;</span><br><span class="line">class CRectangle :</span><br><span class="line">	public IShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CRectangle(void);</span><br><span class="line">	~CRectangle(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line">#include &quot;ishape.h&quot;</span><br><span class="line">class CCircle :</span><br><span class="line">	public IShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CCircle(void);</span><br><span class="line">	~CCircle(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么在怎么画这个问题上，该怎么实现呢？我先定义一个shape的实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">class ImpShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	ImpShape(void);</span><br><span class="line">	virtual ~ImpShape(void);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	virtual void draw(std::vector&lt;Point&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么让pdf和doc的实现类都继承自ImpShape:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;impshape.h&quot;</span><br><span class="line">class ImpPdf :</span><br><span class="line">	public ImpShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	ImpPdf(void);</span><br><span class="line">	~ImpPdf(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line">#include &quot;impshape.h&quot;</span><br><span class="line">class ImpDoc :</span><br><span class="line">	public ImpShape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	ImpDoc(void);</span><br><span class="line">	~ImpDoc(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那ImpPdf和ImpDoc必须继承且重写ImpShape的draw函数。</p>
<p>我们的抽象和实现都分别实现好了，那两者如何联系，如何使用的？</p>
<ul>
<li>关于联系，细心的你也许已经发现，IShape里面包含一个ImpShape的指针，包含!对。因为ImpShape是实现IShape的，这里用包含，我们可以在IShape的其他函数里方便的调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;StdAfx.h&quot;</span><br><span class="line">#include &quot;IShape.h&quot;</span><br><span class="line"></span><br><span class="line">IShape::IShape(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IShape::~IShape(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void IShape::paint()</span><br><span class="line">&#123;</span><br><span class="line">	std::vector&lt;Point&gt; vpoints = getDrawPoints();</span><br><span class="line">	this-&gt;implementor-&gt;draw(vpoints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于使用，很简单：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IShape *item = new CCircle();</span><br><span class="line">	item-&gt;implementor = new ImpPdf();</span><br><span class="line">	item-&gt;paint();</span><br><span class="line"></span><br><span class="line">	item = new CRectangle();</span><br><span class="line">	item-&gt;implementor = new ImpDoc();</span><br><span class="line">	item-&gt;paint();</span><br></pre></td></tr></table></figure>
<p>这样既满足了画什么图形的变化，也满足了在什么上画的问题，他们之间的类图如下：</p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789868632.png" alt=""></p>
<h3 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8811101" target="_blank" rel="noopener">组合模式（Composite Pattern）</a></p>
</blockquote>
<p><strong>解决的问题：</strong><br>我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。</p>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>注明：树形结构里的叶子节点也有左右孩子，只不过他的孩子都是空。</p>
<p><strong>概述</strong><br>组合模式的实现根据所实现接口的区别分为两种形式，分别称为安全模式和透明模式。组合模式可以不提供父对象的管理方法，但组合模式必须在合适的地方提供子对象的管理方法（诸如：add、remove、getChild等）。</p>
<p><strong>透明方式</strong><br>作为第一种选择，在Component里面声明所有的用来管理子类对象的方法，包括add（）、remove（），以及getChild（）方法。这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端可以同等同的对待所有的对象。这就是透明形式的组合模式。</p>
<p>这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此add（）、remove（）以及getChild（）方法没有意义，是在编译时期不会出错，而只会在运行时期才会出错或者说识别出来。</p>
<p><strong>安全方式</strong><br>第二种选择是在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，因为树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。</p>
<p>这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。</p>
<p>这两个形式各有优缺点，需要根据软件的具体情况做出取舍决定。</p>
<p><strong>类图结构及样例实现：</strong><br>这里给出安全方式的组合模式的类图结构和样例实现，透明方式就是在叶子节点的add()/remove()/GetChild()均有实现，不过是无意义的实现。大部分应用都是基于透明模式的，因为这样代码可以重用。</p>
<p><strong>安全方式的组合模式：</strong></p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789886073.png" alt=""></p>
<p>这种形式涉及到三个角色：</p>
<p>抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。在安全式的合成模式里，构件角色并不是定义出管理子对象的方法，这一定义由树枝构件对象给出。</p>
<p>树叶构件（Leaf）角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。</p>
<p>树枝构件（Composite）角色：代表参加组合的有下级子对象的对象。树枝对象给出所有的管理子对象的方法，如add（）、remove（）、getChild（）等。</p>
<p><strong>样例实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">//Menu.h  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line"></span><br><span class="line">class Menu    </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    virtual ~Menu();  </span><br><span class="line"></span><br><span class="line">    virtual void Add(Menu*);  </span><br><span class="line">    virtual void Remove(Menu*);  </span><br><span class="line">    virtual Menu* GetChild(int);  </span><br><span class="line">    virtual void Display() = 0;  </span><br><span class="line">protected:  </span><br><span class="line">    Menu();  </span><br><span class="line">    Menu(std::string);  </span><br><span class="line">    std::string m_strName;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//Menu.cpp  </span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include &quot;Menu.h&quot;  </span><br><span class="line"></span><br><span class="line">Menu::Menu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Menu::Menu(std::string strName) : m_strName(strName)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Menu::~Menu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void Menu::Add(Menu* pMenu)  </span><br><span class="line">&#123;&#125;  </span><br><span class="line"></span><br><span class="line">void Menu::Remove(Menu* pMenu)  </span><br><span class="line">&#123;&#125;  </span><br><span class="line"></span><br><span class="line">Menu* Menu::GetChild(int index)  </span><br><span class="line">&#123;  </span><br><span class="line">    return NULL;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//SubMenu.h  </span><br><span class="line">#include &quot;Menu.h&quot;  </span><br><span class="line"></span><br><span class="line">class SubMenu : public Menu    </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    SubMenu();  </span><br><span class="line">    SubMenu(std::string);  </span><br><span class="line">    virtual ~SubMenu();  </span><br><span class="line"></span><br><span class="line">    void Display();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//SubMenu.cpp  </span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include &quot;SubMenu.h&quot;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">SubMenu::SubMenu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">SubMenu::SubMenu(string strName) : Menu(strName)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">SubMenu::~SubMenu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void SubMenu::Display()  </span><br><span class="line">&#123;  </span><br><span class="line">    cout &lt;&lt; m_strName &lt;&lt; endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//CompositMenu.h  </span><br><span class="line">#include &quot;Menu.h&quot;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line"></span><br><span class="line">class CompositMenu : public Menu  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    CompositMenu();  </span><br><span class="line">    CompositMenu(std::string);  </span><br><span class="line">    virtual ~CompositMenu();  </span><br><span class="line"></span><br><span class="line">    void Add(Menu*);  </span><br><span class="line">    void Remove(Menu*);  </span><br><span class="line">    Menu* GetChild(int);  </span><br><span class="line">    void Display();  </span><br><span class="line">private:  </span><br><span class="line">    std::vector&lt;Menu*&gt; m_vMenu;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//CompositMenu.cpp  </span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include &quot;CompositMenu.h&quot;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">CompositMenu::CompositMenu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">CompositMenu::CompositMenu(string strName) : Menu(strName)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">CompositMenu::~CompositMenu()  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void CompositMenu::Add(Menu* pMenu)  </span><br><span class="line">&#123;  </span><br><span class="line">    m_vMenu.push_back(pMenu);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void CompositMenu::Remove(Menu* pMenu)  </span><br><span class="line">&#123;  </span><br><span class="line">    m_vMenu.erase(&amp;pMenu);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Menu* CompositMenu::GetChild(int index)  </span><br><span class="line">&#123;  </span><br><span class="line">    return m_vMenu[index];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void CompositMenu::Display()  </span><br><span class="line">&#123;  </span><br><span class="line">    cout &lt;&lt; &quot;+&quot; &lt;&lt; m_strName &lt;&lt; endl;  </span><br><span class="line">    vector&lt;Menu*&gt;::iterator it = m_vMenu.begin();  </span><br><span class="line">    for (; it != m_vMenu.end(); ++it)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; &quot;|-&quot;;  </span><br><span class="line">        (*it)-&gt;Display();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;  </span><br><span class="line">#include &quot;Menu.h&quot;  </span><br><span class="line">#include &quot;SubMenu.h&quot;  </span><br><span class="line">#include &quot;CompositMenu.h&quot;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    Menu* pMenu = new CompositMenu(&quot;国内新闻&quot;);  </span><br><span class="line">    pMenu-&gt;Add(new SubMenu(&quot;时事新闻&quot;));  </span><br><span class="line">    pMenu-&gt;Add(new SubMenu(&quot;社会新闻&quot;));  </span><br><span class="line">    pMenu-&gt;Display();  </span><br><span class="line">    pMenu = new CompositMenu(&quot;国际新闻&quot;);  </span><br><span class="line">    pMenu-&gt;Add(new SubMenu(&quot;国际要闻&quot;));  </span><br><span class="line">    pMenu-&gt;Add(new SubMenu(&quot;环球视野&quot;));  </span><br><span class="line">    pMenu-&gt;Display();  </span><br><span class="line"></span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现要点：</strong></p>
<ol>
<li>组合模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li>
<li>将“客户代码与复杂的对象容器结构”解耦是组合模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复内部实现结构——发生依赖关系，从而更能“应对变化”。</li>
<li>组合模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。</li>
<li>组合模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
<li>客户端尽量不要直接调用树叶类的方法，而是借助其父类（Component）的多态性完成调用，这样可以增加代码的复用性。</li>
</ol>
<p><strong>使用场景：</strong><br>以下情况下适用组合模式：</p>
<ol>
<li>你想表示对象的部分-整体层次结构。</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ol>
<h3 id="装饰者模式（Decorator-Pattern）"><a href="#装饰者模式（Decorator-Pattern）" class="headerlink" title="装饰者模式（Decorator Pattern）"></a>装饰者模式（Decorator Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8830455" target="_blank" rel="noopener">装饰者模式（Decorator Pattern）</a></p>
</blockquote>
<p><strong>解决的问题：</strong><br>我们在装饰新家的时候买了几幅抽象画，买回来之后发现有些加上色彩艳丽的边框更适合我们，而有的加上玻璃罩之后更能符合我们的使用。那我们来怎么解决这个问题呢？他需要动态的给别的对象增加额外的职责，这就是装饰者模式的目的。</p>
<p>我们可以通过继承的方式来给原对象增加新功能，但是装饰者模式采用组合的方式比生成子类更加灵活。</p>
<p><strong>类图及样例实现：</strong></p>
<p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789909879.png" alt=""></p>
<p>在装饰模式中的各个角色有：<br>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。<br>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。<br>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。<br>具体装饰（Concrete Decorator）角色：负责给构件对象”贴上”附加的责任。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//抽象类Tank</span><br><span class="line">class Tank</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void shot()=0;</span><br><span class="line">	virtual void run()=0;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	virtual ~Tank()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;in the destructor of Tank&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//具体类 T50</span><br><span class="line">class T50:public Tank</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void shot()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Tank T50 shot()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void run()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Tank T50 run()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	virtual ~T50()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;In the destructor of T50&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//具体类T75</span><br><span class="line">class T75:public Tank</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void shot()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Tank T75 shot()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void run()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;Tank T75 run()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	virtual ~T75()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;In the destructor of T75&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//抽象类，Decorator</span><br><span class="line">class Decorator:public Tank</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">	Tank* tank;</span><br><span class="line">public:</span><br><span class="line">	Decorator(Tank* tank):tank(tank) &#123;&#125;  //具体的坦克的装饰类</span><br><span class="line">	virtual ~Decorator()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;In the destructor of Decorator&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	void shot()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;shot();</span><br><span class="line">	&#125;</span><br><span class="line">	void run()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class InfraredDecorator: public Decorator</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	string infrared;//这就是所谓的addAtrribute</span><br><span class="line">public:</span><br><span class="line">	InfraredDecorator(Tank* tank):Decorator(tank) &#123;&#125;</span><br><span class="line">	virtual ~InfraredDecorator()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;in the destructor of InfraredDecorator&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	void set_Infrared(const string &amp;infrared)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;infrared=infrared;</span><br><span class="line">	&#125;</span><br><span class="line">	string get_infrared() const</span><br><span class="line">	&#123;</span><br><span class="line">		return infrared;</span><br><span class="line">	&#125;</span><br><span class="line">	void run()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;run();</span><br><span class="line">		set_Infrared(&quot;+Infrared&quot;);</span><br><span class="line">		cout&lt;&lt;get_infrared()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void shot()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;shot();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AmphibianDecorator:public Decorator</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	string amphibian;</span><br><span class="line">public:</span><br><span class="line">	AmphibianDecorator(Tank* tank):Decorator(tank) &#123;&#125;</span><br><span class="line">	~AmphibianDecorator()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;in the destructor of AmphibianDecorator&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	void set_amphibian(const string &amp;hibian)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;amphibian=hibian;</span><br><span class="line">	&#125;</span><br><span class="line">	string get_amphibian() const</span><br><span class="line">	&#123;</span><br><span class="line">		return amphibian;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	void run()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;run();</span><br><span class="line">		set_amphibian(&quot;+amphibian&quot;);</span><br><span class="line">		cout&lt;&lt;get_amphibian()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void shot()</span><br><span class="line">	&#123;</span><br><span class="line">		tank-&gt;shot();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	//给T50增加红外功能</span><br><span class="line">	Tank* tank1(new T50);</span><br><span class="line">	Tank* pid1(new InfraredDecorator(tank1));</span><br><span class="line">	pid1-&gt;shot();</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	pid1-&gt;run();</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;---------------&quot;&lt;&lt;endl;</span><br><span class="line">	//给t75增加红外、两栖功能</span><br><span class="line">	Tank* tank2(new T75);</span><br><span class="line">	tank2-&gt;run();</span><br><span class="line">	Tank* pid2(new InfraredDecorator(tank2));</span><br><span class="line">	Tank* pad2(new AmphibianDecorator(pid2));</span><br><span class="line">	pad2-&gt;shot();</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	pad2-&gt;run();</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;&quot;--------------&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	//动态撤销其他装饰 ?</span><br><span class="line">	tank2-&gt;run();</span><br><span class="line"></span><br><span class="line">	Tank * tank3(tank2);</span><br><span class="line">	tank3-&gt;run();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>装饰者与适配者模式的区别：</strong></p>
<ol>
<li>关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。</li>
<li>关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者）</li>
<li>关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</li>
</ol>
<p><strong>要点：</strong></p>
<ol>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>可以用一个或多个装饰者包装一个对象。</li>
<li>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。</li>
<li>装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。</li>
<li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。</li>
</ol>
<p><strong>适用场景与优缺点：</strong><br>在以下情况下应当使用装饰模式：</p>
<ol>
<li>需要扩展一个类的功能，或给一个类增加附加责任。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。</li>
</ol>
<p><strong>优点：</strong></p>
<ol>
<li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li>
<li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li>
<li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li>
</ol>
<h3 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8841779" target="_blank" rel="noopener">外观模式（Facade Pattern）</a></p>
</blockquote>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>想想我们小时候玩的四驱车，里面的构造很复杂，马达，舵机，电池组等等，而我们控制它却非常简单，只要打开电池开关，他就可以跑。我们其实不用知道它里面是如何工作，只要知道拨动开关它就可以工作就行了，这个开关其实就四驱车给我们的一个友好的组件，使得我们可以很方便的控制它。</p>
<p>外观模式其实定义了一个高层接口，该接口为子系统中的一组接口提供一个一致的界面，使得这一子系统更加容易使用。</p>
<h4 id="类图和样例"><a href="#类图和样例" class="headerlink" title="类图和样例"></a>类图和样例</h4><p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789940900.png" alt=""></p>
<p>在这个对象图中，出现了两个角色：</p>
<p>外观(Facade)角色：客户端可以调用这个角色的方法。此角色知晓相关的(一个或者多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</p>
<p>子系统(subsystem)角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被外观角色调用。子系统并不知道外观的存在，对于子系统而言，外观仅仅是另外一个客户端而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Scanner  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	void Scan() &#123; cout&lt;&lt;&quot;词法分析&quot;&lt;&lt;endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class Parser  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	void Parse() &#123; cout&lt;&lt;&quot;语法分析&quot;&lt;&lt;endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class GenMidCode  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	void GenCode() &#123; cout&lt;&lt;&quot;产生中间代码&quot;&lt;&lt;endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">class GenMachineCode  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	void GenCode() &#123; cout&lt;&lt;&quot;产生机器码&quot;&lt;&lt;endl;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">//高层接口  Fecade</span><br><span class="line">class Compiler  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">	void Run()   </span><br><span class="line">	&#123;  </span><br><span class="line">		Scanner scanner;  </span><br><span class="line">		Parser parser;  </span><br><span class="line">		GenMidCode genMidCode;  </span><br><span class="line">		GenMachineCode genMacCode;  </span><br><span class="line">		scanner.Scan();  </span><br><span class="line">		parser.Parse();  </span><br><span class="line">		genMidCode.GenCode();  </span><br><span class="line">		genMacCode.GenCode();  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">//client</span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">	Compiler compiler;  </span><br><span class="line">	compiler.Run();  </span><br><span class="line">	return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol>
<li>Facade模式对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。</li>
<li>Facade模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。</li>
<li>如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性与通用性之间选择。</li>
<li>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只能有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统有一个外观类，整个系统可以有数个外观类。</li>
<li>外观模式的用意是为子系统提供一个集中化和简化的沟通管道，而不建议向子系统加入新的行为。</li>
<li>外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。</li>
</ol>
<h4 id="适用性和优缺点"><a href="#适用性和优缺点" class="headerlink" title="适用性和优缺点"></a>适用性和优缺点</h4><h5 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h5><ol>
<li>为一个复杂子系统提供一个简单接口。</li>
<li>提高子系统的独立性。</li>
<li>在层次化结构中，可以使用Facade模式定义系统中每一层的入口。</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>松散耦合<br> 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。即要点2.</li>
<li><p>简单易用<br>外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。</p>
</li>
<li><p>更好的划分访问层次<br>通过合理使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好的隐藏了内部的细节。</p>
</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>过多的或者是不太合理的Facade也容易让人迷惑，到底是调用Facade好呢，还是直接调用模块好。</p>
<h3 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8974679" target="_blank" rel="noopener">享元模式（Flyweight Pattern）</a></p>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>想想我们编辑文档用的wps，文档里文字很多都是重复的，我们不可能为每一个出现的汉字都创建独立的空间，这样代价太大，最好的办法就是共享其中相同的部分，使得需要创建的对象降到最小，这个就是享元模式的核心，即运用共享技术有效地支持大量细粒度的对象。</p>
<p>享元对象能做到共享的关键是区分内蕴状态（Internal State）和外蕴状态（External State）。内蕴状态是存储在享元对象内部并且不会随环境改变而改变。因此内蕴状态并可以共享。</p>
<p>外蕴状态是随环境改变而改变的、不可以共享的状态。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态与内蕴状态是相互独立的。</p>
<h4 id="类图与样例"><a href="#类图与样例" class="headerlink" title="类图与样例"></a>类图与样例</h4><p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533789988825.png" alt=""></p>
<h5 id="抽象享元类（Flyweight）"><a href="#抽象享元类（Flyweight）" class="headerlink" title="抽象享元类（Flyweight）"></a>抽象享元类（Flyweight）</h5><p>它是所有具体享元类的超类。为这些类规定出需要实现的公共接口,那些需要外蕴状态(Exte的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。</p>
<h5 id="具体享元类-ConcreteFlyweight"><a href="#具体享元类-ConcreteFlyweight" class="headerlink" title="具体享元类(ConcreteFlyweight)"></a>具体享元类(ConcreteFlyweight)</h5><p>具体享元类实现了抽象享元类所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元类又称为单纯具体享元类，因为复合享元类是由单纯具体享元角色通过复合而成的。</p>
<h5 id="不能共享的具体享元类-UnsharableFlyweight"><a href="#不能共享的具体享元类-UnsharableFlyweight" class="headerlink" title="不能共享的具体享元类(UnsharableFlyweight)"></a>不能共享的具体享元类(UnsharableFlyweight)</h5><p>不能共享的享元类，又叫做复合享元类。一个复合享元对象是由多个单享元对象组成，这些组成的对象是可以共享的，但是复合享元类本身并不能共享。</p>
<h5 id="享元工厂类-FlyweightFactoiy"><a href="#享元工厂类-FlyweightFactoiy" class="headerlink" title="享元工厂类(FlyweightFactoiy)"></a>享元工厂类(FlyweightFactoiy)</h5><p>享元工厂类负责创建和管理享元对象。当一个客户端对象请求一个享元对象的时候，享元工厂需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。</p>
<h5 id="客户类-Client"><a href="#客户类-Client" class="headerlink" title="客户类(Client)"></a>客户类(Client)</h5><p>客户类需要自行存储所有享元对象的外蕴状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Character  </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Character()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	virtual void SetSize(int, int) = 0;</span><br><span class="line">	virtual void Display() = 0;</span><br><span class="line">protected:</span><br><span class="line">	Character()&#123;&#125;;</span><br><span class="line">	char m_chSymbol;</span><br><span class="line">	int m_nWeight;</span><br><span class="line">	int m_nHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CharacterA : public Character</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CharacterA();</span><br><span class="line">	virtual ~CharacterA();</span><br><span class="line"></span><br><span class="line">	void SetSize(int, int);</span><br><span class="line">	void Display();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CharacterA::CharacterA()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_chSymbol = &apos;A&apos;;</span><br><span class="line">	this-&gt;m_nWeight = 100;</span><br><span class="line">	this-&gt;m_nHeight = 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CharacterA::~CharacterA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void CharacterA::SetSize(int nWeight, int nHeight)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_nWeight = nWeight;</span><br><span class="line">	this-&gt;m_nHeight = nHeight;</span><br><span class="line">&#125;</span><br><span class="line">void CharacterA::Display()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;CharacterA：&quot; &lt;&lt; m_chSymbol &lt;&lt; &quot;(&quot; &lt;&lt; m_nWeight &lt;&lt; &quot;,&quot; &lt;&lt; m_nHeight &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CharacterB : public Character</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CharacterB();</span><br><span class="line">	virtual ~CharacterB();</span><br><span class="line"></span><br><span class="line">	void SetSize(int, int);</span><br><span class="line">	void Display();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CharacterB::CharacterB()</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_chSymbol = &apos;B&apos;;</span><br><span class="line">	this-&gt;m_nWeight = 100;</span><br><span class="line">	this-&gt;m_nHeight = 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CharacterB::~CharacterB()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CharacterB::SetSize(int nWeight, int nHeight)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_nWeight = nWeight;</span><br><span class="line">	this-&gt;m_nHeight = nHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CharacterB::Display()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;CharacterB：&quot; &lt;&lt; m_chSymbol &lt;&lt; &quot;(&quot; &lt;&lt; m_nWeight &lt;&lt; &quot;,&quot; &lt;&lt; m_nHeight &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CharacterFactory  </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CharacterFactory();</span><br><span class="line">	virtual ~CharacterFactory();</span><br><span class="line"></span><br><span class="line">	Character* GetCharacter(char);</span><br><span class="line">private:</span><br><span class="line">	std::map&lt;char, Character*&gt; m_mChar;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CharacterFactory::CharacterFactory()</span><br><span class="line">&#123;</span><br><span class="line">	m_mChar.insert(make_pair&lt;char, Character*&gt;(&apos;A&apos;, new CharacterA));</span><br><span class="line">	m_mChar.insert(make_pair&lt;char, Character*&gt;(&apos;B&apos;, new CharacterB));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CharacterFactory::~CharacterFactory()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Character* CharacterFactory::GetCharacter(char chIn)</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;char, Character*&gt;::iterator it = m_mChar.find(chIn);</span><br><span class="line">	if(it != m_mChar.end())</span><br><span class="line">	&#123;</span><br><span class="line">		return (Character*)it-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	CharacterFactory* pFactory = new CharacterFactory;</span><br><span class="line"></span><br><span class="line">	//内蕴状态 存储在享元对象内部并且不会随环境改变而改变</span><br><span class="line">	Character* ch1 = pFactory-&gt;GetCharacter(&apos;A&apos;);</span><br><span class="line">	ch1-&gt;Display();</span><br><span class="line"></span><br><span class="line">	//外蕴状态 客户端保存</span><br><span class="line">	Character* ch2 = pFactory-&gt;GetCharacter(&apos;B&apos;);</span><br><span class="line">	ch2-&gt;SetSize(500, 800);</span><br><span class="line">	ch2-&gt;Display();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h4><ol>
<li>面向对象很好的解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li>
<li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li>
<li>享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。另外它将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li>
</ol>
<h4 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h4><p>当以下所有的条件都满足时，可以考虑使用享元模式：</p>
<ol>
<li>一个系统有大量的对象。</li>
<li>这些对象耗费大量的内存。</li>
<li>这些对象的状态中的大部分都可以外部化。</li>
<li>这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。</li>
<li>软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。</li>
</ol>
<p>满足以上的这些条件的系统可以使用享元对象。最后，使用享元模式需要维护一个记录了系统已有的所有享元的表，而这需要耗费资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：</p>
<ol>
<li>享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li>
</ol>
<h3 id="13-“一句话总结”和索引"><a href="#13-“一句话总结”和索引" class="headerlink" title="13.“一句话总结”和索引"></a>13.“一句话总结”和索引</h3><blockquote>
<p><a href="https://blog.csdn.net/lcl_data/article/details/8989420" target="_blank" rel="noopener">代理模式（Proxy Pattern）</a></p>
</blockquote>
<h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>作为C++工程师，免不了要管理内存，内存管理也是C++中的难点，而智能指针采用引用计数的办法很方便的帮我们管理了内存的使用，极大方便了我们的工作效率。而智能指针的这种用法其实就是代理模式的一种，他帮我们控制了该对象的内存使用。</p>
<p>代理模式就是为其他对象提供一种代理来控制对这个对象的访问。</p>
<h4 id="种类和用途"><a href="#种类和用途" class="headerlink" title="种类和用途"></a>种类和用途</h4><p>Proxy模式根据种类不同，效果也不尽相同：</p>
<ol>
<li>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的对象是局域的而不是远程的，而代理对象承担了大部份的网络通讯工作。由于客户可能没有意识到会启动一个耗费时间的远程调用，因此客户没有必要的思想准备。</li>
<li>虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。</li>
<li>Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。</li>
<li>保护（Protector Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。保护代理的好处是它可以在运行时间对用户的有关权限进行检查，然后在核实后决定将调用传递给被代理的对象。</li>
<li>Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙（Firewall）代理：保护目标，不让恶意用户接近。</li>
<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用（SmartReference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。</li>
</ol>
<p>在所有种类的代理模式中，虚拟（Virtual）代理、远程（Remote）代理、智能引用代理（SmartReference Proxy）和保护（Protector Access）代理是最为常见的代理模式。</p>
<h4 id="类图和实例"><a href="#类图和实例" class="headerlink" title="类图和实例"></a>类图和实例</h4><p><img src="/2018/08/09/我所理解的设计模式（C-实现）/1533790045592.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BingcaiHuang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BingcaiHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("zB9W7fUpG8e9iQF9I018I0bj-gzGzoHsz", "RkIarEbWMsL4NVGQPKkJwzAi");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
