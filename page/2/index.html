<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BingcaiHuang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BingcaiHuang&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BingcaiHuang&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>BingcaiHuang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BingcaiHuang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/开源库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/开源库/" itemprop="url">开源库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T22:50:16+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/20/开源库/" class="leancloud_visitors" data-flag-title="开源库">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于C-或者Qt的开源库"><a href="#基于C-或者Qt的开源库" class="headerlink" title="基于C++或者Qt的开源库"></a>基于C++或者Qt的开源库</h2><h3 id="Asynchronous-programming-in-Qt-C-using-tasks-and-continuations"><a href="#Asynchronous-programming-in-Qt-C-using-tasks-and-continuations" class="headerlink" title="Asynchronous programming in Qt/C++ using tasks and continuations"></a><a href="https://github.com/mhogomchungu/tasks" target="_blank" rel="noopener">Asynchronous programming in Qt/C++ using tasks and continuations</a></h3><p>基于Qt/C++的异步库</p>
<h3 id="Poly2Tri"><a href="#Poly2Tri" class="headerlink" title="Poly2Tri"></a><a href="http://sites-final.uclouvain.be/mema/Poly2Tri/" target="_blank" rel="noopener">Poly2Tri</a></h3><p>基于C++的多边形三角化库</p>
<p><img src="/2018/08/20/开源库/1534776864383.png" alt="a. Six types of Vertex:Start vertex(5,7,14) End vertex(1,3,11) Split vertex(2,10,12) Merge vertex(6,9,13) Regular Up Vertex(4), polygon internal on its left Regular Down Vertex(8), polygon internal on its right"></p>
<p><img src="/2018/08/20/开源库/1534777422535.png" alt="b. Monotone polygons with an additional auxiliary diagonal"></p>
<p><img src="/2018/08/20/开源库/1534777483127.png" alt="c. Final Triangulation"></p>
<h3 id="Game-Math-and-Geometry-Library"><a href="#Game-Math-and-Geometry-Library" class="headerlink" title="Game Math and Geometry Library"></a><a href="http://clb.demon.fi/MathGeoLib/nightly/" target="_blank" rel="noopener">Game Math and Geometry Library</a></h3><p>游戏、数学、几何库</p>
<p><img src="/2018/08/20/开源库/1534777558332.png" alt="几何库"></p>
<h3 id="ternary-search-tree查找树"><a href="#ternary-search-tree查找树" class="headerlink" title="ternary_search_tree查找树"></a><a href="https://github.com/kingsamchen/Eureka/blob/master/TernarySearchTree/src/ternary_search_tree.cpp" target="_blank" rel="noopener">ternary_search_tree查找树</a></h3><p>包含ternary_search_tre的源码文件</p>
<h3 id="binary-search-tree-in-qt"><a href="#binary-search-tree-in-qt" class="headerlink" title="binary-search-tree-in-qt"></a><a href="https://github.com/thiagodnf/binary-search-tree-in-qt" target="_blank" rel="noopener">binary-search-tree-in-qt</a></h3><p>基于Qt的二叉树</p>
<h3 id="x3py"><a href="#x3py" class="headerlink" title="x3py"></a><a href="https://github.com/rhcad/x3py" target="_blank" rel="noopener">x3py</a></h3><p>可与Python等集成的轻量级C++插件框架</p>
<h3 id="Qt-PluginManager"><a href="#Qt-PluginManager" class="headerlink" title="Qt PluginManager"></a><a href="https://github.com/bidachon/PluginManager" target="_blank" rel="noopener">Qt PluginManager</a></h3><p>Plugin manager library using Qt framework to create Qt applications based on custom loadable plugins.</p>
<h3 id="nodeeditor"><a href="#nodeeditor" class="headerlink" title="nodeeditor"></a><a href="https://github.com/paceholder/nodeeditor" target="_blank" rel="noopener">nodeeditor</a></h3><p>Qt节点编辑器</p>
<h3 id="chigraph"><a href="#chigraph" class="headerlink" title="chigraph"></a><a href="https://github.com/chigraph/chigraph" target="_blank" rel="noopener">chigraph</a></h3><p>图形化编程<br><img src="/2018/08/20/开源库/1534777908673.png" alt=""></p>
<h3 id="imageutilities"><a href="#imageutilities" class="headerlink" title="imageutilities"></a><a href="https://github.com/ankurhanda/imageutilities/tree/master/src/iuio" target="_blank" rel="noopener">imageutilities</a></h3><p>工业相机取图片刷新例子代码</p>
<h3 id="mars"><a href="#mars" class="headerlink" title="mars"></a><a href="https://github.com/rock-simulation/mars/tree/master/common/gui/main_gui/src/qtpropertybrowser" target="_blank" rel="noopener">mars</a></h3><p>一个应用软件，里面部分代码用到Qt属性表，可以参考该软件的使用</p>
<h3 id="qt-solutions"><a href="#qt-solutions" class="headerlink" title="qt-solutions"></a><a href="https://github.com/qtproject/qt-solutions" target="_blank" rel="noopener">qt-solutions</a></h3><p>一个Qt的类库包，里面包含属性表，单例程序使用，还有其他库的GitHub库</p>
<h3 id="QtXlsxWriter"><a href="#QtXlsxWriter" class="headerlink" title="QtXlsxWriter"></a><a href="https://github.com/dbzhang800/QtXlsxWriter" target="_blank" rel="noopener">QtXlsxWriter</a></h3><p>Qt读写Excel库</p>
<h3 id="qt-serialport-arduino"><a href="#qt-serialport-arduino" class="headerlink" title="qt-serialport-arduino"></a><a href="https://github.com/peteristhegreat/qt-serialport-arduino" target="_blank" rel="noopener">qt-serialport-arduino</a></h3><p>Qt串口通信</p>
<h3 id="dunnart"><a href="#dunnart" class="headerlink" title="dunnart"></a><a href="https://github.com/mjwybrow/dunnart" target="_blank" rel="noopener">dunnart</a></h3><p>Qt写的一个节点编辑器</p>
<p><img src="/2018/08/20/开源库/1534778271535.png" alt=""></p>
<p><img src="/2018/08/20/开源库/1534778277231.png" alt=""></p>
<h3 id="CS-Offer"><a href="#CS-Offer" class="headerlink" title="CS_Offer"></a><a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Class.md" target="_blank" rel="noopener">CS_Offer</a></h3><p>有时间值得一看的C++教程</p>
<h3 id="madplotlib"><a href="#madplotlib" class="headerlink" title="madplotlib"></a><a href="https://github.com/madplotlib/madplotlib" target="_blank" rel="noopener">madplotlib</a></h3><p>A C++ wrapper of Qt Charts that looks, tastes and smells like matplotlib but isn’t.<br><img src="/2018/08/20/开源库/1534778445585.png" alt=""></p>
<h3 id="cppfbp"><a href="#cppfbp" class="headerlink" title="cppfbp"></a><a href="https://github.com/jpaulm/cppfbp" target="_blank" rel="noopener">cppfbp</a></h3><p>C++流式编程库，结合lua</p>
<h3 id="QFlow"><a href="#QFlow" class="headerlink" title="QFlow"></a><a href="https://github.com/chezgi/QFlow" target="_blank" rel="noopener">QFlow</a></h3><p>C++流式编程库<br><img src="/2018/08/20/开源库/1534778591844.png" alt=""></p>
<h3 id="libgitlmvc"><a href="#libgitlmvc" class="headerlink" title="libgitlmvc"></a><a href="https://github.com/lheric/libgitlmvc" target="_blank" rel="noopener">libgitlmvc</a></h3><p>C++ MVC 框架，Qt5</p>
<h3 id="QBox2D"><a href="#QBox2D" class="headerlink" title="QBox2D"></a><a href="https://github.com/Code-ReaQtor/QBox2D" target="_blank" rel="noopener">QBox2D</a></h3><p>An attempt to use Erin Catto’s Box2D (<a href="http://www.box2d.org" target="_blank" rel="noopener">http://www.box2d.org</a>) API with Qt/C++ Graphics VIew Framework</p>
<h3 id="QtnProperty"><a href="#QtnProperty" class="headerlink" title="QtnProperty"></a><a href="https://github.com/lexxmark/QtnProperty" target="_blank" rel="noopener">QtnProperty</a></h3><p>Qt属性表</p>
<h3 id="Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB"><a href="#Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB" class="headerlink" title="Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB"></a><a href="https://github.com/lygstate/lygstate.github.com/blob/master/_posts/2014-03-10-Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB.md" target="_blank" rel="noopener">Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB</a></h3><p> Qt多线程使用相机处理</p>
<h3 id="sa"><a href="#sa" class="headerlink" title="sa"></a><a href="https://github.com/czyt1988/sa" target="_blank" rel="noopener">sa</a></h3><p>这是一个数据预处理软件，主要负责数据挖掘的数据清洗工作，如对一些科研实验数据的清洗和预处理</p>
<h3 id="LeksysINI"><a href="#LeksysINI" class="headerlink" title="LeksysINI"></a><a href="https://github.com/Lek-sys/LeksysINI" target="_blank" rel="noopener">LeksysINI</a></h3><p>开源读写INI配置文件库</p>
<h3 id="tasks"><a href="#tasks" class="headerlink" title="tasks"></a><a href="https://github.com/mhogomchungu/tasks" target="_blank" rel="noopener">tasks</a></h3><p>Qt异步多任务执行类库</p>
<h3 id="Qt-SyncWoker"><a href="#Qt-SyncWoker" class="headerlink" title="Qt-SyncWoker"></a><a href="https://github.com/JimmyJay2015/Qt-SyncWoker" target="_blank" rel="noopener">Qt-SyncWoker</a></h3><p>Qt同步、异步任务模型</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/Qt中文乱码问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/Qt中文乱码问题/" itemprop="url">Qt中文乱码问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:47:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index">
                    <span itemprop="name">Qt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/Qt中文乱码问题/" class="leancloud_visitors" data-flag-title="Qt中文乱码问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Qt中文乱码问题"><a href="#Qt中文乱码问题" class="headerlink" title="Qt中文乱码问题"></a>Qt中文乱码问题</h2><h3 id="VC2010下Qt5的中文乱码问题"><a href="#VC2010下Qt5的中文乱码问题" class="headerlink" title="VC2010下Qt5的中文乱码问题"></a>VC2010下Qt5的中文乱码问题</h3><blockquote>
<p>参考文章：<br><a href="https://my.oschina.net/chai2010/blog/119833" target="_blank" rel="noopener">VC2010下Qt5的中文乱码问题</a></p>
</blockquote>
<p>要搞清楚这个问题，先要弄明白编码。但是编码问题实在太复杂，这里肯定讲不开。</p>
<p>我先找一个例子，比如：”中文” 的 Unicode 码点/UTF8编码/GBK 分别是多少。</p>
<p>先去这个网站，输入 “中文” 查询对应的 Unicode 码点/UTF8编码： <a href="http://www.mytju.com/classcode/tools/encode_utf8.asp" target="_blank" rel="noopener">http://www.mytju.com/classcode/tools/encode_utf8.asp</a></p>
<p>Unicode的码点分别是(十进制)：中(20013)，文(25991)。 对应的UTF8编码分别(16进制): 中(E4B8AD)，文(E69687)。</p>
<p>然后再去下面这个网站，输入 “中文” 查询对应的 GBK 编码： <a href="http://www.mytju.com/classcode/tools/encode_gb2312.asp" target="_blank" rel="noopener">http://www.mytju.com/classcode/tools/encode_gb2312.asp</a></p>
<p>GBK编码16进制(GBK内码)分别是：中(D6D0)，文(CEC4)。</p>
<p>现在已经知道了”中文”的UTF8和GBK编码的具体值。 我们再看看VC2010是怎么处理的。</p>
<h4 id="先看无-BOM-的-UTF8-编码的代码-utf8-no-bom-cpp"><a href="#先看无-BOM-的-UTF8-编码的代码-utf8-no-bom-cpp" class="headerlink" title="先看无 BOM 的 UTF8 编码的代码 (utf8_no_bom.cpp)"></a>先看无 BOM 的 UTF8 编码的代码 (utf8_no_bom.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// utf8 no bom</span><br><span class="line">// 文件中包含不能在当前代码页（936）中表示的字符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xe4 0xb8 0xad 0xe6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是：0xe4 0xb8 0xad 0xe6。 感觉好像是对的。</p>
<p>但是，先别急：VC编译时输出了一条警告信息： utf8_no_bom.cpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。 请将该文件保存为 Unicode 格式以防止数据丢失。</p>
<p>潜台词就是，你这个代码有GBK不能表示的字符，请用Unicode方式保存。 VC根本就没把 代码(utf8_no_bom.cpp) 当作UTF8，VC只是把它作为GBK处理罢了。</p>
<p>那为什么又输出了正确的结果呢？</p>
<p>因为 VC 把 (utf8_no_bom.cpp) 当作 GBK，而编译时也要转换为本地编码(也是GBK)。 因此，UTF8编码的 “中文”，被VC当作编码为 “0xe4 0xb8 0xad 0xe6” 的其他中文处理了。 VC已经不知道 “0xe4 0xb8 0xad 0xe6” 是对应 “中文” 字面值了。</p>
<p>但是在GBK(实际是无BOM的UTF8)转GBK的过程中，发现了一些UTF8编码的字符并不是 GBK能表达的合理方式，因此就出现了那个C4819编译警告。</p>
<h4 id="再看带BOM的UTF8是怎么处理的-utf8-with-bom-cpp"><a href="#再看带BOM的UTF8是怎么处理的-utf8-with-bom-cpp" class="headerlink" title="再看带BOM的UTF8是怎么处理的 (utf8_with_bom.cpp)"></a>再看带BOM的UTF8是怎么处理的 (utf8_with_bom.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// utf8 with bom</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xd6 0xd0 0xce 0xc4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译没有警告，但是输出有问题：0xd6 0xd0 0xce 0xc4。</p>
<p>源文件明明是 UTF8 编码的格式”0xe4 0xb8 0xad 0xe6”， 怎么变成了 “0xd6 0xd0 0xce 0xc4” (这个是GBK编码)？</p>
<p>这就是VC私下干的好事：它自作聪明的将UTF8源代码转换为GBK处理了！</p>
<p>VC为何要做这样蠢事？</p>
<p>原因是为了兼容老的VC版本。 因为以前的VC不能处理UTF8，都是用本地编码处理的。</p>
<h4 id="在看看真的GBK是怎么处理的-gbk-cpp"><a href="#在看看真的GBK是怎么处理的-gbk-cpp" class="headerlink" title="在看看真的GBK是怎么处理的 (gbk.cpp)"></a>在看看真的GBK是怎么处理的 (gbk.cpp)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// gbk</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xd6 0xd0 0xce 0xc4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有编译错误，输出也和源代码一致：”0xd6 0xd0 0xce 0xc4”。</p>
<p>因为源文件就是GBK，cl在编译时GBK转化为GBK，没有改变字符串。</p>
<p>只是，现在很多人不想用GBK了（因为只能在中国地区用，不能表示全球字符）。</p>
<hr>
<p>到这里，可以初步小结一下：</p>
<ol>
<li>VC编辑器和VC编译器是2个概念，VC编辑器支持UTF8并不能表示VC编译器也支持UTF8</li>
<li>VC编辑器从2008?开始支持带BOM的UTF8(不带BOM的暂时没戏，因为会本地编码冲突)</li>
<li>VC编译器从2010开始重要可以支持UTF8了(虽然支持方式很不优雅)</li>
</ol>
<hr>
<h4 id="看看VC2010是怎么处理带BOM的UTF8的-utf8-with-bom-2010-cpp"><a href="#看看VC2010是怎么处理带BOM的UTF8的-utf8-with-bom-2010-cpp" class="headerlink" title="看看VC2010是怎么处理带BOM的UTF8的 (utf8_with_bom_2010.cpp)"></a>看看VC2010是怎么处理带BOM的UTF8的 (utf8_with_bom_2010.cpp)</h4><p>VC2010重要增加了UTF8的编译支持(#pragma execution_character_set(“utf-8”)), 具体查看:</p>
<p><a href="http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/2f328917-4e99-40be-adfa-35cc17c9cdec" target="_blank" rel="noopener">http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/2f328917-4e99-40be-adfa-35cc17c9cdec</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// utf8 with bom (VC2010), 这句是重点！</span><br><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const char* str = &quot;中文&quot;;</span><br><span class="line">	for(int i = 0; i &lt; sizeof(str); ++i) &#123;</span><br><span class="line">		printf(&quot;0x%x &quot;, str[i]&amp;0xFF);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">	// Output:</span><br><span class="line">	// 0xe4 0xb8 0xad 0xe6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有编译错误，输出也和源代码一致：”0xe4 0xb8 0xad 0xe6”。</p>
<p>UTF8编码，UTF8输出。完美!</p>
<hr>
<h4 id="回到-Qt5-的中文输出问题。"><a href="#回到-Qt5-的中文输出问题。" class="headerlink" title="回到 Qt5 的中文输出问题。"></a>回到 Qt5 的中文输出问题。</h4><p>Qt默认支持 VS2010/MinGW/Gcc 等编译器，而它们现在都已经真正支持UTF8了。</p>
<p>当然，VS2010 对UTF8的支持会入侵代码(#pragma execution_character_set(“utf-8”))。</p>
<p>看看Qt官方论坛别人是怎么说的： <a href="http://qt-project.org/forums/viewthread/17617" target="_blank" rel="noopener">http://qt-project.org/forums/viewthread/17617</a></p>
<blockquote>
<p>Nothing special need to do, it will works by default. If the exec-charset of your your compiler is UTF-8.</p>
</blockquote>
<p>简单的说，从Qt5开始，源代码就是默认UTF8编码的。</p>
<p>当然，VC2010编辑器对带BOM的UTF8也是认识，只可惜VC2010编译器根本承认它是UTF8！</p>
<p>在继续看官方论坛的回复：</p>
<blockquote>
<p>You can write a simple example like this</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">  #if _MSC_VER &gt;= 1600</span><br><span class="line">  #pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">  int main(int argc, char *argv[])</span><br><span class="line">  &#123;</span><br><span class="line">      QApplication a(argc, argv);</span><br><span class="line">      QLabel label(&quot;ąśćółęńżź&quot;);</span><br><span class="line">      label.show();</span><br><span class="line"></span><br><span class="line">      return a.exec();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If other people can reproduce your problem, you can file a bug.</p>
</blockquote>
<p>教完整的解决方案(增加了Qt4/Qt5和非VC环境的判断):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Coding: UTF-8(BOM)</span><br><span class="line">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)</span><br><span class="line"># pragma execution_character_set(&quot;utf-8&quot;)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	QApplication app(argc, argv);</span><br><span class="line"></span><br><span class="line">#if QT_VERSION &lt; QT_VERSION_CHECK(5,0,0)</span><br><span class="line">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1600)</span><br><span class="line">	QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;GB18030-0&quot;));</span><br><span class="line">#else</span><br><span class="line">	QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;UTF-8&quot;));</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	QLabel *label = new QLabel(QObject::tr(&quot;你好！&quot;));</span><br><span class="line">	label-&gt;show();</span><br><span class="line"></span><br><span class="line">	return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有以下几种类型(源代码必须是带BOM的UTF8):</p>
<ul>
<li>Qt5+/VC2010+: 包含了 # pragma execution_character_set(“utf-8”) 已经支持中文</li>
<li>Qt5/VC2008-: 这个暂时误解(我还没找到方法)</li>
<li>Qt4+/VC2008-: 采用以前老的方式, 指定代码为 “GB18030-0” 编码</li>
<li>Qt4/Qt5/Linux: 只要是默认的UTF8环境, 应该都没问题</li>
</ul>
<p>其实这个问题不是Qt特有的, 追根溯源还是C/C++和编译器的问题.</p>
<p>即使是支持UTF16的Java也同样难逃此问题.</p>
<h3 id="Qt5中解决中文乱码的方法"><a href="#Qt5中解决中文乱码的方法" class="headerlink" title="Qt5中解决中文乱码的方法"></a>Qt5中解决中文乱码的方法</h3><blockquote>
<p>文章：<a href="https://blog.csdn.net/liyuanbhu/article/details/72596952" target="_blank" rel="noopener">Qt5中解决中文乱码的方法</a></p>
</blockquote>
<p>在 Qt 4 的时代，解决中文乱码挺麻烦。要考虑用的是什么编译器，具体的可以参考下面这篇文章：<br><a href="http://blog.csdn.net/brave_heart_lxl/article/details/7186631" target="_blank" rel="noopener">http://blog.csdn.net/brave_heart_lxl/article/details/7186631</a></p>
<p>到了 Qt 5 的年代，这个问题变得简单了些。因为根据 Qt 的文档：<br><a href="http://doc.qt.io/qt-5.6/qstring.html#QString-7" target="_blank" rel="noopener">http://doc.qt.io/qt-5.6/qstring.html#QString-7</a></p>
<p>中规定 QString 的 const char* 构造函数是调用 fromUtf8() 构造的。所以要求字符串字面量是 UTF-8 编码的字节。</p>
<p>这里先要解释一下下面两个概念：</p>
<ul>
<li>源码字符集(the source character set)：源码文件是使用何种编码保存的</li>
<li>执行字符集(the execution character set)：可执行程序内保存的是何种编码(程序执行时内存中字符串编码)</li>
</ul>
<p>源码字符集很容易理解，就是我们源代码的编码。为了我们的代码能够跨平台，源文件要保存为带 BOM 的 utf-8。</p>
<p>执行字符集就麻烦多了。比如我们下面的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>即使这个文件存为 utf-8 格式了，编译成 exe 文件时，编译器也可能对这个字符串常量进行转码，转为别的编码格式。</p>
<p>在 gcc 中，控制这个转码操作的命令行参数是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fexec-charset=charset</span><br></pre></td></tr></table></figure></p>
<p>如果不指定的话默认是 utf-8。所以我们用 gcc 时很少关注这个问题。</p>
<p>Viual Stdio 中就麻烦多了。这里先说 Visual stdio 2015，这个是我现在用的编译环境。VS2015 中如果源代码是 utf-8的，执行字符集默认是本地 Locale 字符集，对于简体中文的 windows 系统来说，这个 本地Locale字符集是 gb18030。所以直接显示汉字会全是乱码。解决这个乱码有三个办法，第一个办法是编译时加入命令行参数，在 Qt 的 pro 文件中可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msvc:QMAKE_CXXFLAGS += -execution-charset:utf-8</span><br></pre></td></tr></table></figure></p>
<p>第二个办法是在源文件中加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma execution_character_set(&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure></p>
<p>更好的办法是源代码写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString  str(u8&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>当然，这里要求编译器支持 C++11，因此上面的代码在 VS2005、VS2008 上是无法编译通过的。</p>
<p>另外，如果源代码保存为不带 BOM 的 utf-8。那需要告诉 VS2015 我们的编码格式是 utf-8，可以在 pro 文件中加入如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msvc:QMAKE_CXXFLAGS += -source-charset:utf-8</span><br></pre></td></tr></table></figure></p>
<p>另外再说说 VS2005、VS2008 下该如何设置。首先这两个编译器都不支持 C++11，也不支持执行字符集的设置，执行字符集就是默认的本地 Locale 字符集。所以我们的代码只能写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = QString::fromLocal8Bit(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/Qt-Plugin框架结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/Qt-Plugin框架结构/" itemprop="url">Qt Plugin框架结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T17:08:10+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index">
                    <span itemprop="name">Qt</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/Qt-Plugin框架结构/" class="leancloud_visitors" data-flag-title="Qt Plugin框架结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Qt-Plugin框架结构"><a href="#Qt-Plugin框架结构" class="headerlink" title="Qt Plugin框架结构"></a>Qt Plugin框架结构</h2><blockquote>
<p>参考文章：<br><a href="http://yleesun.blog.163.com/blog/static/2941340220093246562218/" target="_blank" rel="noopener">基于QT Plugin框架结构</a></p>
</blockquote>
<h3 id="qt-plugin-介绍"><a href="#qt-plugin-介绍" class="headerlink" title="qt plugin 介绍"></a>qt plugin 介绍</h3><pre><code>Qt Plugin和其他类型的插件一样，是一种计算机应用程序，它和主应用程序(host application)互相交互，以提供特定的功能。应用程序支持Plugin有许多原因，一些主要原因包括：使得第三方开发者有能力扩展应用程序，以提供无法先期预料的特色；减小应用程序的大小；由于软件版权之间的不兼容性将源代码和应用程序分享。Qt Plugin 分动态插件和静态插件两种。
</code></pre><h3 id="qt-plugin-创建和使用方法"><a href="#qt-plugin-创建和使用方法" class="headerlink" title="qt plugin 创建和使用方法"></a>qt plugin 创建和使用方法</h3><p>Qt有两种与插件有关的API。一种用来扩展Qt本身的功能，如自定义数据库驱动，图像格式，文本编解码，自定义分格，等等，称为Higher-Level API。另一种用于应用程序的功能扩展，称为Lower-Level API。前一种是建立在后一种的基础之上的。这里讨论的是后一种，即用来扩展应用程序的Lower-level API。</p>
<p>让应用程序支持插件扩展的步骤：</p>
<ol>
<li><p>定义一个接口集(只有纯虚函数的类)，用来与插件交流。</p>
</li>
<li><p>用宏Q_DECLARE_INTERFACE()将该接口告诉Qt元对象系统。</p>
<p>Q_DECLARE_INTERFACE(BrushInterface,”com.trolltech.PlugAndPaint.BrushInterface/1.0”)</p>
</li>
<li><p>应用程序中用QPluginLoader来装载插件。</p>
</li>
<li><p>用宏qobject_cast()来确定一个插件是否实现了接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject *obj = new QTimer;</span><br><span class="line">QTimer *timer = qobject_cast&lt;QTimer *&gt;(obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>写一个插件的步骤：</p>
<ol>
<li><p>声明插件类，该类从QObject和该插件希望实现的接口继承而来。</p>
</li>
<li><p>用宏Q_INTERFACES()将该接口告诉Qt元对象系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BasicToolsPlugin : public QObject,</span><br><span class="line">                         public BrushInterface,</span><br><span class="line">                         public ShapeInterface,</span><br><span class="line">                         public FilterInterface</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用宏Q_EXPORT_PLUGIN2()导出插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q_EXPORT_PLUGIN2 ( PluginName, ClassName )</span><br></pre></td></tr></table></figure>
</li>
<li><p>用适当的.pro文件构建插件。</p>
</li>
</ol>
<p>下面的代码声明了一个接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FilterInterface</span><br><span class="line">&#123;</span><br><span class="line"> public:</span><br><span class="line">        virtual ~FilterInterface() &#123;&#125;</span><br><span class="line">        virtual QStringList filters() const = 0;</span><br><span class="line">        virtual QImage filterImage(const QString &amp;filter, const QImage &amp;image, QWidget* parent)=0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Q_DECLARE_INTERFACE(FilterInterface, &quot;com.trolltech.PlugAndPaint.FilterInterface/1.0&quot;)</span><br></pre></td></tr></table></figure>
<p>这里是实现该接口的插件类的定义：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QObject&gt;</span><br><span class="line">#include &lt;QStringList&gt;</span><br><span class="line">#include &lt;QImage&gt;</span><br><span class="line">#include &lt;plugandpaint/interfaces.h&gt;</span><br><span class="line"></span><br><span class="line">class ExtraFiltersPlugin : public QObject, public FilterInterface</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">Q_INTERFACES(FilterInterface)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    QStringList filters() const;</span><br><span class="line">    QImage filterImage(const QString &amp;filter, const QImage &amp;image,</span><br><span class="line">    QWidget *parent);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据插件的类型不同，pro文件中配置上有不同。下面是pro文件分析：</p>
<p>TEMPLATE      = lib                                  // 声明为lib，动态和静态插件一样。</p>
<p>CONFIG       += plugin static                // 声明为plugin，带static表面为静态，否则为动态。</p>
<p>INCLUDEPATH  += ../..</p>
<p>HEADERS       = basictoolsplugin.h</p>
<p>SOURCES       = basictoolsplugin.cpp</p>
<p>TARGET        = $$qtLibraryTarget(pnp_basictools)           // 指明插件的名称</p>
<p>DESTDIR       = ../../plugandpaint/plugins</p>
<p>加载插件的主应用程序默认在当前目录下的plugins文件夹中寻找可用插件，如果是动态插件，则直接放在plugins文件夹中便可，如果是静态，则需要在主应用程序的main函数的开始的地方用宏：Q_IMPORT_PLUGIN(pluginname(和pro文件中声明的一致))声明需要加载的插件并在工程配置中指明插件的lib位置。</p>
<h3 id="基于qt-plugin-技术的框架结构设想"><a href="#基于qt-plugin-技术的框架结构设想" class="headerlink" title="基于qt plugin 技术的框架结构设想"></a>基于qt plugin 技术的框架结构设想</h3><ol>
<li><p>愿景<br>由于我们目前系统功能多，模块多，缺乏系统的整体性。我们想借助Qt Plugin技术，把各个独立的功能模块实现为一个个插件，统一在主体框架中，并能根据不同地方的用户的不同需求，在主框架中加载不同的功能模块，以实现整个系统的功能集中，体现出系统的整体性。</p>
</li>
<li><p>plugin 接口<br>通过技术验证得出，目前我们采用动态插件，各个功能的插件实现定义的统一接口，具体功能放在插件界面中实现，此部分就像开发独立的应用程序，只是需要注意的是：</p>
<ul>
<li>功能部分的主界面需要继承至插件界面基类：PluginWidget，插件接口中用具体的实现类指针给插件界面基类指针赋值，在加载插件的主框架中通过插件接口中定义的基类指针统一调用，利用C++动态技术动态识别具体指向的实现类。</li>
<li>插件界面类必须实现基类的虚函数：CreateActions()用于创建Action</li>
<li>创建Action需要使用基类的方法newAction创建，在此函数中加入了保存创建的Action功能。</li>
</ul>
</li>
</ol>
<p>插件接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class QPluginInterface</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 析构函数</span><br><span class="line">    virtual ~QPluginInterface() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 插件名称</span><br><span class="line">    virtual QString PluginName() = 0;</span><br><span class="line"></span><br><span class="line">    // 插件显示在主框架中的图标文件路径</span><br><span class="line">    virtual QString PluginIconurl() = 0;</span><br><span class="line"></span><br><span class="line">    //　插件提供的对外操作接口集</span><br><span class="line">    virtual QList&lt;QAction*&gt;* Actions() = 0;</span><br><span class="line"></span><br><span class="line">    // 创建插件提供的操作方法</span><br><span class="line">    virtual void CreateActions()=0;</span><br><span class="line"></span><br><span class="line">    // 插件的主界面</span><br><span class="line">    virtual QWidget* Widget() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // 插件的主界面基类</span><br><span class="line">    PluginWidget *pluginWidget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插件界面基类定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class PluginWidget :public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    PluginWidget(QWidget*parent=0);</span><br><span class="line">    ~PluginWidget();</span><br><span class="line">    QList&lt;QAction*&gt;* Actions();</span><br><span class="line">    virtual void CreateActions()&#123;&#125;</span><br><span class="line">    QAction *newAction(const QIcon &amp;icon,const QString &amp;text,QObject*parent);</span><br><span class="line">    QAction *newAction(const QString &amp;text,QObject*parent);</span><br><span class="line">    void AppendAction(QAction*act);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // action链表</span><br><span class="line">    QList&lt;QAction*&gt; *m_actlist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下图是一个实现案例中各类之间的关系图：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151586951.png" alt=""></p>
<ol start="3">
<li>插件调用</li>
</ol>
<p>插件在主框架中动态加载，目前考虑主框架基本结构是继承至QMainWindow，工具栏上显示当前加载的插件的功能键，并留有返回键可以回退到上一级。主工作区是一个QStackWidget,保存插件的界面，并把插件序号和插件对应的界面建立映射，保存在QMap&lt;int,QWidget&gt;中。通过序号到QStackWidget中切换界面。</p>
<p>下图是把DBManager做成插件加载到主框架的运行界面：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151601388.png" alt=""></p>
<p>下图是把一个简单的绘图程序做成了插件，加载到主框架的运行界面：</p>
<p><img src="/2018/08/13/Qt-Plugin框架结构/1534151609060.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前只是通过实现两个动态插件在主框架中运行，基本算是功能性的验证，离具体实施还有很多工作需要进一步的研究，比如主框架的风格，插件的管理等等。由于本人的能力有限，可能有很多认识不够的地方，请指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/模式PK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/模式PK/" itemprop="url">模式PK</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T08:54:42+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/模式PK/" class="leancloud_visitors" data-flag-title="模式PK">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模式PK"><a href="#模式PK" class="headerlink" title="模式PK"></a>模式PK</h2><p>一张记住图例的图片</p>
<p><img src="/2018/08/13/模式PK/1534121798715.png" alt=""></p>
<h3 id="抽象工厂模式VS建造者模式"><a href="#抽象工厂模式VS建造者模式" class="headerlink" title="抽象工厂模式VS建造者模式"></a>抽象工厂模式VS建造者模式</h3><blockquote>
<p><a href="https://www.cnblogs.com/ChinaHook/p/7471736.html" target="_blank" rel="noopener">抽象工厂模式VS建造者模式</a></p>
</blockquote>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品，两者的区别还是比较明显的。</p>
<p>现代化的汽车工厂能够批量生产汽车（不考虑手工打造的豪华车）。不同的工厂生产不同的汽车，宝马工厂生产宝马牌子的车，奔驰工厂生产奔驰牌子的车。车不仅具有不同品牌，还有不同的用途分类，如商务车Van，运动型车SUV等，我们按照两种设计模式分别实现车辆的生产过程。</p>
<h4 id="抽象工厂模式生产车辆"><a href="#抽象工厂模式生产车辆" class="headerlink" title="抽象工厂模式生产车辆"></a>抽象工厂模式生产车辆</h4><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p>按照抽象工厂模式，首先需要定义一个抽象的产品接口即汽车接口，然后宝马和奔驰分别实现该接口，由于它们只具有了一个品牌属性，还没有定义一个具体的型号，属于对象的抽象层次，每个具体车型由其子类实现，如R系列的奔驰车是商务车，X系列的宝马车属于SUV，我们来看类图。</p>
<p><img src="/2018/08/13/模式PK/1534121926220.png" alt=""></p>
<p>在类图中，产品类很简单，我们从两个维度看产品：品牌和车型，每个品牌下都有两个车型，如宝马SUV，宝马商务车等，同时我们又建造了两个工厂，一个专门生产宝马车的宝马工厂BMWFactory，一个是生产奔驰车的奔驰车生产工厂BenzFactory。当然，汽车工厂也有两个不同的维度，可以建立这样两个工厂：一个专门生产SUV车辆的生产工厂，生产宝马SUV和奔驰SUV，另外一个工厂专门生成商务车，分别是宝马商务车和奔驰商务车，这样设计在技术上是完全可行的，但是在业务上是不可行的，为什么？这是因为你看到过有一个工厂既能生产奔驰SUV也能生产宝马SUV吗？这是不可能的，因为业务受限，除非是国内的山寨工厂。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><h5 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CICar()&#123;&#125;;</span><br><span class="line">    ~CICar()&#123;&#125;;</span><br><span class="line">    //汽车的生产商， 也就是牌子</span><br><span class="line">    virtual string msGetBand() = 0;</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在产品接口中我们定义了车辆有两个可以查询的属性：品牌和型号，奔驰车和宝马车是两个不同品牌的产品，但不够具体，只是知道它们的品牌而已，还不能够实例化，因此还是一个抽象类。</p>
<h5 id="抽象宝马车"><a href="#抽象宝马车" class="headerlink" title="抽象宝马车"></a>抽象宝马车</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAbsBMW :public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAbsBMW() &#123; msBand = &quot;宝马汽车&quot;; &#125;</span><br><span class="line">    ~CAbsBMW()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //宝马车</span><br><span class="line">    string msGetBand()&#123; return msBand; &#125;</span><br><span class="line"></span><br><span class="line">    // 型号由具体的实现类实现</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>抽象产品类中实现了产品的类型定义，车辆的型号没有实现，两实现类分别实现商务车和运动型车。</p>
<h5 id="宝马商务车"><a href="#宝马商务车" class="headerlink" title="宝马商务车"></a>宝马商务车</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBMWVan : public CAbsBMW</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWVan()&#123; msModel = &quot;7系列车型商务车&quot;; &#125;;</span><br><span class="line">    ~CBMWVan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="宝马SUV"><a href="#宝马SUV" class="headerlink" title="宝马SUV"></a>宝马SUV</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBMWSuv : public CAbsBMW</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWSuv()&#123; msModel = &quot;X系列车型SUV&quot;; &#125;;</span><br><span class="line">    ~CBMWSuv()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰抽象类"><a href="#奔驰抽象类" class="headerlink" title="奔驰抽象类"></a>奔驰抽象类</h5><p>奔驰车与宝马车类似，都已经有清晰品牌定义，但是型号还没有确认，也是一个抽象的产品类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAbsBenz :public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAbsBenz() &#123; msBand = &quot;奔驰汽车&quot;; &#125;</span><br><span class="line">    ~CAbsBenz()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //奔驰车</span><br><span class="line">    string msGetBand()&#123; return msBand; &#125;</span><br><span class="line"></span><br><span class="line">    // 型号由具体的实现类实现</span><br><span class="line">    virtual string msGetModel() = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰商务车"><a href="#奔驰商务车" class="headerlink" title="奔驰商务车"></a>奔驰商务车</h5><p>由于分类的标准是相同的，因此奔驰车也应该有商务车和运动车两个类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBenzVan : public CAbsBenz</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzVan()&#123; msModel = &quot;R系列商务车&quot;; &#125;;</span><br><span class="line">    ~CBenzVan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="奔驰SUV"><a href="#奔驰SUV" class="headerlink" title="奔驰SUV"></a>奔驰SUV</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CBenzSuv : public CAbsBenz</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzSuv()&#123; msModel = &quot;G系列SUV&quot;; &#125;;</span><br><span class="line">    ~CBenzSuv()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetModel()&#123; return msModel; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msModel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>所有的产品类都已经实现了，剩下的工作就是要定义工厂类进行生产，由于产品类型多样，也导致了必须有多个工厂类来生产不同产品，首先就需要定义一个抽象工厂，声明每个工厂必须完成的职责。<br>抽象工厂定义了每个工厂必须生产两个类型车：SUV（运动车）和VAN（商务车），否则一个工厂就不能被实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CICarFactory()&#123;&#125;;</span><br><span class="line">    ~CICarFactory()&#123;&#125;;</span><br><span class="line">    virtual CICar * mopCreateSuv() = 0;</span><br><span class="line">    virtual CICar * mopCreateVan() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="宝马车工厂"><a href="#宝马车工厂" class="headerlink" title="宝马车工厂"></a>宝马车工厂</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CBMWFactory : public CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWFactory()&#123;&#125;;</span><br><span class="line">    ~CBMWFactory()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产SUV</span><br><span class="line">    CICar * mopCreateSuv() &#123; return new CBMWSuv; &#125;</span><br><span class="line"></span><br><span class="line">    //生产商务车</span><br><span class="line">    CICar * mopCreateVan() &#123; return new CBMWVan; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很简单，你要我生产宝马商务车，没问题，直接产生一个宝马商务车对象，返回给调用者，这对调用者来说根本不需要关心到底是怎么生产的，它只要找到一个宝马工厂，即可生产出自己需要的产品（汽车）。</p>
<h5 id="奔驰车工厂"><a href="#奔驰车工厂" class="headerlink" title="奔驰车工厂"></a>奔驰车工厂</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CBenzFactory : public CICarFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzFactory()&#123;&#125;;</span><br><span class="line">    ~CBenzFactory()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产SUV</span><br><span class="line">    CICar * mopCreateSuv() &#123; return new CBenzSuv; &#125;</span><br><span class="line"></span><br><span class="line">    //生产商务车</span><br><span class="line">    CICar * mopCreateVan() &#123; return new CBenzVan; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用场景"><a href="#调用场景" class="headerlink" title="调用场景"></a>调用场景</h5><p>产品和工厂都具备了，剩下的工作就是建立一个场景类模拟调用者调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //要求生产一辆奔驰SUV</span><br><span class="line">    cout &lt;&lt; &quot;===要求生产一辆奔驰SUV===&quot; &lt;&lt; endl;</span><br><span class="line">    //首先找到生产奔驰车的工厂</span><br><span class="line">    cout &lt;&lt; &quot;A、 找到奔驰车工厂&quot; &lt;&lt; endl;</span><br><span class="line">    CICarFactory *op_factory = new CBenzFactory;</span><br><span class="line">    //开始生产奔驰SUV</span><br><span class="line">    cout &lt;&lt; &quot;B、 开始生产奔驰SUV&quot; &lt;&lt; endl;</span><br><span class="line">    CICar *op_benz_suv = op_factory-&gt;mopCreateSuv();</span><br><span class="line">    //生产完毕， 展示一下车辆信息</span><br><span class="line">    cout &lt;&lt; &quot;C、 生产出的汽车如下： &quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;汽车品牌： &quot; &lt;&lt; op_benz_suv-&gt;msGetBand().c_str() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;汽车型号： &quot; &lt;&lt; op_benz_suv-&gt;msGetModel().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="/2018/08/13/模式PK/1534121943512.png" alt=""></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>对外界调用者来说，只要更换一个具备相同结构的对象，即可发生非常大的改变，如我们原本使用BenzFactory生产汽车，但是过了一段时间后，我们的系统需要生产宝马汽车，这对系统来说不需要很大的改动，只要把工厂类使用BMWFactory代替即可，立刻可以生产出宝马车，注意这里生产的是一辆完整的车，对于一个产品，只要给出产品代码（车类型）即可生产，抽象工厂模式把一辆车认为是一个完整的、不可拆分的对象。它注重完整性，一个产品一旦找到一个工厂生产，那就是固定的型号，不会出现一个宝马工厂生产奔驰车的情况。</p>
<h4 id="造者模式生产车辆"><a href="#造者模式生产车辆" class="headerlink" title="造者模式生产车辆"></a>造者模式生产车辆</h4><p>那现在的问题是我们就想要一辆混合的车型，如奔驰的引擎，宝马的车轮，那该怎么处理呢？使用我们的建造者模式！</p>
<h5 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h5><p>按照建造者模式设计一个生产车辆需要把车辆进行拆分，拆分成引擎和车轮两部分，然后由建造者进行建造，想要什么车，你只要有设计图纸就成，马上可以制造一辆车出来。它注重的是对零件的装配、组合、封装，它从一个细微构件装配角度看待一个对象。我们来看生产车辆的类图。</p>
<p><img src="/2018/08/13/模式PK/1534121951198.png" alt=""></p>
<p>注意看我们类图中的蓝图类Blueprint，它负责对产品建造过程定义。既然要生产产品，那必然要对产品进行一个描述，在类图中我们定义了一个接口来描述汽车。<br>车辆产品描述，我们定义一辆车必须有车轮和引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //汽车车轮</span><br><span class="line">    virtual string msGetWheel() = 0;</span><br><span class="line">    //汽车引擎</span><br><span class="line">    virtual string msGetEngine() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><h5 id="具体车辆"><a href="#具体车辆" class="headerlink" title="具体车辆"></a>具体车辆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CCar : public CICar</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CCar(const string &amp;sEngine, const string &amp;sWheel)</span><br><span class="line">    &#123;</span><br><span class="line">        msEngine = sEngine;</span><br><span class="line">        msWheel = sWheel;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~CCar()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //汽车车轮</span><br><span class="line">    string msGetWheel()  &#123; return msWheel;  &#125;;</span><br><span class="line">    //汽车引擎</span><br><span class="line">    string msGetEngine() &#123; return msEngine;  &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetInfo()&#123; return &quot;车的轮子是： &quot; + msWheel + &quot;\n车的引擎是： &quot; + msEngine; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //汽车引擎</span><br><span class="line">    string msEngine;</span><br><span class="line">    //汽车车轮</span><br><span class="line">    string msWheel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单定义产品的属性，明确对产品的描述。我们继续来思考，因为我们的产品是比较抽象的，它没有指定引擎的型号，也没有指定车轮的牌子，那么这样的组合方式有很多，完全要靠建造者来建造，建造者说要生产一辆奔驰SUV那就得用奔驰的引擎和奔驰的车轮，该建造者对于一个具体的产品来说是绝对的权威，我们来描述一下建造者。</p>
<h5 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CCarBuilder() &#123;&#125;;</span><br><span class="line">    ~CCarBuilder()&#123;&#125;;</span><br><span class="line">    // 接收一份设计蓝图</span><br><span class="line">    void mvSetBlueprint(CBlueprint *opBlueprint)&#123; mopBluprint = opBlueprint; &#125;;</span><br><span class="line">    CCar *mopBuildCar() &#123; return new CCar(msBuildEngine(), msBuildWheel()); &#125;;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // 查看蓝图， 只有真正的建造者才可以查看蓝图</span><br><span class="line">    CBlueprint *mopGetBlueprint() &#123; return mopBluprint; &#125;;</span><br><span class="line">    virtual string msBuildWheel() = 0;</span><br><span class="line">    virtual string msBuildEngine() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    //设计蓝图</span><br><span class="line">    CBlueprint *mopBluprint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到Blueprint类了，它中文的意思是“蓝图”，你要建造一辆车必须有一个设计样稿或者蓝图吧，否则怎么生产？怎么装配？该类就是一个可参考的生产样本。</p>
<h5 id="生产蓝图"><a href="#生产蓝图" class="headerlink" title="生产蓝图"></a>生产蓝图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CBlueprint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string msGetWheel()&#123; return msWheel; &#125;</span><br><span class="line">    void mvSetWheel(const string &amp;sWheel)&#123; msWheel = sWheel; &#125;</span><br><span class="line"></span><br><span class="line">    string msGetEngine()&#123; return msEngine; &#125;</span><br><span class="line">    void mvSetEngine(const string &amp;sEngine) &#123; msEngine = sEngine; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msWheel;</span><br><span class="line">    string msEngine;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这和一个具体的产品Car类是一样的？错，不一样！它是一个蓝图，是一个可以参考的模板，有一个蓝图可以设计出非常多的产品，如有一个R系统的奔驰商务车设计蓝图，我们就可以生产出一系列的奔驰车。它指导我们的产品生产，而不是一个具体的产品。我们来看宝马车建造车间。</p>
<h5 id="宝马车建造车间"><a href="#宝马车建造车间" class="headerlink" title="宝马车建造车间"></a>宝马车建造车间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBMWBuilder : public CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBMWBuilder()&#123;&#125;;</span><br><span class="line">    ~CBMWBuilder()&#123;&#125;;</span><br><span class="line">    string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125;</span><br><span class="line">    string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是非常简单的类。只要获得一个蓝图，然后按照蓝图制造引擎和车轮即可，剩下的事情就交给抽象的建造者进行装配。奔驰车间与此类似。</p>
<h5 id="奔驰车建造车间"><a href="#奔驰车建造车间" class="headerlink" title="奔驰车建造车间"></a>奔驰车建造车间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBenzBuilder : public CCarBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBenzBuilder()&#123;&#125;;</span><br><span class="line">    ~CBenzBuilder()&#123;&#125;;</span><br><span class="line">    string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125;</span><br><span class="line">    string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个建造车间都已经完成，那现在的问题就变成了怎么让车间运作，谁来编写蓝图？谁来协调生产车间？谁来对外提供最终产品？于是导演类出场了，它不仅仅有每个车间需要的设计蓝图，还具有指导不同车间装配顺序的职责。</p>
<h5 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class CDirector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDirector()</span><br><span class="line">    &#123;</span><br><span class="line">        mopBenzBuilder = new CBenzBuilder;</span><br><span class="line">        mopBMWBuilder = new CBMWBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~CDirector()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //生产奔驰SUV</span><br><span class="line">    CCar *mopCreateBenzSuv()</span><br><span class="line">    &#123;</span><br><span class="line">        //制造出汽车</span><br><span class="line">        return mopCreateCar(mopBenzBuilder, &quot;benz的引擎&quot;, &quot;benz的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生产出一辆宝马商务车</span><br><span class="line">    CCar *mopCreateBMWVan()</span><br><span class="line">    &#123;</span><br><span class="line">        return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;BMW的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 生产出一个混合车型</span><br><span class="line">    CCar *mopCreateComplexCar()</span><br><span class="line">    &#123;</span><br><span class="line">        return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;benz的轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">     // 生产车辆</span><br><span class="line">     CCar *mopCreateCar(CCarBuilder *opCarBuilder, const string &amp;sEngine, const string &amp;sWheel)</span><br><span class="line">     &#123;</span><br><span class="line">        //导演怀揣蓝图</span><br><span class="line">         CBlueprint *op_bp = new CBlueprint();</span><br><span class="line">         op_bp-&gt;mvSetEngine(sEngine);</span><br><span class="line">         op_bp-&gt;mvSetWheel(sWheel);</span><br><span class="line">        opCarBuilder-&gt;mvSetBlueprint(op_bp);</span><br><span class="line"></span><br><span class="line">        return opCarBuilder-&gt;mopBuildCar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CCarBuilder *mopBenzBuilder;</span><br><span class="line">    CCarBuilder *mopBMWBuilder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有一个私有方法mopCreateCar，其作用是减少导演类中的方法对蓝图的依赖，全部由该方法来完成。</p>
<h5 id="场景调用"><a href="#场景调用" class="headerlink" title="场景调用"></a>场景调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义出导演类</span><br><span class="line">    CDirector o_director;</span><br><span class="line"></span><br><span class="line">    //给我一辆奔驰车SUV</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆奔驰SUV===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_benz_suv = o_director.mopCreateBenzSuv();</span><br><span class="line">    cout &lt;&lt; op_benz_suv-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //给我一辆宝马商务车</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆宝马商务车===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_bmw_van = o_director.mopCreateBMWVan();</span><br><span class="line">    cout &lt;&lt; op_bmw_van-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //给我一辆混合车型</span><br><span class="line">    cout &lt;&lt; &quot;===制造一辆混合车===&quot; &lt;&lt; endl;</span><br><span class="line">    CCar *op_complex_car = o_director.mopCreateComplexCar();</span><br><span class="line">    cout &lt;&lt; op_complex_car-&gt;msGetInfo().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h5><p>场景类只要找到导演类（也就是车间主任了）说给我制造一辆这样的宝马车，车间主任马上通晓你的意图，设计了一个蓝图，然后命令建造车间拼命加班加点建造，最终返回给你一件最新出品的产品，运行结果如下所示</p>
<p><img src="/2018/08/13/模式PK/1534122001067.png" alt=""></p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>注意最后一个运行结果片段，我们可以立刻生产出一辆混合车型，只要有设计蓝图，这非常容易实现。反观我们的抽象工厂模式，它是不可能实现该功能的，因为它更关注的是整体，而不关注到底用的是奔驰引擎还是宝马引擎，而我们的建造者模式却可以很容易地实现该设计，市场信息变更了，我们就可以立刻跟进，生产出客户需要的产品。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>注意看上面的描述，我们在抽象工厂模式中使用“工厂”来描述构建者，而在建造者模式中使用“车间”来描述构建者，其实我们已经在说它们两者的区别了，抽象工厂模式就好比是一个一个的工厂，宝马车工厂生产宝马SUV和宝马VAN，奔驰车工厂生产奔驰车SUV和奔驰VAN，它是从一个更高层次去看对象的构建，具体到工厂内部还有很多的车间，如制造引擎的车间、装配引擎的车间等，但这些都是隐藏在工厂内部的细节，对外不公布。也就是对领导者来说，他只要关心一个工厂到底是生产什么产品的，不用关心具体怎么生产。而建造者模式就不同了，它是由车间组成，不同的车间完成不同的创建和装配任务，一个完整的汽车生产过程需要引擎制造车间、引擎装配车间的配合才能完成，它们配合的基础就是设计蓝图，而这个蓝图是掌握在车间主任（导演类）手中，它给建造车间什么蓝图就能生产什么产品，建造者模式更关心建造过程。虽然从外界看来一个车间还是生产车辆，但是这个车间的转型是非常快的，只要重新设计一个蓝图，即可产生不同的产品，这有赖于建造者模式的功劳。</p>
<p>相对来说，抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。</p>
<h3 id="工厂模式VS建造者模式"><a href="#工厂模式VS建造者模式" class="headerlink" title="工厂模式VS建造者模式"></a>工厂模式VS建造者模式</h3><blockquote>
<p><a href="http://www.cnblogs.com/ChinaHook/p/7471470.html" target="_blank" rel="noopener">工厂模式VS建造者模式</a><br>Create by bingcaihaung</p>
</blockquote>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，才能创造一个超人。</p>
<h4 id="工厂方法建造超人"><a href="#工厂方法建造超人" class="headerlink" title="工厂方法建造超人"></a>工厂方法建造超人</h4><h5 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h5><p>首先我们按照工厂方法创造超人，我们来看类图。类图中我们按照年龄段把超人分为两种类型：成年超人（如克拉克、超能先生）和未成年超人（如Dash、Jack）。这是一个非常正宗的工厂方法模式，定义一个产品的接口，然后再定义两个实现，通过超人制造工厂制造超人。</p>
<p><img src="/2018/08/13/模式PK/1534122092060.png" alt=""></p>
<h5 id="抽象超人"><a href="#抽象超人" class="headerlink" title="抽象超人"></a>抽象超人</h5><p>想想看我们对超人最大印象是什么？当然是他的超能力，我们以specialTalent（特殊天赋）方法来代表，先看抽象产品类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISuperMan()&#123;&#125;;</span><br><span class="line">    ~CISuperMan()&#123;&#125;;</span><br><span class="line">    virtual void mvSpecialTalent() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="成年超人"><a href="#成年超人" class="headerlink" title="成年超人"></a>成年超人</h5><p>产品的接口定义好了，我们再来看具体的产品。先看成年超人，很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CAdultSuperMan : public CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAdultSuperMan()&#123;&#125;;</span><br><span class="line">    ~CAdultSuperMan()&#123;&#125;;</span><br><span class="line">    void mvSpecialTalent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;超人力大无穷&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="未成年超人"><a href="#未成年超人" class="headerlink" title="未成年超人"></a>未成年超人</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ChildSuperMan : public CISuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ChildSuperMan()&#123;&#125;;</span><br><span class="line">    ~ChildSuperMan()&#123;&#125;;</span><br><span class="line">    void mvSpecialTalent()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;小超人的能力是刀枪不入、 快速运动&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h5><p>产品都具备，那我们编写一个工厂类，其意图就是生产超人，具体是成年超人还是未成年超人，则由客户端决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class CSuperManFactory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CSuperManFactory()&#123;&#125;;</span><br><span class="line">    ~CSuperManFactory()&#123;&#125;;</span><br><span class="line">    CISuperMan *mopCreateSuperMan(string sType)</span><br><span class="line">    &#123;</span><br><span class="line">        if (&quot;adult&quot; == sType)</span><br><span class="line">        &#123;</span><br><span class="line">            return new CAdultSuperMan;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (&quot;child&quot; == sType)</span><br><span class="line">        &#123;</span><br><span class="line">            return new CChildSuperMan;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>产品有了，工厂类也有了，剩下的工作就是开始生产超人。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CSuperManFactory o_factory;</span><br><span class="line">    CISuperMan *op_super = o_factory.mopCreateSuperMan(&quot;adult&quot;);</span><br><span class="line">    op_super-&gt;mvSpecialTalent();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>建立了一个超人生产工厂，年复一年地生产超人，对于具体生产出的产品，不管是成年超人还是未成年超人，都是一个模样：深蓝色紧身衣、胸前S标记、内裤外穿，没有特殊的地方。但是我们的目的达到了——生产出超人，这就是我们的意图。具体怎么生产、怎么组装，这不是工厂方法模式要考虑的，也就是说，工厂模式关注的是一个产品整体，生产出的产品应该具有相似的功能和架构。</p>
<p>注意：通过工厂方法模式生产出对象，然后由客户端进行对象的其他操作，但是并不代表所有生产出的对象都必须具有相同的状态和行为，它是由产品所决定。</p>
<h4 id="建造者模式建造超人"><a href="#建造者模式建造超人" class="headerlink" title="建造者模式建造超人"></a>建造者模式建造超人</h4><h5 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h5><p>我们在抽象建造者上使用了模板方法模式，每一个建造者都必须返回一个产品，但是产品是如何制造的，则由各个建造者自己负责。</p>
<p><img src="/2018/08/13/模式PK/1534122128745.png" alt=""></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><h5 id="产品类-1"><a href="#产品类-1" class="headerlink" title="产品类"></a>产品类</h5><p>超人这个产品是由三部分组成：躯体、特殊技能、身份标记，这就类似于电子产品，首先生产出一个固件，然后再安装一个灵魂（软件驱动），最后再打上产品标签。一个崭新的产品就诞生。我们的超人也是这样生产的，先生产一个普通的躯体，然后注入特殊技能，最后打上S标签，一个超人生产完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CSuperMan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CSuperMan()&#123;&#125;;</span><br><span class="line">    ~CSuperMan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    string msGetBody() &#123; return msBody; &#125;;</span><br><span class="line">    void mvSetBody(const string &amp;sBody) &#123; msBody = sBody; &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetSpecialTalent() &#123; return msSpecialTalent; &#125;;</span><br><span class="line">    void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; msSpecialTalent = sSpecialTalent; &#125;;</span><br><span class="line"></span><br><span class="line">    string msGetSpecialSymbol() &#123; return msSpecialSymbol; &#125;;</span><br><span class="line">    void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; msSpecialSymbol = sSpecialSymbol; &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    string msBody;             //超人的躯体</span><br><span class="line">    string msSpecialTalent;    //超人的特殊技能</span><br><span class="line">    string msSpecialSymbol;    //超人的标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象建造者-1"><a href="#抽象建造者-1" class="headerlink" title="抽象建造者"></a>抽象建造者</h5><p>一个典型的模板方法模式，超人的各个部件（躯体、灵魂、标志）都准备好了，具体怎么组装则是由实现类来决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CBuilder</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    CBuilder() &#123; mopSuperMan = new CSuperMan; &#125;;</span><br><span class="line">    ~CBuilder();</span><br><span class="line"></span><br><span class="line">    void mvSetBody(const string &amp;sBody) &#123; this-&gt;mopSuperMan-&gt;mvSetBody(sBody); &#125;;</span><br><span class="line">    void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialTalent(sSpecialTalent); &#125;;</span><br><span class="line">    void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialSymbol(sSpecialSymbol); &#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual CSuperMan  *mopGetSuperMan() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    CSuperMan *mopSuperMan;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="成年超人-1"><a href="#成年超人-1" class="headerlink" title="成年超人"></a>成年超人</h5><p>设计模式只是提供了一个解决问题的意图：复杂对象的构建与它的表示分离，而没有具体定出一个设计模式必须是这样的实现，必须是这样的代码，灵活运用模式才是其根本，我们通过模版方法加上建造者模式来建造超人。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CAdultSuperManBuilder : public CBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CAdultSuperManBuilder()&#123;&#125;;</span><br><span class="line">    ~CAdultSuperManBuilder()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CSuperMan  *mopGetSuperMan()</span><br><span class="line">    &#123;</span><br><span class="line">        mvSetBody(&quot;强壮的躯体&quot;);</span><br><span class="line">        mvSetSpecialTalent(&quot;会飞行&quot;);</span><br><span class="line">        mvSetSpecialSymbol(&quot;胸前带S标记&quot;);</span><br><span class="line"></span><br><span class="line">        return mopSuperMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="未成年超人-1"><a href="#未成年超人-1" class="headerlink" title="未成年超人"></a>未成年超人</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CChildSuperManBuilder : public CBuilder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CChildSuperManBuilder()&#123;&#125;;</span><br><span class="line">    ~CChildSuperManBuilder()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CSuperMan  *mopGetSuperMan()</span><br><span class="line">    &#123;</span><br><span class="line">        mvSetBody(&quot;强壮的躯体&quot;);</span><br><span class="line">        mvSetSpecialTalent(&quot;刀枪不入&quot;);</span><br><span class="line">        mvSetSpecialSymbol(&quot;胸前带S标记&quot;);</span><br><span class="line"></span><br><span class="line">        return mopSuperMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大家注意看我们这两个具体的建造者，它们都关注了产品的各个部分，在某些应用场景下甚至会关心产品的构建顺序，即使是相同的部件，装配顺序不同，产生的结果也不同，这也正是建造者模式的意图：通过不同的部件、不同装配产生不同的复杂对象。</p>
<h5 id="导演类-1"><a href="#导演类-1" class="headerlink" title="导演类"></a>导演类</h5><p>导演类很简单就不多说了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CDirector &#123;</span><br><span class="line">public:</span><br><span class="line">    CDirector()&#123;&#125;;</span><br><span class="line">    ~CDirector()&#123;&#125;;</span><br><span class="line">    //两个建造者的应用</span><br><span class="line">    CBuilder *mopAdultBuilder = new CAdultSuperManBuilder();</span><br><span class="line">    //未成年超人的建造者</span><br><span class="line">    CBuilder *CChildBuilder = new CChildSuperManBuilder();</span><br><span class="line">    //建造一个成年、 会飞行的超人</span><br><span class="line">    CSuperMan *mopGetAdultSuperMan()&#123; return mopAdultBuilder-&gt;mopGetSuperMan();     &#125;</span><br><span class="line">    // 建造一个未成年、 刀枪不入的超人</span><br><span class="line">    CSuperMan *mopGetChildSuperMan()&#123; return CChildBuilder-&gt;mopGetSuperMan(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="场景调用-1"><a href="#场景调用-1" class="headerlink" title="场景调用"></a>场景调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CDirector o_director;</span><br><span class="line"></span><br><span class="line">    //建造一个成年超人</span><br><span class="line">    CSuperMan *op_adult = o_director.mopGetAdultSuperMan();</span><br><span class="line"></span><br><span class="line">    // 展示超人信息</span><br><span class="line">    cout &lt;&lt; op_adult-&gt;msGetSpecialTalent().c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个场景类的写法与工厂方法模式是相同的，但是你可以看到，在建立超人的过程中，建造者必须关注超人的各个部件，而工厂方法模式则只关注超人的整体，这就是两者的区别。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>工厂方法模式和建造者模式都属于对象创建类模式，都用来创建类的对象。但它们之间的区别还是比较明显的。</p>
<ul>
<li>意图不同</li>
</ul>
<p>在工厂方法模式里，我们关注的是一个产品整体，如超人整体，无须关心产品的各部分是如何创建出来的；但在建造者模式中，一个具体产品的产生是依赖各个部件的产生以及装配顺序，它关注的是“由零件一步一步地组装出产品对象”。简单地说，工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注的是产品组成部分的创建过程。</p>
<ul>
<li>产品的复杂度不同</li>
</ul>
<p>工厂方法模式创建的产品一般都是单一性质产品，如成年超人，都是一个模样，而建造者模式创建的则是一个复合产品，它由各个部件复合而成，部件不同产品对象当然不同。这不是说工厂方法模式创建的对象简单，而是指它们的粒度大小不同。一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。</p>
<p>两者的区别有了，那在具体的应用中，我们该如何选择呢？是用工厂方法模式来创建对象，还是用建造者模式来创建对象，这完全取决于我们在做系统设计时的意图，如果需要详细关注一个产品部件的生产、安装步骤，则选择建造者，否则选择工厂方法模式。</p>
<h3 id="装饰模式VS适配器模式"><a href="#装饰模式VS适配器模式" class="headerlink" title="装饰模式VS适配器模式"></a>装饰模式VS适配器模式</h3><blockquote>
<p><a href="http://www.cnblogs.com/ChinaHook/p/7475540.html" target="_blank" rel="noopener">装饰模式VS适配器模式</a></p>
</blockquote>
<h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。</p>
<p>大家都应该听过丑小鸭的故事吧，我们今天就用这两种模式分别讲述丑小鸭的故事。话说鸭妈妈有5个孩子，其中4个孩子都是黄白相间的颜色，而最小的那只也就是叫做丑小鸭的那只，是纯白色的，与兄弟姐妹不相同，在遭受了诸多的嘲讽和讥笑后，最终丑小鸭变成了一只美丽的天鹅。那我们如何用两种不同模式来描述这一故事呢？</p>
<h4 id="装饰模式描述丑小鸭"><a href="#装饰模式描述丑小鸭" class="headerlink" title="装饰模式描述丑小鸭"></a>装饰模式描述丑小鸭</h4><h5 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h5><p>用装饰模式来描述丑小鸭，首先就要肯定丑小鸭是一只天鹅，只是因为她小或者是鸭妈妈的无知才没有被认出是天鹅，经过一段时间后，它逐步变成一个漂亮、自信、优美的白天鹅。根据分析我们可以这样设计，先设计一个丑小鸭，然后根据时间先后来进行不同的美化处理，怎么美化呢？先长出漂亮的羽毛，然后逐步展现出异于鸭子的不同行为，如飞行，最终在具备了所有的行为后，它就成为一只纯粹的白天鹅了。类图比较简单，非常标准的装饰模式。</p>
<p><img src="/2018/08/13/模式PK/1534122187586.png" alt=""></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="天鹅接口"><a href="#天鹅接口" class="headerlink" title="天鹅接口"></a>天鹅接口</h5><p>我们按照故事的情节发展一步一步地实现程序。初期的时候，丑小鸭表现得很另类，叫声不同，外形不同，致使周围的亲戚、朋友都对她鄙视，那我们来建立这个过程，由于丑小鸭的本质就是一个天鹅，我们就先生成一个天鹅的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISwan()&#123;&#125;;</span><br><span class="line">    ~CISwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //天鹅会飞</span><br><span class="line">    virtual  void mvFly() = 0;</span><br><span class="line">    //天鹅会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line">    //天鹅都有漂亮的外表</span><br><span class="line">    virtual void mvDesAppaearance() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="丑小鸭"><a href="#丑小鸭" class="headerlink" title="丑小鸭"></a>丑小鸭</h5><p>我们定义了天鹅的行为，都会飞行、会叫，并且可以描述她们漂亮的外表。丑小鸭是一只白天鹅，是”is-a”的关系，也就是需要实现这个接口了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CUglyDuckling : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CUglyDuckling()&#123;&#125;;</span><br><span class="line">    ~CUglyDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //丑小鸭的叫声</span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    //丑小鸭的外形</span><br><span class="line">    void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是脏兮兮的白色， 毛茸茸的大脑袋&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    //丑小鸭还比较小，不能飞</span><br><span class="line">    void mvFly()&#123; cout &lt;&lt; &quot;不能飞行&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="抽象装饰类"><a href="#抽象装饰类" class="headerlink" title="抽象装饰类"></a>抽象装饰类</h5><p>丑小鸭具备了天鹅的所有行为和属性，因为她本来就是一只白天鹅，只是因为她太小了还不能飞行，也不能照顾自己，所以丑丑的，在经过长时间的流浪生活后，丑小鸭长大了。终于有一天，她发现自己竟然变成了一只美丽的白天鹅，有着漂亮、洁白的羽毛，而且还可以飞行，这完全是一种升华行为。我们来看看她的行为（飞行）和属性（外形）是如何加强的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CDecorator : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDecorator(CISwan *opSwan)&#123; mopSwan = opSwan; &#125;;</span><br><span class="line">    ~CDecorator()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    virtual void mvCry() &#123; mopSwan-&gt;mvCry(); &#125;</span><br><span class="line">    virtual void mvFly() &#123; mopSwan-&gt;mvFly(); &#125;</span><br><span class="line">    virtual void mvDesAppaearance() &#123; mopSwan-&gt;mvDesAppaearance(); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CISwan *mopSwan;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="外形装饰"><a href="#外形装饰" class="headerlink" title="外形装饰"></a>外形装饰</h5><p>这是一个非常简单的代理模式。我们再来看丑小鸭是如何开始变得美丽的，变化是由外及里的，有了漂亮的外表才有内心的实质变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CBeautifyAppearance : public CDecorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBeautifyAppearance(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 外表美化处理</span><br><span class="line">    void mvDesAppaearance() override &#123; cout &lt;&lt; &quot;外表是纯白色的，非常惹人喜爱！&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="行为装饰"><a href="#行为装饰" class="headerlink" title="行为装饰"></a>行为装饰</h5><p>丑小鸭最后发现自己还能飞行，这是一个行为突破，是对原有行为“不会飞行”的一种强化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CStrongBehavior : public CDecorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CStrongBehavior(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;;</span><br><span class="line">    ~CStrongBehavior()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 会飞行了</span><br><span class="line">    void mvFly() override &#123; cout &lt;&lt; &quot;会飞行了！&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="场景调用-2"><a href="#场景调用-2" class="headerlink" title="场景调用"></a>场景调用</h5><p>所有的故事元素我们都具备了，就等有人来讲故事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //很久很久以前， 这里有一个丑陋的小鸭子</span><br><span class="line">    cout &lt;&lt; &quot;===很久很久以前， 这里有一只丑陋的小鸭子===&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CISwan *op_duck = new CUglyDuckling;</span><br><span class="line">    //展示一下小鸭子</span><br><span class="line">    op_duck-&gt;mvDesAppaearance();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvFly();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;===小鸭子终于发现自己是一只天鹅====&quot; &lt;&lt; endl;</span><br><span class="line">    //首先外形变化了</span><br><span class="line">    op_duck = new CBeautifyAppearance(op_duck);</span><br><span class="line">    //其次行为也发生了改变</span><br><span class="line">    op_duck = new CStrongBehavior(op_duck);</span><br><span class="line">    //虽然还是叫丑小鸭， 但是已经发生了很大变化</span><br><span class="line">    op_duck-&gt;mvDesAppaearance();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvFly();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/2018/08/13/模式PK/1534122227827.png" alt=""></p>
<p>使用装饰模式描述丑小鸭蜕变的过程是如此简单，它关注了对象功能的强化，是对原始对象的行为和属性的修正和加强，把原本被人歧视、冷落的丑小鸭通过两次强化处理最终转变为受人喜爱、羡慕的白天鹅。</p>
<h4 id="适配器模式实现丑小鸭"><a href="#适配器模式实现丑小鸭" class="headerlink" title="适配器模式实现丑小鸭"></a>适配器模式实现丑小鸭</h4><h5 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h5><p>采用适配器模式实现丑小鸭变成白天鹅的过程要从鸭妈妈的角度来分析，鸭妈妈有5个孩子，它认为这5个孩子都是她的后代，都是鸭类，但是实际上是有一只（也就是丑小鸭）不是真正的鸭类，她是一只小白天鹅，因为太小，差别太细微，很难分辨，导致鸭妈妈认为她是一只鸭子，从鸭子的审美观来看，丑小鸭是丑陋的。通过分析，我们要做的就是要设计两个对象：鸭和天鹅，然后鸭妈妈把一只天鹅看成了小鸭子，最终时间到来的时候丑小鸭变成了白天鹅。</p>
<p><img src="/2018/08/13/模式PK/1534122243332.png" alt=""></p>
<p>类图非常简单，我们定义了两个接口：鸭类接口和天鹅类接口，然后建立了一个适配器UglyDuckling，把一只白天鹅封装成了小鸭子。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><h5 id="鸭类接口"><a href="#鸭类接口" class="headerlink" title="鸭类接口"></a>鸭类接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CIDuck()&#123;&#125;;</span><br><span class="line">    ~CIDuck()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line"></span><br><span class="line">    //鸭子的外形</span><br><span class="line">    virtual void mvDesAppearance() = 0;</span><br><span class="line"></span><br><span class="line">    //描述鸭子的其他行为</span><br><span class="line">    virtual void mvDesBehavior() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>鸭类有3个行为，一个是鸭会叫，一个是外形描述，还有一个是综合性的其他行为描述，例如会游泳等。</p>
<h5 id="小鸭子"><a href="#小鸭子" class="headerlink" title="小鸭子"></a>小鸭子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CDuckling : public CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CDuckling()&#123;&#125;;</span><br><span class="line">    ~CDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是嘎——嘎——嘎&quot; &lt;&lt; endl;  &#125;;</span><br><span class="line">    void mvDesAppearance() &#123; cout &lt;&lt; &quot;外形是黄白相间，嘴长&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    // 鸭子的其他行为， 如游泳</span><br><span class="line">    void mvDesBehavior() &#123; cout &lt;&lt; &quot;会游泳&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="白天鹅"><a href="#白天鹅" class="headerlink" title="白天鹅"></a>白天鹅</h5><p>4只正宗的小鸭子形象已经清晰地定义出来了。鸭妈妈还有一个孩子，就是另类的丑小鸭，她实际是一只白天鹅。我们先定义出白天鹅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CISwan()&#123;&#125;;</span><br><span class="line">    ~CISwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //天鹅会飞</span><br><span class="line">    virtual  void mvFly() = 0;</span><br><span class="line">    //天鹅会叫</span><br><span class="line">    virtual void mvCry() = 0;</span><br><span class="line">    //天鹅都有漂亮的外表</span><br><span class="line">    virtual void mvDesAppaearance() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CWhiteSwan : public CISwan</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CWhiteSwan()&#123;&#125;;</span><br><span class="line">    ~CWhiteSwan()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    //白天鹅的叫声</span><br><span class="line">    void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line">    //白天鹅的外形</span><br><span class="line">    void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是纯白色，惹人喜爱&quot; &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    //天鹅是能够飞行的</span><br><span class="line">    void mvFly()&#123; cout &lt;&lt; &quot;能够飞行&quot; &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="当成鸭子的白天鹅"><a href="#当成鸭子的白天鹅" class="headerlink" title="当成鸭子的白天鹅"></a>当成鸭子的白天鹅</h5><p>但是，鸭妈妈却不认为自己这个另类的孩子是白天鹅，它从自己的观点出发，认为她很丑陋，有碍自己的脸面，于是驱赶她——鸭妈妈把这只小天鹅误认为一只鸭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class CUglyDuckling : public CWhiteSwan, public CIDuck</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CUglyDuckling()&#123;&#125;;</span><br><span class="line">    ~CUglyDuckling()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    void mvCry() &#123; CWhiteSwan::mvCry(); &#125;;</span><br><span class="line">    void mvDesAppearance() &#123; CWhiteSwan::mvDesAppaearance(); &#125;;</span><br><span class="line">    void mvDesBehavior()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;会游泳！&quot; &lt;&lt; endl;</span><br><span class="line">        CWhiteSwan::mvFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h5><p>天鹅被看成了鸭子，有点暴殄天物的感觉。我们再来创建一个场景类来描述这一场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //鸭妈妈有5个孩子， 其中4个都是一个模样</span><br><span class="line">    cout &lt;&lt; &quot;===妈妈有五个孩子， 其中四个模样是这样的： ===&quot; &lt;&lt; endl;</span><br><span class="line">    CIDuck *op_duck = new CDuckling();</span><br><span class="line">    op_duck-&gt;mvCry();</span><br><span class="line">    op_duck-&gt;mvDesAppearance();</span><br><span class="line">    op_duck-&gt;mvDesBehavior();</span><br><span class="line">    cout &lt;&lt; &quot;===一只独特的小鸭子， 模样是这样的： ===&quot; &lt;&lt; endl;</span><br><span class="line">    CIDuck *op_ugly_duck = new CUglyDuckling;</span><br><span class="line">    op_ugly_duck-&gt;mvCry();</span><br><span class="line">    op_ugly_duck-&gt;mvDesAppearance();</span><br><span class="line">    op_ugly_duck-&gt;mvDesBehavior();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/2018/08/13/模式PK/1534122278770.png" alt=""></p>
<p>小天鹅被认为是一只丑陋的小鸭子…采用适配器模式讲述丑小鸭的故事，我们首先观察到的是鸭与天鹅的不同点，建立了不同的接口以实现不同的物种，然后在需要的时候（根据故事情节）把一个物种伪装成另外一个物种，实现不同物种的相同处理过程，这就是适配器模式的设计意图。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>我们用两个模式实现了丑小鸭的美丽蜕变。我们发现：这两个模式有较多的不同点。</p>
<ul>
<li>意图不同</li>
</ul>
<p>装饰模式的意图是加强对象的功能，例子中就是把一个怯弱的小天鹅强化成了一个美丽、自信的白天鹅，它不改变类的行为和属性，只是增加（当然了，减弱类的功能也是可能存在的）功能，使美丽更加美丽，强壮更加强壮，安全更加安全；而适配器模式关注的则是转化，它的主要意图是两个不同对象之间的转化，它可以把一个天鹅转化为一个小鸭子看待，也可以把一只小鸭子看成是一只天鹅，它关注转换。</p>
<ul>
<li>施与对象不同</li>
</ul>
<p>装饰模式装饰的对象必须是自己的同宗，也就是相同的接口或父类，只要在具有相同的属性和行为的情况下，才能比较行为是增加还是减弱；适配器模式则必须是两个不同的对象，因为它着重于转换，只有两个不同的对象才有转换的必要，如果是相同对象还转换什么？！</p>
<ul>
<li>场景不同</li>
</ul>
<p>装饰模式在任何时候都可以使用，只要是想增强类的功能，而适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用。</p>
<ul>
<li>扩展性不同</li>
</ul>
<p>装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/C-编译器知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/C-编译器知识/" itemprop="url">C++编译器知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T00:41:26+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/13/C-编译器知识/" class="leancloud_visitors" data-flag-title="C++编译器知识">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LLVM、Clang介绍"><a href="#LLVM、Clang介绍" class="headerlink" title="LLVM、Clang介绍"></a>LLVM、Clang介绍</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>在正式开始之前，插播一段编译器和链接器。<br>编译器主要用于将源代码从高级语言翻译成低级语言（汇编语言、目标代码、机器码），输出目标文件。<br>链接器主要用于将一个或多个目标文件（obj）与库文件（lib）合并成一个可执行文件（exe）或者库文件（lib、dll等）。</p>
<p>编译器可分为前端（front end）和后端（back end），两者以中间代码（IR，Intermediate Representation）为分界。</p>
<p>也可划分成前端、中端和后端，这里的中端主要完成对IR的优化工作，输出仍为IR。</p>
<h3 id="LLVM与Clang"><a href="#LLVM与Clang" class="headerlink" title="LLVM与Clang"></a>LLVM与Clang</h3><p>LLVM全称为Low Level Virtual Machine，按wiki的说法，它是“a collection of modular and reusable compiler and toolchain technologies”，起初只支持C/C++，现已支持多种语言。提及LLVM可能指代的是LLVM project/infrastructure（框架，编译器各个环节对应项目的集合）、An LLVM-based compiler、LLVM libraries（库）、LLVM core（编译器的后端）、The LLVM IR，具体如下：</p>
<blockquote>
<ul>
<li><strong>The LLVM project/infrastructure</strong>: This is an umbrella for several projects that, together, form a complete compiler: frontends, backends, optimizers, assemblers, linkers, libc++, compiler-rt, and a JIT engine. The word “LLVM” has this meaning, for example, in the following sentence: “LLVM is comprised of several projects”.</li>
<li><strong>An LLVM-based compiler</strong>: This is a compiler built partially or completely with the LLVM infrastructure. For example, a compiler might use LLVM for the frontend and backend but use GCC and GNU system libraries to perform the final link. LLVM has this meaning in the following sentence, for example: “I used LLVM to compile C programs to a MIPS platform”.</li>
<li><strong>LLVM libraries</strong>: This is the reusable code portion of the LLVM infrastructure. For example, LLVM has this meaning in the sentence: “My project uses LLVM to generate code through its Just-in-Time compilation framework”.</li>
<li><strong>LLVM core</strong>: The optimizations that happen at the intermediate language level and the backend algorithms form the LLVM core where the project started. LLVM has this meaning in the following sentence: “LLVM and Clang are two different projects”.</li>
<li><strong>The LLVM IR</strong>: This is the LLVM compiler intermediate representation. LLVM has this meaning when used in sentences such as “I built a frontend that translates my own language to LLVM”.<br>——What exactly is LLVM</li>
</ul>
</blockquote>
<p>而Clang呢？Clang是a C language family frontend for LLVM，是C-like语言的编译器前端，支持C, C++, Objective C/C++, OpenCL C等。后端使用LLVM，现已兼容GCC——Clang.LLVM。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BingcaiHuang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BingcaiHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("zB9W7fUpG8e9iQF9I018I0bj-gzGzoHsz", "RkIarEbWMsL4NVGQPKkJwzAi");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
