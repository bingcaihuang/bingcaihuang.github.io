<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BingcaiHuang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="BingcaiHuang&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BingcaiHuang&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>BingcaiHuang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BingcaiHuang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/C-智能指针系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/C-智能指针系列/" itemprop="url">C++智能指针系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T19:02:22+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/07/C-智能指针系列/" class="leancloud_visitors" data-flag-title="C++智能指针系列">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-智能指针系列"><a href="#C-智能指针系列" class="headerlink" title="C++智能指针系列"></a>C++智能指针系列</h2><h3 id="智能指针shared-ptr的用法"><a href="#智能指针shared-ptr的用法" class="headerlink" title="智能指针shared_ptr的用法"></a>智能指针shared_ptr的用法</h3><blockquote>
<p><a href="https://www.cnblogs.com/jiayayao/p/6128877.html" target="_blank" rel="noopener">智能指针shared_ptr的用法</a></p>
</blockquote>
<p>为了解决C++内存泄漏的问题，C++11引入了智能指针（Smart Pointer）。</p>
<p>智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。</p>
<p>C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件<memory>。</memory></p>
<p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。</p>
<h4 id="shared-ptr的基本用法"><a href="#shared-ptr的基本用法" class="headerlink" title="shared_ptr的基本用法"></a>shared_ptr的基本用法</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>可以通过构造函数、std::make_shared<t>辅助函数和reset方法来初始化shared_ptr：</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Person(int v) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        std::cout &lt;&lt; &quot;Cons&quot; &lt;&lt;value&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Des&quot; &lt;&lt;value&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int value;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Person&gt; p1(new Person(1));// Person(1)的引用计数为1</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Person&gt; p2 = std::make_shared&lt;Person&gt;(2);</span><br><span class="line"></span><br><span class="line">    p1.reset(new Person(3));// 首先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1)</span><br><span class="line">                            // 最后将新对象的指针交给智能指针</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Person&gt; p3 = p1;//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2</span><br><span class="line"></span><br><span class="line">    p1.reset();//Person(3)的引用计数为1</span><br><span class="line">    p3.reset();//Person(3)的引用计数为0，析构Person(3)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不能将一个原始指针直接赋值给一个智能指针，如下所示，原因是一个是类，一个是指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p4 = new int(1);// error</span><br></pre></td></tr></table></figure>
<p><strong>reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx())重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管。</strong></p>
<h5 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p4(new int(5));</span><br><span class="line">int *pInt = p4.get();</span><br></pre></td></tr></table></figure>
<h5 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h5><p>智能指针可以指定删除器，当智能指针的引用计数为0时，自动调用指定的删除器来释放内存。std::shared_ptr可以指定删除器的一个原因是其默认删除器不支持数组对象，这一点需要注意。</p>
<h4 id="使用shared-ptr需要注意的问题"><a href="#使用shared-ptr需要注意的问题" class="headerlink" title="使用shared_ptr需要注意的问题"></a>使用shared_ptr需要注意的问题</h4><p>但凡一些高级的用法，使用时都有不少陷阱。<br><strong>不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁，如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p5 = new int;</span><br><span class="line">std::shared_ptr&lt;int&gt; p6(p5);</span><br><span class="line">std::shared_ptr&lt;int&gt; p7(p5);// logic error</span><br></pre></td></tr></table></figure>
<p><strong>不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(shared_ptr&lt;int&gt;(new int), g());</span><br></pre></td></tr></table></figure>
<p><strong>禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构。</strong></p>
<p><strong>避免循环引用。智能指针最大的一个陷阱是循环引用，循环引用会导致内存泄漏。解决方法是AStruct或BStruct改为weak_ptr。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct AStruct;</span><br><span class="line">struct BStruct;</span><br><span class="line"></span><br><span class="line">struct AStruct &#123;</span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~AStruct() &#123; cout &lt;&lt; &quot;AStruct is deleted!&quot;&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct BStruct &#123;</span><br><span class="line">    std::shared_ptr&lt;AStruct&gt; APtr;</span><br><span class="line">    ~BStruct() &#123; cout &lt;&lt; &quot;BStruct is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void TestLoopReference()</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;AStruct&gt; ap(new AStruct);</span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bp(new BStruct);</span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    bp-&gt;APtr = ap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr-使用注意事项"><a href="#shared-ptr-使用注意事项" class="headerlink" title="shared_ptr 使用注意事项"></a>shared_ptr 使用注意事项</h3><blockquote>
<p><a href="https://www.cnblogs.com/daihanlong/p/4716009.html" target="_blank" rel="noopener">c++ shared_ptr 使用注意事项</a></p>
</blockquote>
<h4 id="条款1：不要把一个原生指针给多个shared-ptr管理"><a href="#条款1：不要把一个原生指针给多个shared-ptr管理" class="headerlink" title="条款1：不要把一个原生指针给多个shared_ptr管理"></a>条款1：不要把一个原生指针给多个shared_ptr管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* ptr = new int;</span><br><span class="line">shared_ptr&lt;int&gt; p1(ptr);</span><br><span class="line">shared_ptr&lt;int&gt; p2(ptr); //logic error</span><br></pre></td></tr></table></figure>
<p>ptr对象被删除了2次<br>这种问题比喻成“二龙治水”，在原生指针中也同样可能发生。</p>
<h4 id="条款2：不要把this指针给shared-ptr"><a href="#条款2：不要把this指针给shared-ptr" class="headerlink" title="条款2：不要把this指针给shared_ptr"></a>条款2：不要把this指针给shared_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">public:</span><br><span class="line">    void Do()&#123;  m_member_sp =  shared_ptr&lt;Test&gt;(this);  &#125;</span><br><span class="line">private:</span><br><span class="line">    shared_ptr&lt;Test&gt; m_member_sp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test* t = new Test;</span><br><span class="line">shared_ptr&lt;Test&gt; local_sp(t);</span><br><span class="line">p-&gt;Do();</span><br></pre></td></tr></table></figure>
<p>发生什么事呢，t对象被删除了2次！<br>t对象给了local_sp管理，然后在m_member_sp =  shared_ptr<test>(this)这句里又请了一尊神来管理t。<br>这就发生了条款1里“二龙治水”错误。</test></p>
<h4 id="条款3：不要让shared-ptr的循环引用"><a href="#条款3：不要让shared-ptr的循环引用" class="headerlink" title="条款3：不要让shared_ptr的循环引用"></a>条款3：不要让shared_ptr的循环引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//---------------------------------------------</span><br><span class="line">class Dog;</span><br><span class="line">class Animal&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Animal()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal Deconstructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;Dog&gt; _dog;</span><br><span class="line">&#125;;</span><br><span class="line">//---------------------------------------------</span><br><span class="line">class Dog&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Dog()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Dog Deconstructor&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;Animal&gt; _animal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//---------------------------------------------</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Dog&gt; dog = make_shared&lt;Dog&gt;();</span><br><span class="line">    shared_ptr&lt;Animal&gt; animal = make_shared&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    dog-&gt;_animal = animal;</span><br><span class="line">    animal-&gt;_dog = dog;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 Animal 和 Dog 都不会被回收.<br>解决办法,将 shared_ptr<dog> _dog  或   shared_ptr&lt;Animal&gt; _animal 其中的一个换成  weak_ptr.</dog></p>
<h4 id="条款4：不要在函数实参里创建shared-ptr"><a href="#条款4：不要在函数实参里创建shared-ptr" class="headerlink" title="条款4：不要在函数实参里创建shared_ptr"></a>条款4：不要在函数实参里创建shared_ptr</h4><p>function ( shared_ptr<int>(new int), g( ) );  //有缺陷<br>可能的过程是先new int，然后调g( )，g( )发生异常，shared_ptr<int>没有创建，int内存泄露</int></int></p>
<p>shared_ptr<int> p(new int());<br>f(p, g());  //Boost推荐写法</int></p>
<h4 id="条款5：对象内部生成shared-ptr"><a href="#条款5：对象内部生成shared-ptr" class="headerlink" title="条款5：对象内部生成shared_ptr"></a>条款5：对象内部生成shared_ptr</h4><p>前面说过，不能把this指针直接扔给shared_ptr. 但是没有禁止在对象内部生成自己的shared_ptr</p>
<p>//这是Boost的例子改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Y: public boost::enable_shared_from_this&lt;Y&gt;</span><br><span class="line">&#123;</span><br><span class="line">    boost::shared_ptr&lt;Y&gt; GetSelf()</span><br><span class="line">    &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原理是这样的。普通的（没有继承enable_shared_from_this）类T的shared_ptr<t> p(new T).<br>p作为栈对象占8个字节，为了记录（new T）对象的引用计数，p会在堆上分配16个字节以保存<br>引用计数等“智能信息”。share_ptr没有“嵌入(intrusive)”到T对象，或者说T对象对share_ptr毫不知<br>情。Y对象则不同，Y对象已经被“嵌入”了一些share_ptr相关的信息，目的是为了找到“全局性”的<br>那16字节的本对象的“智能信息”。</t></p>
<p>原理说完了，就是陷阱<br>Y y;<br>boost::shared_ptr<y> p=  y.GetSelf(); //无知的代码，y根本就不是new出来的</y></p>
<p>Y* y = new Y;<br>boost::shared_ptr<y> p=  y-&gt;GetSelf(); //似是而非，仍旧程序崩盘。<br>Boost文档说，在调用shared_from_this()之前，必须存在一个正常途径创建的shared_ptr</y></p>
<p>boost::shared_ptr<y> spy(new Y)<br>boost::shared_ptr<y> p =  spy-&gt;GetSelf(); //OK</y></y></p>
<h4 id="条款6-：处理不是new的对象要小心"><a href="#条款6-：处理不是new的对象要小心" class="headerlink" title="条款6 ：处理不是new的对象要小心"></a>条款6 ：处理不是new的对象要小心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pi = (int*)malloc(4)</span><br><span class="line">shared_ptr&lt;int&gt; sp( pi ) ; //delete马嘴不对malloc驴头。</span><br></pre></td></tr></table></figure>
<h4 id="条款7：多线程对引用计数的影响"><a href="#条款7：多线程对引用计数的影响" class="headerlink" title="条款7：多线程对引用计数的影响"></a>条款7：多线程对引用计数的影响</h4><p>如果是轻量级的锁，比如InterLockIncrement等，对程序影响不大<br>如果是重量级的锁，就要考虑因为share_ptr维护引用计数而造成的上下文切换开销。<br>1.33版本以后的shared_ptr对引用计数的操作使用的是Lock-Free（类似InterLockIncrement函数族）<br>的操作，应该效率不错，而且能保证线程安全（库必须保证其安全，程序员都没有干预这些隐藏事物的机会）。<br>Boost文档说read，write同时对shared_ptr操作时，行为不确定。这是因为shared_ptr本身有两个成员px，pi。<br>多线程同时对px读写是要出问题的。与一个int的全局变量多线程读写会出问题的原因一样。</p>
<h4 id="条款8：对象数组用shared-array"><a href="#条款8：对象数组用shared-array" class="headerlink" title="条款8：对象数组用shared_array"></a>条款8：对象数组用shared_array</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int* pint = new int[100];</span><br><span class="line">shared_array&lt;int&gt; p (pint );</span><br></pre></td></tr></table></figure>
<p>既然shared_ptr对应着delete；显然需要一个delete[]对应物shared_array</p>
<h4 id="条款9：学会用删除器"><a href="#条款9：学会用删除器" class="headerlink" title="条款9：学会用删除器"></a>条款9：学会用删除器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Test_Deleter</span><br><span class="line">&#123;   </span><br><span class="line">    void  operator ()( Test* p)&#123;   ::free(p);   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Test* t = (Test*)malloc(sizeof(Test));</span><br><span class="line">new (t) Test;</span><br></pre></td></tr></table></figure>
<p>shared_ptr<test> sp( t ,  Test_Deleter() ); //删除器可以改变share_ptr销毁对象行为</test></p>
<p>有了删除器，shared_array无用武之地了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct Array_Deleter</span><br><span class="line">&#123;   </span><br><span class="line">    void  operator ()( T*)&#123;   delete[] p;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int* pint = new int[100];</span><br><span class="line">shared_ptr&lt;int&gt; p (pint, Array_Deleter&lt;int&gt;() );</span><br></pre></td></tr></table></figure>
<h4 id="条款10：学会用分配器"><a href="#条款10：学会用分配器" class="headerlink" title="条款10：学会用分配器"></a>条款10：学会用分配器</h4><p>存放引用计数的地方是堆内存，需要16-20字节的开销。<br>如果大量使用shared_ptr会造成大量内存碎片。<br>shared_ptr构造函数的第3个参数是分配器，可以解决这个问题。</p>
<p>shared_ptr<test> p( (new Test), Test_Deleter(), Mallocator<test>() );<br>注意删除器Test_Deleter是针对Test类的。分配器是针对shared_ptr内部数据的。</test></test></p>
<p>Mallocator<test>()是个临时对象（无状态的），符合STL分配器规约。</test></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Mallocator &#123;</span><br><span class="line">    //略。。。。。。</span><br><span class="line">    T * allocate(const size_t n) const &#123;</span><br><span class="line">        return singleton_pool&lt;T,sizeof(T)&gt;::malloc();</span><br><span class="line">    &#125;</span><br><span class="line">    //略。。。。。。</span><br></pre></td></tr></table></figure>
<p>Mallocator传入Test，实际分配的类型确是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class boost::detail::sp_counted_impl_pda&lt;class Test *,</span><br><span class="line">                                         struct Test_Deleter,</span><br><span class="line">                                         class Mallocator&lt;class Test&gt; &gt;</span><br></pre></td></tr></table></figure>
<p>这是用typeid(T).name()打印出来的。可能和rebind相关。</p>
<h4 id="条款11-weak-ptr在使用前需要检查合法性"><a href="#条款11-weak-ptr在使用前需要检查合法性" class="headerlink" title="条款11 weak_ptr在使用前需要检查合法性"></a>条款11 weak_ptr在使用前需要检查合法性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;K&gt; wp;</span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;K&gt;  sp(new K);  //sp.use_count()==1</span><br><span class="line">wp = sp; //wp不会改变引用计数，所以sp.use_count()==1</span><br><span class="line">shared_ptr&lt;K&gt; sp_ok = wp.lock(); //wp没有重载-&gt;操作符。只能这样取所指向的对象</span><br><span class="line">&#125;</span><br><span class="line">shared_ptr&lt;K&gt; sp_null = wp.lock(); //sp_null .use_count()==0;</span><br></pre></td></tr></table></figure>
<p>因为上述代码中sp和sp_ok离开了作用域，其容纳的K对象已经被释放了。<br>得到了一个容纳NULL指针的sp_null对象。在使用wp前需要调用wp.expired()函数判断一下。<br>因为wp还仍旧存在，虽然引用计数等于0，仍有某处“全局”性的存储块保存着这个计数信息。<br>直到最后一个weak_ptr对象被析构，这块“堆”存储块才能被回收。否则weak_ptr无法知道自己<br>所容纳的那个指针资源的当前状态。</p>
<h4 id="条款12-不要new-shared-ptr-lt-T-gt"><a href="#条款12-不要new-shared-ptr-lt-T-gt" class="headerlink" title="条款12 不要new shared_ptr&lt;T&gt;"></a>条款12 不要new shared_ptr&lt;T&gt;</h4><p>本来shared_ptr就是为了管理指针资源的，不要又引入一个需要管理的指针资源shared_ptr<t>*</t></p>
<h4 id="条款13-尽量不要get"><a href="#条款13-尽量不要get" class="headerlink" title="条款13  尽量不要get"></a>条款13  尽量不要get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;...&#125;;</span><br><span class="line">class D : public B&#123; ...&#125;;  //继承层次关系</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;B&gt; sp (new D);    //通过隐式转换，储存D的指针。</span><br><span class="line">B* b = sp.get();             //shared_ptr辛辛苦苦隐藏的原生指针就这么被刨出来了。</span><br><span class="line">D* d = dynamic_cast&lt;D*&gt;(b);  //这是使用get的正当理由吗？</span><br></pre></td></tr></table></figure>
<p>正确的做法<br>shared_ptr&lt;B&gt; spb (new D)  ;<br>shared_ptr&lt;D&gt; spd = shared_dynamic_cast&lt;D&gt;(spb); //变成子类的指针<br>shared_ptr在竭尽全力表演的像一个原生指针，原生指针能干的事，它也基本上能干。</p>
<p>另一个同get相关的错误<br>shared_ptr&lt;T&gt; sp(new T);<br>shared_ptr&lt;T&gt; sp2( sp.get() ) ;//又一个“二龙治水”实例，指针会删2次而错误。</p>
<h4 id="条款14-不要memcpy-shared-ptr"><a href="#条款14-不要memcpy-shared-ptr" class="headerlink" title="条款14 不要memcpy shared_ptr"></a>条款14 不要memcpy shared_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;B&gt; sp1 (new B)  ;</span><br><span class="line">shared_ptr&lt;B&gt; sp2;</span><br><span class="line">memcpy(&amp;sp2,&amp;sp1,sizeof(shared_ptr&lt;B&gt;)); //sp2.use_count()==1</span><br></pre></td></tr></table></figure>
<p>很显然，不是通过正常途径（拷贝构造，赋值运算），引用计数是不会正确增长的。</p>
<h4 id="条款15-使用BOOST预定义的宏去改变shared-ptr行为。"><a href="#条款15-使用BOOST预定义的宏去改变shared-ptr行为。" class="headerlink" title="条款15 使用BOOST预定义的宏去改变shared_ptr行为。"></a>条款15 使用BOOST预定义的宏去改变shared_ptr行为。</h4><p>shared_ptr行为由类似BOOST_SP_DISABLE_THREADS这样的宏控制。需要去学习他们到底是干什么的。<br>大师Andrei Alexandrescu设计了一种基于模板策略设计模式的智能指针，通过几个模板参数去定制化<br>智能指针的行为。Boost却不以为然，官方解释是：需要统一的接口，这样利于大规模书写。<br>smart_ptr&lt;T,OwnershipPolicy,ConversionPolicy,CheckingPolicy,StoragePolicy&gt; sp(new T);<br>上述接口缺点是外形复杂，看上去像个大花脸。优点是客户程序员可以轻易的定制行为。</p>
<h4 id="条款17-构造函数里调用shared-from-this抛例外"><a href="#条款17-构造函数里调用shared-from-this抛例外" class="headerlink" title="条款17 构造函数里调用shared_from_this抛例外"></a>条款17 构造函数里调用shared_from_this抛例外</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Holder:public enable_shared_from_this&lt;Holder&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">    Holder() &#123;</span><br><span class="line">        shared_ptr&lt;Holder&gt; sp = shared_from_this();</span><br><span class="line">        int x = sp.use_count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同前面条款5，不符合enable_shared_from_this使用前提。</p>
<p>总结：<br>学习了一天就总结出10多条条款，长期研究一下恐怕就出现条款100了。为什么还要使用shared_ptr呢？<br>有很多开源库用shared_ptr，而且shared_ptr具有“传染性”（某网友语：像毒品沾上就甩不掉），<br>抛开它就会有更严重的多龙治水现象。shared_ptr作为原生指针的替代品，能解决一定的内存泄露问题。<br>实际上初学原生指针时，每个人都遇到过野指针，删两次，忘记删除等问题。学习shared_ptr也会遇到。<br>shared_ptr的确能改善上述问题，并不能完全解决问题。shared_ptr可能在将来占主流，它最可能号令江湖，<br>否则一大堆auto_ptr,weak_ptr,原生指针，scoped_ptr共存就把人搞糊涂了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/针对范围对的高效查找算法设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/针对范围对的高效查找算法设计/" itemprop="url">针对范围对的高效查找算法设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T18:57:53+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/07/针对范围对的高效查找算法设计/" class="leancloud_visitors" data-flag-title="针对范围对的高效查找算法设计">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="针对范围对的高效查找算法设计"><a href="#针对范围对的高效查找算法设计" class="headerlink" title="针对范围对的高效查找算法设计"></a>针对范围对的高效查找算法设计</h2><blockquote>
<p><a href="https://www.cnblogs.com/lanxuezaipiao/p/3802699.html" target="_blank" rel="noopener">针对范围对的高效查找算法设计（不准用数组）</a></p>
</blockquote>
<p>描述如下：</p>
<p>假如有一群范围对，格式为：&lt;范围表示，该范围对应的结果值&gt;，设计一个最快查找算法，使得给定一个值，输出该值所在范围对的结果值。<br>注意1：范围对之间没有交集，即不可能存在&lt;1, 10&gt;和&lt;2, 11&gt;这样的两个范围对。</p>
<p>注意2：各个区间不一定严格相邻，也就是可能只有&lt;1, 3&gt;和&lt;99, 201&gt;这样两个区间，所以STL中的lower_bound不适用。<br>例如有以下几个范围对：<br>&lt;&lt;1, 2&gt;, 20&gt;<br>&lt;&lt;3, 37&gt;, 27&gt;<br>&lt;&lt;48, 57&gt;, 28&gt;<br>&lt;&lt;58, 63&gt;, 27&gt;<br>&lt;&lt;97, 128&gt;, 122&gt;<br>&lt;&lt;129, 149&gt;, 12&gt;<br>&lt;&lt;150, 189&gt;, 13&gt;<br>&lt;&lt;200, 245&gt;, 14&gt;<br>&lt;&lt;246, 256&gt;, 129&gt;<br>&lt;&lt;479, 560&gt;, 12&gt;</p>
<p>假如给定一个数100，则根据题意应输出122，因为100属于范围对&lt;97, 128&gt;</p>
<p>要求：不要用范围对作为下标用数组来存储，因为范围对可能非常大。</p>
<p>对于这个问题，思考许久，有了下面几个思路：</p>
<h3 id="用STL-map来存储这些范围对（key）及对应的结果集（value），用map进行查找"><a href="#用STL-map来存储这些范围对（key）及对应的结果集（value），用map进行查找" class="headerlink" title="用STL map来存储这些范围对（key）及对应的结果集（value），用map进行查找"></a>用STL map来存储这些范围对（key）及对应的结果集（value），用map进行查找</h3><p>范围对定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class range &#123;</span><br><span class="line">public:</span><br><span class="line">    int from;                                                                  </span><br><span class="line">    int to;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    range(): from(-1), to(-1) &#123;&#125;</span><br><span class="line">    range(int f, int t): from(f), to(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>map定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;range*, int&gt; range_map;</span><br></pre></td></tr></table></figure>
<p>但这里有个问题，map的key是自定义类型，一般需要自定义比较函数才能进行查找，一般的自定义比较函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct cmp_func &#123;</span><br><span class="line">    bool operator()(const range* lc,const range* rc) const &#123;</span><br><span class="line">        return (lc-&gt;from &lt; rc-&gt;from) || (lc-&gt;from == rc-&gt;from &amp;&amp; lc-&gt;to &lt; rc-&gt;to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但这样的比较函数并不适用于我们的需求，因为我们要求查询的并不是一个范围对，即并不是查询map中有没有&lt;3, 37&gt;这样的范围对，而是要求给定一个值，查询这个值属于哪个范围对，那么能不能自定义一个这样的比较函数呢？以上面那个例子为例，如果我们查找35这个数，我们将35包装成一个范围对&lt;35, 35&gt;，然后查找它包含在map中的哪个范围对，上面的例子是包含在&lt;3, 37&gt;这样的范围对，这样就找到了，也就是两个key相等，只要它们包含在同一个范围对即可。这似乎有点奇怪，违背了通常意义上的比较含义（也就是两个key相等，两个key的组成部分都应该相同才是）。不管如何，这样的比较函数还是比较简单的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct cmp_func &#123;</span><br><span class="line">    bool operator()(const range* lc,const range* rc) const &#123;</span><br><span class="line">        return lc-&gt;to &lt; rc-&gt;from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就实现了我们用map的find函数来查找给定的一个数属于哪个范围对了。当然，这时我们的map定义就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;range*, int, cmp_func&gt; range_map;</span><br></pre></td></tr></table></figure>
<p>用map查找表面上看上去应该挺高效的，至少比一个个顺序查找要快吧，但事实却并非如此。我用未自定义比较函数的map顺序查找和自定义上面比较函数的map find查找，结果却发现用自定义比较函数后的效果并不好，竟然比顺序查找还要慢，下面的粗糙的测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class range &#123;</span><br><span class="line">public:</span><br><span class="line">    int from;                                                                  </span><br><span class="line">    int to;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    range(): from(-1), to(-1) &#123;&#125;</span><br><span class="line">    range(int f, int t): from(f), to(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cmp_func &#123;</span><br><span class="line">    bool operator()(const range* lc,const range* rc) const &#123;</span><br><span class="line">        return lc-&gt;to &lt; rc-&gt;from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef map&lt;range*, int, cmp_func&gt; range_map;</span><br><span class="line"></span><br><span class="line">int get_next1(range_map *rm, int c) &#123;</span><br><span class="line">    for(range_map::iterator it = rm-&gt;begin(); it != rm-&gt;end(); ++it) &#123;</span><br><span class="line">        if(c &gt;= it-&gt;first-&gt;from &amp;&amp; c &lt;= it-&gt;first-&gt;to) return it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; // not found.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_next2(range_map *rm, int c) &#123;</span><br><span class="line">    range_map::iterator iter = rm-&gt;find(new range(c, c));</span><br><span class="line">    if(iter != rm-&gt;end())  return iter-&gt;second;</span><br><span class="line"></span><br><span class="line">    return -1;  // not found.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct timeval t_begin, t_end;</span><br><span class="line"></span><br><span class="line">    range_map *rm = new range_map();</span><br><span class="line"></span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(1, 2), 20));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(3, 37), 27));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(48, 57), 28));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(58, 63), 27));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(97, 128), 122));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(129, 149), 12));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(150, 189), 12));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(200, 245), 14));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(246, 256), 129));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(479, 560), 12));</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;t_begin,NULL);</span><br><span class="line">    int result[256];</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        result[c] = get_next1(rm, c);</span><br><span class="line">    gettimeofday(&amp;t_end,NULL);</span><br><span class="line">    double timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec);</span><br><span class="line">    timeuse/=1000000;</span><br><span class="line">    printf(&quot;\nget_next1 time use: %.12f\n&quot;, timeuse);</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;t_begin,NULL);</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        result[c] = get_next2(rm, c);</span><br><span class="line">    gettimeofday(&amp;t_end,NULL);</span><br><span class="line">    timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec);</span><br><span class="line">    timeuse/=1000000;</span><br><span class="line">    printf(&quot;\nget_next2 time use: %.12f\n&quot;, timeuse);</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_next1 time use: 0.000124000000</span><br><span class="line">get_next2 time use: 0.000144000000</span><br></pre></td></tr></table></figure>
<p>当然这个例子并不能代表所有情况，且每次运行结果也不一样，但从每次的运行结果来看，几乎没有一次是用自定义比较函数比顺序查找情况好的。这至少说明了一点：我们的自定义比较函数让map在查找时做了一些额外的工作，减慢了速度。比如我们为了使用map的find函数，不得不封装我们的一个数为一个range对象，在查找的时候还得调用我们自定义的比较函数进行处理。</p>
<p>难道就只能顺序查找吗？在这个不靠谱的思路过后又萌生了另一个不靠谱的思路。</p>
<h3 id="使用二分查找的思想来查找范围对"><a href="#使用二分查找的思想来查找范围对" class="headerlink" title="使用二分查找的思想来查找范围对"></a>使用二分查找的思想来查找范围对</h3><p>我们使用ranges和results这两个数组来保存范围对及对应的结果，按序保存，每两个ranges数对应一个results里的数。</p>
<p>例如上面的例子保存为：</p>
<p>int ranges[] = {1, 2, 3, 37, 48, 57, 58, 63, 97, 128, 129, 149, 150, 189, 200, 245, 246, 256, 479, 560};<br>int results[] = {20, 27, 28, 27, 122, 12, 13, 14, 129, 12};</p>
<p>使用二分查找来查找某个数属于哪个范围对。那么如何查找呢？比如查找35属于哪个范围对，首先与最中间的128进行比较，35&lt;128，这时候有两种可能：</p>
<p>（1）100在128前半部分的数组里，即1, 2, 3, 37, 48, 57, 58, 63, 97；</p>
<p>（2）由于128是范围对&lt;97, 128&gt;的第二部分，那么也有可能这个数属于这个范围对。</p>
<p>由于35不属于这个范围对，那么只有在97之前的部分找（不包括97），继续二分即与37进行比较，35 &lt; 37，与上类似，此时35属于范围对&lt;3, 37&gt;，也就是找到了。</p>
<p>再举个例子，找130属于哪个范围对，同样的先与128比较，130 &gt; 128，这时候130只可能在128的后半部分而不需要判断是否属于范围对&lt;128, 129&gt;，因为&lt;128, 129&gt;不是范围对。怎么判断是不是范围对呢？很简单，根据当前位置的奇偶性判断即可。</p>
<p>下面是我写的二分查找算法，及与map顺序查找、数组顺序查找的简单对比试验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class range &#123;</span><br><span class="line">public:</span><br><span class="line">    int from;                                                                  </span><br><span class="line">    int to;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    range(): from(-1), to(-1) &#123;&#125;</span><br><span class="line">    range(int f, int t): from(f), to(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef map&lt;range*, int&gt; range_map;</span><br><span class="line"></span><br><span class="line">int get_next1(range_map *rm, int c) &#123;</span><br><span class="line">    for(range_map::iterator it = rm-&gt;begin(); it != rm-&gt;end(); ++it) &#123;</span><br><span class="line">        if(c &gt;= it-&gt;first-&gt;from &amp;&amp; c &lt;= it-&gt;first-&gt;to) return it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; // not found.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// binary search</span><br><span class="line">int get_next2(int *ranges, int *results, int size, int c) &#123;</span><br><span class="line">    if(size &lt;= 1) return -1;</span><br><span class="line"></span><br><span class="line">    int start, end, mid;</span><br><span class="line">    start = 0;</span><br><span class="line">    end = size - 1;</span><br><span class="line"></span><br><span class="line">    while(start &lt;= end) &#123;</span><br><span class="line">        if(c &lt; ranges[start] || c &gt; ranges[end]) return -1;</span><br><span class="line">        mid = start + (end - start) / 2;</span><br><span class="line">        if(c == ranges[mid]) return results[mid / 2];</span><br><span class="line">        if(c &lt; ranges[mid]) &#123;</span><br><span class="line">            if(mid % 2 == 1) &#123;</span><br><span class="line">                if(c &gt;= ranges[mid - 1]) return results[mid / 2];</span><br><span class="line">                else end = mid - 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else end = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if(mid % 2 == 0) &#123;</span><br><span class="line">                if(c &lt;= ranges[mid + 1]) return results[mid / 2];</span><br><span class="line">                else start = mid + 2;</span><br><span class="line">            &#125;</span><br><span class="line">            else start = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;  // not found.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_next3(int *ranges, int *results, int size, int c) &#123;</span><br><span class="line">    for(int i = 0; i &lt; size;) &#123;</span><br><span class="line">        if(i % 2 == 0) &#123;</span><br><span class="line">            if(c &gt;= ranges[i] &amp;&amp; c &lt;= ranges[i + 1]) return results[i / 2];</span><br><span class="line">            else if(c &lt; ranges[i]) return -1;</span><br><span class="line">            else i += 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct timeval t_begin, t_end;</span><br><span class="line"></span><br><span class="line">    range_map *rm = new range_map();</span><br><span class="line"></span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(1, 2), 20));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(3, 37), 27));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(48, 57), 28));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(58, 63), 27));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(97, 128), 122));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(129, 149), 12));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(150, 189), 13));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(200, 245), 14));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(246, 256), 129));</span><br><span class="line">    rm-&gt;insert(pair&lt;range*, int&gt;(new range(479, 560), 12));</span><br><span class="line"></span><br><span class="line">    int ranges[] = &#123;1, 2, 3, 37, 48, 57, 58, 63, 97, 128, 129, 149, 150, 189, 200, 245, 246, 256, 479, 560&#125;;</span><br><span class="line">    int results[] = &#123;20, 27, 28, 27, 122, 12, 13, 14, 129, 12&#125;;</span><br><span class="line"></span><br><span class="line">    // int r = get_next2(ranges, results, 20, 65);</span><br><span class="line">    // cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;t_begin,NULL);</span><br><span class="line">    int result[256];</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        result[c] = get_next1(rm, c);</span><br><span class="line">    gettimeofday(&amp;t_end,NULL);</span><br><span class="line">    double timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec);</span><br><span class="line">    timeuse/=1000000;</span><br><span class="line">    printf(&quot;\nget_next1 time use: %.12f\n&quot;, timeuse);</span><br><span class="line">    // for(int c = 0; c &lt; 256; c++)</span><br><span class="line">    //     cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;;</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;t_begin,NULL);</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        result[c] = get_next2(ranges, results, 20, c);</span><br><span class="line">    gettimeofday(&amp;t_end,NULL);</span><br><span class="line">    timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec);</span><br><span class="line">    timeuse/=1000000;</span><br><span class="line">    printf(&quot;\nget_next2 time use: %.12f\n&quot;, timeuse);</span><br><span class="line">    // for(int c = 0; c &lt; 256; c++)</span><br><span class="line">    //     cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;;</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;t_begin,NULL);</span><br><span class="line">    for(int c = 0; c &lt; 256; c++)</span><br><span class="line">        result[c] = get_next3(ranges, results, 20, c);</span><br><span class="line">    gettimeofday(&amp;t_end,NULL);</span><br><span class="line">    timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec);</span><br><span class="line">    timeuse/=1000000;</span><br><span class="line">    printf(&quot;\nget_next3 time use: %.12f\n&quot;, timeuse);</span><br><span class="line">    // for(int c = 0; c &lt; 256; c++)</span><br><span class="line">    //     cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;;</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_next1 time use: 0.000302000000</span><br><span class="line">get_next2 time use: 0.000043000000</span><br><span class="line">get_next3 time use: 0.000165000000</span><br></pre></td></tr></table></figure>
<p>说明二分查找算法还是挺高效的，顺序查找也不错，有时候表现的与二分查找差不多，这里的数据比较少，体现不出准确的对比，但至少可能说明二分查找算法比简单的顺序查找（map顺序和数组顺序查找）要快不少。</p>
<p>上面是自己的一点拙见，相信二分查找算法肯定不是最高效的算法，但目前实在想不出更好的办法了。大家有想法的尽管提，不试试不知道算法好不好！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现/" itemprop="url">UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T18:40:21+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/07/UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现/" class="leancloud_visitors" data-flag-title="UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现"><a href="#UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现" class="headerlink" title="UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现"></a>UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在UML类图中，类之间的关系可以分成：关联(association)、聚合(aggregation)、组合(composition)、依赖(dependency)、泛化(generalization)/继承(inheritance)和实现(realization)。这六种关系如下图所描绘：</p>
<p><img src="/2018/08/07/UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现/1533638525606.png" alt=""></p>
<p>上面的关系可以解读如下:</p>
<ul>
<li>(关联)Association：A类有B类有逻辑上的连接</li>
<li>(聚合)Aggregation : A类有一个B类</li>
<li>(组合)Composition : A类拥有一个B类</li>
<li>(依赖)Dependency : A类使用了B类</li>
<li>(继承)Inheritance : B类是一个A类  (或者B类扩展A类)</li>
<li>(实现)Realization : B类实现了接口A</li>
</ul>
<p>本篇文章主要是展示在Java中如何表示这些关系 ,以便我们可以更好地理解这些关系并且知道如何以及何时使用每一种关系。</p>
<h3 id="关联-association"><a href="#关联-association" class="headerlink" title="关联(association)"></a>关联(association)</h3><p>关联描述两个类之间行为的一般二元关系。例如，一个学生选修一门特定的课程是学生类Student和课程类Course之间的一个关联，而一个教师教授一门课程是师资类Faculty和课程类Course之间的一个关联。Java代码中，关联可以用属性和方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private Course[] courses;</span><br><span class="line"></span><br><span class="line">    public void addCourse(Course s) &#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Course &#123;</span><br><span class="line">    private Strudent[] students;</span><br><span class="line">    private Faculty faculty;</span><br><span class="line"></span><br><span class="line">    public void addStudent(Student s) &#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFaculty(Faculty faculty) &#123;</span><br><span class="line">        this.faculty = faculty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Faculty &#123;</span><br><span class="line">    private Course[] courses;</span><br><span class="line"></span><br><span class="line">    public void addCourse(Course s) &#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h3><p>聚合是一种特殊的关联(Association)形式，表示两个对象之间的所属(has-a)关系。所有者对象称为聚合对象，它的类称为聚合类；从属对象称为被聚合对象，它的类称为被聚合类。例如，一个公司有很多员工就是公司类Company和员工类Employee之间的一种聚合关系。被聚合对象和聚合对象有着各自的生命周期，即如果公司倒闭并不影响员工的存在。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public class Company &#123;</span><br><span class="line">    private List&lt;Employee&gt; employees;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h3><p>聚合是一种较弱形式的对象包含(一个对象包含另一个对象)关系。较强形式是组合(Composition). 在组合关系中包含对象负责被包含对象的创建以及生命周期，即当包含对象被销毁时被包含对象也会不复存在。例如一辆汽车拥有一个引擎是汽车类Car与引擎类Engine的组合关系。下面是组合的一些例子。</p>
<p>(1)通过成员变量初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private final Engine engine = new Engine();       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Engine &#123;</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)通过构造函数初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private final Engine engine;  </span><br><span class="line"></span><br><span class="line">    public Car()&#123;</span><br><span class="line">       engine  = new Engine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Engine &#123;</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(3)通过延迟初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    private final Engine engine;  </span><br><span class="line">    public Engine getEngine() &#123;</span><br><span class="line">        if (null == engine) &#123;</span><br><span class="line">            engine = new Engine();</span><br><span class="line">        &#125;</span><br><span class="line">        return engine;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Engine &#123;</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h3><p>依赖(Dependency)描述的是一个类的引用用作另一个类的方法的参数。例如，可以使用Calendar类中的setTime(Date date)方法设置日历，所以Calendar和Date之间的关系可以用依赖描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public final void setTime(Date date) &#123;</span><br><span class="line">        setTimeInMillis(date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在依赖关系中，类之间是松耦合的。</p>
<h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h3><p>继承(Inheritance)模拟两个类之间的is-a关系。强是(strong is-a)关系描述两个类之间的直接继承关系。弱是(weak is-a)关系描述一个类具有某个属性。强是关系可以用类的继承表示。例如，Spring的ApplicationEvent是一个EventObject，ApplicationEvent和EventObject间就是一种强是关系，可以用继承描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationEvent extends EventObject &#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现(Realization)"></a>实现(Realization)</h3><p>实现(Realization)描述的是一个类实现了接口（可以是多个）。上面描述的弱是(weak is-a)关系就可以用接口表示。例如字符串是可以被序列化的，这就可以用实现来描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String  implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    . . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/06/一个可注销的通用多路回调列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/06/一个可注销的通用多路回调列表/" itemprop="url">一个可注销的通用多路回调列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-06T14:03:27+08:00">
                2018-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/06/一个可注销的通用多路回调列表/" class="leancloud_visitors" data-flag-title="一个可注销的通用多路回调列表">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个可注销的通用多路回调列表"><a href="#一个可注销的通用多路回调列表" class="headerlink" title="一个可注销的通用多路回调列表"></a>一个可注销的通用多路回调列表</h2><blockquote>
<p>文章出处：<a href="https://gulu-dev.com/post/2015-07-22-multicast" target="_blank" rel="noopener">(C++) 一个可注销的通用多路回调列表</a></p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>回调列表是个很常见的东东，经常被用在 Observer 这样的订阅/发布模式里。当系统触发一个事件时，会遍历所有已经注册的回调列表，挨个调用，通知到相关的对象。</p>
<p>我们知道，为了保持对 C 尽可能的兼容，一直以来，C++ 中的函数并非是所谓的“一级对象” (first-class objects)。而在函数指针的帮助下，我们可以在 C/C++ 中模拟一些 First-class function 才有的特性，比如把函数像值一样以参数传递和保存。到了 C++11 的出现，有了语言和标准库级别的 lambda / closure / std::function 之后，对函数的操作才变得真正灵活和丰富起来。</p>
<p>常见的 C/C++ 回调列表有以下这几种实现方式：</p>
<ol>
<li><strong>基类指针 （形如 std::vector&lt;IListener*&gt;）</strong>，当回调发生时，以虚函数的形式通知到不同的派生类的对象。这个方案的问题在于，凡是想加入这个列表，必须从 IListener 派生，而且所有的虚函数要求签名严格一致，耦合太高，灵活性较差。</li>
<li><strong>函数指针 （形如 std::vector<fncallback>）</fncallback></strong>，当回调发生时，挨个调用容器中的函数指针。这个方案避免了继承的强耦合，但仍需要保证所有的响应函数签名一致，而且每一种类型的响应函数都要定义不同的回调列表，多了之后非常啰嗦，再一个函数指针本身可读性也欠佳。</li>
<li><strong>函数对象 （形如std::vector&lt;std::function&lt; … &gt;&gt;）</strong>，这种回调列表相对于上面两个更加灵活一些，不仅不需要继承，在 std::bind 的帮助下，连函数签名也不需要一致。但问题是，由于 std::function 无法使用 == 和 != 来比较（见参考一(第1条)和参考二），注销比较麻烦，不像上面两个可以直接指针比较。</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>那么这里介绍的所谓通用回调列表有何好处呢？</p>
<ol>
<li>（以所谓“完美转发”的形式）支持任意个数和类型的参数调用</li>
<li>在上面第三点 std::function&lt;&gt; 的基础上，可以使用 std::string 作为 tag， 标记那些后面需要被注销的函数，也同时支持不打 tag 的函数</li>
<li>在需要时，支持批量地收集这些回调函数的返回值</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>说完了好处，接下来看一下 BtMulticast 这个类的对外接口和基本的使用吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename TRet, class... TArgs&gt;</span><br><span class="line">class BtMulticast</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using TFunc = std::function &lt; TRet(TArgs...) &gt; ;</span><br><span class="line">    using TElem = std::pair &lt; TFunc, std::string &gt; ;</span><br><span class="line">    using TRetVect = std::vector &lt; std::pair &lt; TRet, std::string &gt; &gt;;</span><br><span class="line"></span><br><span class="line">    bool AddFunc(TFunc func);</span><br><span class="line">    bool AddFunc(const std::string&amp; tag, TFunc func);</span><br><span class="line">    void RemoveFunc(const std::string&amp; tag);</span><br><span class="line"></span><br><span class="line">    template&lt;class... U&gt; void Invoke(U&amp;&amp;... u);</span><br><span class="line">    template&lt;class... U&gt; TRetVect InvokeR(U&amp;&amp;... u);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector &lt; TElem &gt; m_funcList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个类很简短，</p>
<ul>
<li><code>AddFunc</code> / <code>RemoveFunc</code> 是添加和删除回调函数</li>
<li><code>Invoke</code> / <code>InvokeR</code> 分别触发无返回值和普通返回值的回调。</li>
</ul>
<p>需要注意的是，</p>
<ol>
<li><code>AddFunc()</code> 可以选择指明 tag， 在这种情况下可通过指明 tag 来 <code>RemoveFunc</code></li>
<li><code>InvokeR()</code> 实际上返回的是一个返回值列表，采集了每一个回调的结果</li>
<li><code>TFunc</code> 这个类型定义了最终存储在 <code>BtMulticast</code> 类中的回调函数对象，利用了 C++11 的所谓“完美转发”来把任意类型和个数的参数转发给回调函数</li>
<li>考虑到 add/remove 通常只发生一次，而每次触发事件都会遍历，内部的存储选择 <code>std::vector</code>，牺牲了一点 add/remove 时的查找速度，换得更快更紧凑的遍历。而看一下实现代码就可以知道，牺牲的那点 add/remove 速度也只有在有 tag 的情况下会发生。</li>
</ol>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>使用方面，基本用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// testing multicast: simplest</span><br><span class="line">&#123;</span><br><span class="line">    BtMulticast&lt;void&gt; test;</span><br><span class="line">    test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 1 called. &quot;); &#125;);</span><br><span class="line">    test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 2 called. &quot;); &#125;);</span><br><span class="line">    test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 3 called. &quot;); &#125;);</span><br><span class="line">    test.Invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三个匿名函数被添加进 test 对象，然后在 test.Invoke() 的时候被依次调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// testing multicast: tagged &amp; single parameter</span><br><span class="line">&#123;</span><br><span class="line">    BtMulticast&lt;void, int&gt; test;</span><br><span class="line">    test.AddFunc(&quot;a&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func a called (param: %d). &quot;, p); &#125;);</span><br><span class="line">    test.AddFunc(&quot;b&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func b called (param: %d). &quot;, p); &#125;);</span><br><span class="line">    test.AddFunc(&quot;c&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func c called (param: %d). &quot;, p); &#125;);</span><br><span class="line">    test.RemoveFunc(&quot;b&quot;);</span><br><span class="line">    test.Invoke(15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三个 tag 分别为 “a”, “b”, “c” 的匿名函数 (参数为 int，注意实例化 BtMulticast 时的类型参数列表变化) 被注册进来，然后 tag 为 “b” 的匿名函数被移除，最后以 15 作为参数依次调用剩下的回调函数 (“a” 和 “c”)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// testing multicast with multiple parameters and return value list</span><br><span class="line">&#123;</span><br><span class="line">    BtMulticast&lt;int, int, int&gt; testRet;</span><br><span class="line">    testRet.AddFunc(&quot;a&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func a called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 1 * p2; &#125;);</span><br><span class="line">    testRet.AddFunc(&quot;b&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func b called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 2 * p2; &#125;);</span><br><span class="line">    testRet.AddFunc(&quot;c&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func c called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 3 * p2; &#125;);</span><br><span class="line">    testRet.RemoveFunc(&quot;b&quot;);</span><br><span class="line"></span><br><span class="line">    for (auto&amp; p : testRet.InvokeR(20, 2))</span><br><span class="line">        BT_LOG(&quot;Multicast (with RetVal): func %s returned %d. &quot;, p.second, p.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后这个用例测试了多个参数和返回值的情况，可以看到 “a”, “b”, “c” 做了不同的操作后，返回的值被采集到了一个返回值列表里面，这个列表被就地 (即所谓的 move 语意) 遍历，内部的值可以根据需要再进行处理。这个用例的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Multicast (with RetVal): func a called (p1: 20, p2: 2).</span><br><span class="line">Multicast (with RetVal): func c called (p1: 20, p2: 2).</span><br><span class="line">Multicast (with RetVal): func a returned 22.</span><br><span class="line">Multicast (with RetVal): func c returned 26.</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>BtMulticast</code> 能够适配任意个数和类型的参数，因此可认为具有一定的通用性。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>最后我们简单看一下实现。先看看 <code>BtMulticast::AddFunc()</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename TRet, class... TArgs&gt;</span><br><span class="line">bool BtMulticast&lt;TRet, TArgs...&gt;::AddFunc(const std::string&amp; tag, TFunc func)</span><br><span class="line">&#123;</span><br><span class="line">    // check if this tag has been used</span><br><span class="line">    if (tag.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto it = std::find_if(m_funcList.begin(), m_funcList.end(),</span><br><span class="line">            [&amp;tag](const TElem&amp; elem) &#123; return elem.second == tag; &#125;);</span><br><span class="line">        if (it != m_funcList.end())</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_funcList.emplace_back(func, tag);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 tag 有效时，先判定是否有 tag 冲突，然后注册一下回调，过程很直白就不多说了。</p>
<p>再看一下具体的调用过程 <code>BtMulticast::InvokeR()</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* ----- Note -----</span><br><span class="line">    `BtMulticastRetVect` is an extra alias especially for the returning type for the signature of InvokeR() below,</span><br><span class="line">    since `TRetVect` defined inside `BtMulticast` cannot be used in the signature (outside the function body)</span><br><span class="line">    although `BtMulticastRetVect` is defined separately, it literally equals to `typename BtMulticast::TRetVect`</span><br><span class="line">*/</span><br><span class="line">template &lt;typename TRet&gt;</span><br><span class="line">using BtMulticastRetVect = std::vector &lt; std::pair &lt; TRet, std::string &gt; &gt; ;</span><br><span class="line"></span><br><span class="line">template &lt;typename TRet, class... TArgs&gt;</span><br><span class="line">template &lt;class... U&gt;</span><br><span class="line">BtMulticastRetVect&lt;TRet&gt; BtMulticast&lt;TRet, TArgs...&gt;::InvokeR(U&amp;&amp;... u)</span><br><span class="line">&#123;</span><br><span class="line">    BtMulticastRetVect&lt;TRet&gt; ret;</span><br><span class="line">    for (auto&amp; p : m_funcList)</span><br><span class="line">    &#123;</span><br><span class="line">        ret.emplace_back(p.first(std::forward&lt;U&gt;(u)...), p.second);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到我单独定义了一下返回值的类型，具体原因见注释，大体上是说类内定义的类型 <code>TRetVect</code> 只能在类内使用 (包括类定义及相关的成员函数体的定义，成员函数的签名不算在内)。另外这函数前面的两个 <code>template</code> 声明分别是类的模板和函数的模板。</p>
<p>俺一直觉得 C++ 的模板声明挺啰嗦，很有孔乙己范儿，看了上面这个函数声明，你也一定深有同感罢。应该跟 D 学一下，简化一下。</p>
<p>C++ 的 <code>typedef</code> 和 <code>class template</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef double A;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; struct B</span><br><span class="line">&#123;</span><br><span class="line">    typedef int A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>D 的对应语法 <code>alias</code> 和模板的 <code>(T)</code> 语法，简洁到没朋友。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias A = double;</span><br><span class="line"></span><br><span class="line">class B(T)</span><br><span class="line">&#123;</span><br><span class="line">    alias A = int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过 C++ 已经把 D 的 alias 关键字的用法学来了，翻到前面可以看到 class BtMulticast 的定义中的那一组 using，把 alias 抄了个十足十，啧啧，借鉴得不错。</p>
<p>BtMulticast 类的实现和测试用例代码见<a href="https://gist.github.com/mc-gulu/ae73eb94e005fcf720c6" target="_blank" rel="noopener">这里</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/03/C-基础系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BingcaiHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BingcaiHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/C-基础系列/" itemprop="url">C++基础系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T19:06:54+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/08/03/C-基础系列/" class="leancloud_visitors" data-flag-title="C++基础系列">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-基础系列"><a href="#C-基础系列" class="headerlink" title="C++基础系列"></a>C++基础系列</h2><h3 id="C-C-中各种类型int、long、double、char表示范围（最大最小值）"><a href="#C-C-中各种类型int、long、double、char表示范围（最大最小值）" class="headerlink" title="C/C++中各种类型int、long、double、char表示范围（最大最小值）"></a>C/C++中各种类型int、long、double、char表示范围（最大最小值）</h3><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;string&gt;  </span><br><span class="line">#include &lt;limits&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t);  </span><br><span class="line">    cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl;  </span><br><span class="line">    // &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/03/C-基础系列/1533294525273.png" alt=""></p>
<p>/*运行结果分析：<br>以上结果已经很明白了，一下补充说明几点：<br>概念、整型：表示整数、字符和布尔值的算术类型合称为整型（integral type）。<br>关于带符号与无符号类型：整型 int、stort  和  long 都默认为带符号型。要获得无符号型则必须制定该类型为unsigned，比如unsigned long。unsigned int类型可以简写为unsigned，也就是说，unsigned后不加其他类型说明符就意味着是unsigned int。<br>一字节表示八位，即：1byte = 8 bit;<br>int: 4byte =  32 bit 有符号signed范围：2^31-1 ~ -2^31即：2147483647 ~ -2147483648无符号unsigned范围：2^32-1 ~ 0即：4294967295 ~ 0<br>long: 4 byte = 32 bit 同int型<br>double: 8 byte = 64 bit 范围：1.79769e+308 ~ 2.22507e-308<br>long double: 12 byte = 96 bit 范围： 1.18973e+4932 ~ 3.3621e-4932<br>float: 4 byte = 32 bit 范围： 3.40282e+038 ~ 1.17549e-038<br>int、unsigned、long、unsigned long 、double的数量级最大都只能表示为10亿，即它们表示十进制的位数不超过10个，即可以保存所有9位整数。而short只是能表示5位；</p>
<p>另外对于浮点说而言：使用double类型基本上不会有错。在float类型中隐式的精度损失是不能忽视的，二双精度计算的代价相对于单精度可以忽略。事实上，在有些机器上，double类型比float类型的计算要快得多。float型只能保证6位有效数字，而double型至少可以保证15位有效数字（小数点后的数位），long double型提供的精度通常没有必要，而且还要承担额外的运行代价。<br>double是8字节共64位，其中小数位占52位，2-^52=2.2204460492503130808472633361816e-16，量级为10^-16，故能够保证2^-15的所有精度。<br>在有些机器上，用long类型进行计算所付出的运行时代价远远高于用int类型进行同样计算的代价，所以算则类型前要先了解程序的细节并且比较long类型与int类型的实际运行时性能代价。</p>
<h3 id="浅析Windows中的句柄Handle的本质"><a href="#浅析Windows中的句柄Handle的本质" class="headerlink" title="浅析Windows中的句柄Handle的本质"></a>浅析Windows中的句柄Handle的本质</h3><blockquote>
<p>参考文章：<br><a href="http://www.cjjjs.com/paper/czxt/67201512320501.aspx" target="_blank" rel="noopener">浅析Windows中的句柄Handle的本质</a><br>[摘要] 本文讨论Windows中的句柄Handle的本质，使程序员能够真正熟悉经常使用的句柄的含义。相信通过本文会对句柄有一个确切的认识，能够更好的指导编程开发。</p>
</blockquote>
<p>在Windows中，句柄是非常有用的东西。什么是句柄。有很多资料，包括MSDN也讲述了句柄是一个32位或者64位的整数值，是一种数据类型，标志了一个对象，可以通过这个句柄访问对象。看了这样的解释，我不相信你就真的明白了句柄是什么。<br>    在C和C++中，指针是无所不能的，因此也是很危险的。系统的很多东西，如果知道确切地址，通过指针就可以直接修改，从而破坏系统。有了指针，指针中的值就存放了内存地址，就可以直接对内存的数据进行修改。系统的内核的东西，是不允许直接访问的，所有操作都必须通过API函数进行，这样就可以保证系统不会被破坏。但是要访问内核的东西，总得要有一个可以定位的东西，比如说地址，这样才能真正知道要操作内核的哪些东西，因为东西很多，总要区分一下。如果说直接给地址，用指针形式进行定位操作，那就会危及系统，所以微软就不提供这种方法来操作。很自然，就采用了一个代号，给内存的所有东西取个名字，就产生一个代号，通过这个代号，你并不知道它的确切的位置，你就无从直接操作它，就不会带来破坏。这个代号要让访问者知道，就必须存储起来，而访问者在系统中是以进程的形式存在的，所以，这些代号就跟进程相关了。一个进程创建了一个东西，这个东西就会返回一个代号，这个代号就记录到进程的一个表了，这样就可以通过这个代号找到这个东西了。而在这个表中，肯定是有一个映射关系的，也就是，这个代号一定会与这个东西的位置进行关联，以后通过这个代号，在表里就能够找到这个东西的地址，然后再操作这个东西。<br>    说了这么多很不专业的描述，相信你对这个过程大致有印象了。这个代号就是句柄，这个表就是句柄表，这个句柄表就是与进程相关的，而这些东西就是系统中被创建的内存中的内存块。现在相信你对于微软为什么搞出一个句柄有所体会了吧。<br>    句柄的存在，保证了系统的安全，程序员不用通过指针直接操作内存中的东西，将句柄传入API函数，函数在内部会在当前的进程的句柄表中去找这个句柄对应的内存块的地址，以及判断该内存块的访问权限和标志，然后再执行之后的操作。这样一来，如果是非法访问，你对于那块内存面都见不到，更不用说去破坏了。而如果是指针，只要指针指向了那个内存块，你就可以对它任意操作了。<br>    所以说，理解句柄，理解到这个地步，你脑子的很多疑问都会自然的没了，看句柄也会顺眼多了。线程句柄、文件句柄、GDI句柄等等，本质都是一样的。如果你不理解的话，还要以为是好多种数据类型，其实就是一个类型。知道了本质，一切都很自然了。<br>    当然，本文只是大致讨论了一下，要想更加深入的理解，本文是远远不够。但是对于初学者来说，了解到这个，已经很够用了。</p>
<h3 id="类内const-static-static-const-成员变量初始化问题"><a href="#类内const-static-static-const-成员变量初始化问题" class="headerlink" title="类内const static(static const)成员变量初始化问题"></a>类内const static(static const)成员变量初始化问题</h3><blockquote>
<p>参考文章：<br><a href="http://www.cnblogs.com/yanqi0124/p/3795244.html" target="_blank" rel="noopener">类内const static(static const)成员变量初始化问题</a></p>
</blockquote>
<p>在查找const相关资料的过程中，又遇到了另外一个问题，就是C++类中const static（或者static const）成员变量应当如何初始化的问题。</p>
<p>　　查阅了许多资料，发现VC环境下，只允许const static成员变量在类外初始化，这个应该是编译器遗留下的bug（你也可以说是要求严格）。</p>
<p>　　在其他编译器下，整型以及枚举类型的const static成员变量是允许在声明的同时进行初始的，其中整型包括int、short、long、char等，非整型是指浮点型 包括float、double等。尽管可以在类内进行初始化，但是我在网上看到两种解释：</p>
<h4 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h4><p>虽然可以进行初始化，但是这种初始化时不够严格地，倘若对变量取地址 （这里并不是指 &amp;操作符，而是指所有需要用到这个变量的存储空间的操作 比如 ++ 之类，其实这儿我也没看懂到底什么是取地址），就会出现错误，这是因为这种在类内的初始化是不会分配内存的，应当再次在类外进行定义来获取内存分配（无需再赋值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int age = 18;</span><br><span class="line">&#125;;</span><br><span class="line">const int people::age;</span><br></pre></td></tr></table></figure>
<h4 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h4><p>之所以整型有这种特权，是为了设计一个更明确（类型）的常量定义语法来取代用enum定义常量的旧方式。因为出发点是这个，所以才仅仅只是对静态整形常量特殊处理，因为enum也只能是整型值。现在的最新标准完全允许在类内进行定义，并且当你用到取地址操作时，它就会分配内存，类似于常量折叠（const folding），所以无需在外再次定义，这是完全没有问题的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int age = 18;</span><br><span class="line">&#125;;</span><br><span class="line">//不需要const int people::age;</span><br></pre></td></tr></table></figure>
<p>对于上述解释，作为一个初学者，也没法从绝对的知识点上判断到底哪个是对的，根据我在VS2013中敲代码实际测试来看，解释一、二是代码都是对的，都不会报错，但是我在codeblock中运行时，如果对age进行const int *p=&amp;people::age操作时，一不会报错而二报错，所以我支持解释一的说法。如果有哪位大神有幸看到这篇文章，还望指点一二，感激不尽！</p>
<h3 id="“阻塞（pend）”与“挂起（suspend）”的区别？"><a href="#“阻塞（pend）”与“挂起（suspend）”的区别？" class="headerlink" title="“阻塞（pend）”与“挂起（suspend）”的区别？"></a>“阻塞（pend）”与“挂起（suspend）”的区别？</h3><ul>
<li>理解一：挂起是一种主动行为，因此恢复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列。</li>
<li>理解二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试。</li>
<li>理解三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task;</li>
<li>理解四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。可以这样理解，只要是挂起状态，操作系统就不在管理这个任务了。</li>
<li>理解五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。</li>
</ul>
<p>操作系统中睡眠、阻塞、挂起的区别形象解释<br>首先这些术语都是对于线程来说的。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的。<br>挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”。<br>使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。<br>线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。</p>
<h3 id="函数传递的参数是原参数的副本"><a href="#函数传递的参数是原参数的副本" class="headerlink" title="函数传递的参数是原参数的副本"></a>函数传递的参数是原参数的副本</h3><p>函数的传递的参数是原参数的副本<br>　　 使用C语言编程，不可能不用到函数，但是函数的参数传递，我们是否真的清楚了呢。本文主要介绍C语言中函数传递的参数。。<br>　　 函数的参数通常分为两种，普通变量，指针变量。这些参数，将会被函数体调用，当让，也可以传入一些永远不被函数调用的参数，就像你声明了一些变量，却永远不用一样，在语法上是没有问题的。<br>　　 那么，函数体内调用的传递过来的参数，与原来的参数有什么关系呢？<br>　　 函数体内接收到的参数，是原参数的副本。<br>　　1. 普通变量在函数中的传递 首先我们来看普通变量，函数体内的参数为该普通变量的拷贝副本。下面是一个例子的源程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">include &lt;stdlib.h&gt;</span><br><span class="line">int test(int t1, int t2);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int t1 = 10;</span><br><span class="line">	int t2 = 0;</span><br><span class="line">	printf(&quot;[main]t1: %d\tt1:%x\n&quot;, t1, &amp;t1);</span><br><span class="line">	printf(&quot;[main]t2: %d\tt2:%x\n&quot;, t2, &amp;t2);</span><br><span class="line">	test(t1, t2);</span><br><span class="line"></span><br><span class="line">	printf(&quot;[main]t1: %d\tt1:%x\n&quot;, t1, &amp;t1);</span><br><span class="line">	printf(&quot;[main]t2: %d\tt2:%x\n&quot;, t2, &amp;t2);</span><br><span class="line"></span><br><span class="line">	system(&quot;PAUSE&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">	nt test(int t1, int t2)</span><br><span class="line"></span><br><span class="line">	printf(&quot;in func....\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;[test]t1: %d\tt1:%x\n&quot;, t1, &amp;t1);</span><br><span class="line">	printf(&quot;[test]t2: %d\tt2:%x\n&quot;, t2, &amp;t2);</span><br><span class="line">	t2 = t1;</span><br><span class="line">	printf(&quot;[test]after t2 = t1\n&quot;);</span><br><span class="line">	printf(&quot;[test]t1: %d\tt1:%x\n&quot;, t1, &amp;t1);</span><br><span class="line">	printf(&quot;[test]t2: %d\tt2:%x\n&quot;, t2, &amp;t2);</span><br><span class="line">	printf(&quot;in func over....\n&quot;);</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　[main]t1: 10 t1:22ff7c</span><br><span class="line">　　[main]t2: 0 t2:22ff78</span><br><span class="line">　　in func....</span><br><span class="line">　　[test]t1: 10 t1:22ff60</span><br><span class="line">　　[test]t2: 0 t2:22ff64</span><br><span class="line">　　[test]after t2 = t1</span><br><span class="line">　　[test]t1: 10 t1:22ff60</span><br><span class="line">　　[test]t2: 10 t2:22ff64</span><br><span class="line">　　in func over....</span><br><span class="line">　　[main]t1: 10 t1:22ff7c</span><br><span class="line">　　[main]t2: 0 t2:22ff78</span><br></pre></td></tr></table></figure></p>
<p>　　（打印的地址值可能与我获得的结果不同。）<br>　　 可以看到，t1和t2，在被test函数调用前后，其值和地址都未变化。而在test函数中，t1和t2的地址与main函数中并不相同，其只是原来的t1和t2的拷贝副本。对副本作的一切操作，都不会影响到test函数外的原来的参数。<br>　　2. 指针变量在函数中的传递 指针作为变量在函数传递中，有些特殊，对于普通变量，函数传递的是对其的一份拷贝的副本，而对于指针，函数传递的是对其存放地址的一份拷贝，该拷贝存放的地址与原来的指针所存的地址一致。<br>　　 我们来看看例子程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int test(char *t1, char *t2);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">　　 char t1[] = &quot;kdsfkasdfkdsf&quot;;</span><br><span class="line">　　 char *t2 = NULL;</span><br><span class="line">　　 printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[main]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　 test(t1, t2);</span><br><span class="line">　　 printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[main]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　</span><br><span class="line">　　 system(&quot;PAUSE&quot;);</span><br><span class="line">　　 return 0;</span><br><span class="line">　　&#125;</span><br><span class="line">　　int test(char *t1, char *t2)</span><br><span class="line">　　&#123;</span><br><span class="line">　　 printf(&quot;in func....\n&quot;);</span><br><span class="line">　　 printf(&quot;[test]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[test]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　 t2 = t1;</span><br><span class="line">　　 printf(&quot;[test]after t2 = t1\n&quot;);</span><br><span class="line">　　 printf(&quot;[test]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[test]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　 printf(&quot;in func over....\n&quot;);</span><br><span class="line">　　 return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[main]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff68</span><br><span class="line">[main]t2: (null) t2:0 &amp;t2:22ff64</span><br><span class="line">in func....</span><br><span class="line">[test]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff40</span><br><span class="line">[test]t2: (null) t2:0 &amp;t2:22ff44</span><br><span class="line">[test]after t2 = t1</span><br><span class="line">[test]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff40</span><br><span class="line">[test]t2: kdsfkasdfkdsf t2:22ff68 &amp;t2:22ff44</span><br><span class="line">in func over....</span><br><span class="line">[main]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff68</span><br><span class="line">[main]t2: (null) t2:0 &amp;t2:22ff64</span><br></pre></td></tr></table></figure>
<p>（打印的地址值可能与我获得的结果不同。）<br>　　 可以看到，在main函数中，t1、t2所存放的地址，以及该地址对应的字符串的值，与test函数中传递的t1、t2完全一样，但t1、t2的地址却完全不同，<br>　　l 故指针在函数中传递的是其地址的一份拷贝，可以在函数体内，修改指针存放的地址对应的值，其修改在函数体外对原参数同样有效，因为原参数也指向该地址。<br>　　l 指针在函数体内可修改其所存放的地址，但其修改对函数体外原指针参数无效，因为其只是原指针参数的地址副本，原指针依然指向原来的地址。<br>　　3. 使用指针的指针在函数体内修改指针所指对象 如果一定要修改指针参数所指的地址，应该怎么作呢？这时，我们需要用到指针的指针了。请看例子程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int test(char **t1, char **t2);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">　　 char *t1 = &quot;tttt&quot;;</span><br><span class="line">　　 char *t2 = NULL;</span><br><span class="line">　　 printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[main]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　 test(&amp;t1, &amp;t2);</span><br><span class="line">　　</span><br><span class="line">　　 printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1);</span><br><span class="line">　　 printf(&quot;[main]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2);</span><br><span class="line">　　 //printf(&quot;[main]t2: %s\n&quot;, t2);</span><br><span class="line">　　</span><br><span class="line">　　 system(&quot;PAUSE&quot;);</span><br><span class="line">　　 return 0;</span><br><span class="line">　　&#125;</span><br><span class="line">　　int test(char **t1, char **t2)</span><br><span class="line">　　&#123;</span><br><span class="line">　　 printf(&quot;[test]in func....\n&quot;);</span><br><span class="line">　　 printf(&quot;[test]*t1: %s\tt1:%x\n&quot;, *t1, t1);</span><br><span class="line">　　 printf(&quot;[test]*t2: %s\tt2:%x\n&quot;, *t2, t2);</span><br><span class="line">　　 *t2 = *t1;</span><br><span class="line">　　 printf(&quot;[test]after *t2 = *t1\n&quot;);</span><br><span class="line">　　 printf(&quot;[test]*t1: %s\tt1:%x\n&quot;, *t1, t1);</span><br><span class="line">　　 printf(&quot;[test]*t2: %s\tt2:%x\n&quot;, *t2, t2);</span><br><span class="line">　　</span><br><span class="line">　　 printf(&quot;[test]in func over....\n&quot;);</span><br><span class="line">　　 return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深入理解指针函数"><a href="#深入理解指针函数" class="headerlink" title="深入理解指针函数"></a>深入理解指针函数</h3><h4 id="指针函数的定义"><a href="#指针函数的定义" class="headerlink" title="指针函数的定义"></a>指针函数的定义</h4><p>顾名思义，指针函数即返回指针的函数。其一般定义形式如下：</p>
<h5 id="类型名-函数名-函数参数表列"><a href="#类型名-函数名-函数参数表列" class="headerlink" title="类型名 *函数名(函数参数表列);"></a>类型名 *函数名(函数参数表列);</h5><p>其中，后缀运算符括号“()”表示这是一个函数，其前缀运算符星号“*”表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。 “(函数参数表列)”中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pfun(int, int);</span><br></pre></td></tr></table></figure>
<p> 由于“*”的优先级低于“()”的优先级，因而pfun首先和后面的“()”结合，也就意味着，pfun是一个函数。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *(pfun(int, int));</span><br></pre></td></tr></table></figure>
<p>接着再和前面的“*”结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。 我们不妨来再看一看，指针函数与函数指针有什么区别？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*pfun)(int, int);</span><br></pre></td></tr></table></figure></p>
<p>通过括号强行将pfun首先与“*”结合，也就意味着，pfun是一个指针，接着与后面的“()”结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。</p>
<h4 id="用函数指针作为函数的返回值"><a href="#用函数指针作为函数的返回值" class="headerlink" title="用函数指针作为函数的返回值"></a>用函数指针作为函数的返回值</h4><p>在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*ff(int))(int *, int);</span><br></pre></td></tr></table></figure></p>
<p>我们用上面介绍的方法分析一下，ff首先与后面的“()”结合，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*(ff(int)))(int *, int);          // 用括号将ff(int)再括起来</span><br></pre></td></tr></table></figure></p>
<p>也就意味着，ff是一个函数。<br>    接着与前面的“*”结合，说明ff函数的返回值是一个指针。然后再与后面的“()”结合，也就是说，该指针指向的是一个函数。<br>这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*PF)(int *, int);</span><br></pre></td></tr></table></figure></p>
<p>也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int (*PF)(int *, int);</span><br></pre></td></tr></table></figure></p>
<p>这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PF ff(int);</span><br></pre></td></tr></table></figure></p>
<p>下面将以程序清单1为例，说明用函数指针作为函数的返回值的用法。当程序接收用户输入时，如果用户输入d，则求数组的最大值，如果输入x，则求数组的最小值，如果输入p，则求数组的平均值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">double GetMin( double *dbData, int iSize )              /* 求最小值 */</span><br><span class="line">&#123;</span><br><span class="line">	double	dbMin;</span><br><span class="line">	int	i;</span><br><span class="line"></span><br><span class="line">	assert( iSize &gt; 0 );</span><br><span class="line">	dbMin = dbData[0];</span><br><span class="line">	for ( i = 1; i &lt; iSize; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		if ( dbMin &gt; dbData[i] )</span><br><span class="line">		&#123;</span><br><span class="line">			dbMin = dbData[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return(dbMin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">double GetMax( double *dbData, int iSize )                 /* 求最大值 */</span><br><span class="line">&#123;</span><br><span class="line">	double	dbMax;</span><br><span class="line">	int	i;</span><br><span class="line"></span><br><span class="line">	assert( iSize &gt; 0 );</span><br><span class="line">	dbMax = dbData[0];</span><br><span class="line">	for ( i = 1; i &lt; iSize; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		if ( dbMax &lt; dbData[i] )</span><br><span class="line">		&#123;</span><br><span class="line">			dbMax = dbData[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return(dbMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">double GetAverage( double *dbData, int iSize )               /* 求平均值 */</span><br><span class="line">&#123;</span><br><span class="line">	double	dbSum = 0;</span><br><span class="line">	int	i;</span><br><span class="line"></span><br><span class="line">	assert( iSize &gt; 0 );</span><br><span class="line">	for ( i = 0; i &lt; iSize; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		dbSum += dbData[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return(dbSum / iSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">double UnKnown( double *dbData, int iSize )                     /* 未知算法 */</span><br><span class="line">&#123;</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef double (*PF)( double *dbData, int iSize );              /* 定义函数指针类型 */</span><br><span class="line">PF GetOperation( char c )                                       /* 根据字符得到操作类型，返回函数指针 */</span><br><span class="line">&#123;</span><br><span class="line">	switch ( c )</span><br><span class="line">	&#123;</span><br><span class="line">	case &apos;d&apos;:</span><br><span class="line">		return(GetMax);</span><br><span class="line">	case &apos;x&apos;:</span><br><span class="line">		return(GetMin);</span><br><span class="line">	case &apos;p&apos;:</span><br><span class="line">		return(GetAverage);</span><br><span class="line">	default:</span><br><span class="line">		return(UnKnown);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( void )</span><br><span class="line">&#123;</span><br><span class="line">	double	dbData[]	= &#123; 3.1415926, 1.4142, -0.5, 999, -313, 365 &#125;;</span><br><span class="line">	int	iSize		= sizeof(dbData) / sizeof(dbData[0]);</span><br><span class="line">	char	c;</span><br><span class="line"></span><br><span class="line">	printf( &quot;Please input the Operation :\n&quot; );</span><br><span class="line">	c = getchar();</span><br><span class="line">	printf( &quot;result is %lf\n&quot;, GetOperation( c ) ( dbData, iSize ) ); /* 通过函数指针调用函数 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中前面4个函数分别实现求最大值、最小值、平均值和未知算法，然后实现了GetOperation函数。这个函数根据字符的返回值实现上面4个函数。它是以函数指针的形式返回的，从后面的main函数的GetOperation(c)(dbData, iSize)可以看出，通过这个指针可以调用函数。</p>
<h3 id="C-容器groupby"><a href="#C-容器groupby" class="headerlink" title="C++容器groupby"></a>C++容器groupby</h3><blockquote>
<p>参考文章：<br><a href="https://stackoverflow.com/questions/12335860/c-algorithm-like-pythons-groupby" target="_blank" rel="noopener">C++ algorithm like python’s ‘groupby’</a></p>
</blockquote>
<p>The one-liner I have provided is not well-optimized for the case when your vector is already sorted. A number of map lookups can be reduced if we remember the iterator of previously inserted object, so it the “key” of the next object and do a lookup only when the key is changing. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct foo &#123;</span><br><span class="line">    int         x;</span><br><span class="line">    std::string y;</span><br><span class="line">    float       z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class optimized_inserter &#123;</span><br><span class="line">  public:</span><br><span class="line">    typedef std::map&lt;int, std::vector&lt;foo&gt; &gt; map_type;</span><br><span class="line"></span><br><span class="line">    optimized_inserter(map_type &amp; map) : map(&amp;map), it(map.end()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void operator()(const foo &amp; obj) &#123;</span><br><span class="line">        typedef map_type::value_type value_type;</span><br><span class="line">        if (it != map-&gt;end() &amp;&amp; last_x == obj.x) &#123;</span><br><span class="line">            it-&gt;second.push_back(obj);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        last_x = obj.x;</span><br><span class="line">        it = map-&gt;insert(value_type(obj.x, std::vector&lt;foo&gt;(&#123; obj &#125;))).first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    map_type          *map;</span><br><span class="line">    map_type::iterator it;</span><br><span class="line">    int                last_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;foo&gt; foos;</span><br><span class="line">    std::map&lt;int, std::vector&lt;foo&gt;&gt; foos_by_x;</span><br><span class="line"></span><br><span class="line">    foos.push_back(&#123; 1, &quot;one&quot;, 1.0 &#125;);</span><br><span class="line">    foos.push_back(&#123; 3, &quot;third&quot;, 2.5 &#125;);</span><br><span class="line">    foos.push_back(&#123; 1, &quot;one.. but third&quot;, 1.5 &#125;);</span><br><span class="line">    foos.push_back(&#123; 2, &quot;second&quot;, 1.8 &#125;);</span><br><span class="line">    foos.push_back(&#123; 1, &quot;one.. but second&quot;, 1.5 &#125;);</span><br><span class="line"></span><br><span class="line">    std::sort(foos.begin(), foos.end(), [](const foo &amp; lhs, const foo &amp; rhs) &#123;</span><br><span class="line">            return lhs.x &lt; rhs.x;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    std::for_each(foos.begin(), foos.end(), optimized_inserter(foos_by_x));</span><br><span class="line"></span><br><span class="line">    for (const auto &amp; p : foos_by_x) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;--- &quot; &lt;&lt; p.first &lt;&lt; &quot;---\n&quot;;</span><br><span class="line">        for (auto &amp; f : p.second) &#123;</span><br><span class="line">            std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; f.x &lt;&lt; &quot; &apos;&quot; &lt;&lt; f.y &lt;&lt; &quot;&apos; / &quot; &lt;&lt; f.z &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组指针理解"><a href="#二维数组指针理解" class="headerlink" title="二维数组指针理解"></a>二维数组指针理解</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define k 100</span><br><span class="line">int b[k], *q=0;//用指针要初始化！</span><br><span class="line">q = b; //指针q指向数组b的首地址</span><br></pre></td></tr></table></figure>
<p>以后使用数组b的元素，比如b[?]，均可用q[?]代替！（注：?表示某整数索引值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = b+i;//此时指针q不再指向数组首地址，而是指向b[i]元素的地址</span><br></pre></td></tr></table></figure>
<p>若要给b[i]元素更新值，可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b[i] = ?; //或者</span><br><span class="line">q[i] = ?; //都是等价的。</span><br></pre></td></tr></table></figure>
<p>而这时的q[i]可以写作：*(q+i)，注意加括号！也就是说，<br>q[i]与*(q+i)等价！代表“值”<br>&amp;q[i]与 q+i 等价！代表“地址”</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[3][5];</span><br></pre></td></tr></table></figure>
<p>对于这句，你先把[5]挡住，别看：int a[3]<br>什么意思？声明一个数组a，有三个元素，分别是a[0],a[1],a[2]<br>物理位置：<br>口口口<br>a[0],a[1],a[2]<br>再接上[5]：int a[3][5];<br>什么意思？对于数组a的三个元素，每个元素又都有5个元素，分别是：<br>a[0]——a[0][0],a[0][1],a[0][2],a[0][3],a[0][4]<br>a[1]——a[1][0],a[1][1],a[1][2],a[1][3],a[1][4]<br>a[2]——a[2][0],a[2][1],a[2][2],a[2][3],a[2][4]<br>物理位置：<br>口口口口口 口口口口口 口口口口口<br>前五个“口”对应与上一个图的第一个“口”；中间五个对应第二个“口”，最后五个对应第三个“口”。这相当于又把上一个图里的三个“口”每一个都细分了5份！<br>你该看出来：a[0],a[1],a[2]相当于三个一维数组！每个都有5个元素。</p>
<p>二维数组名“a”，标识a[0][0]的地址。注意，它是一个地址常量，不能被更新，比如：a++，a–，a=？……都是错的！但可以用在赋值号“=”的右边。稍后举例</p>
<p>概括的说，指针其实就是可变数组的首地址，说是可变数组，是指其包含内容的数量的可变的，并且是可动态申请和释放的，从而充分节约宝贵的内存资源。我一向喜欢一维数组，除非万不得已，我一般是不用二维数组的，多维的则更是很少涉足了。因为一维简单，容易理解，而用指针指向的多维数组就具有相当的复杂性了，也因此更具有讨论的必要。<br>    闲话少说，这里我就以三个二维数组的比较来展开讨论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、int **Ptr;</span><br><span class="line">(2)、int *Ptr[ 5 ];</span><br><span class="line">(3)、int ( *Ptr )[ 5 ];</span><br></pre></td></tr></table></figure></p>
<p>以上三例都是整数的二维数组，都可以用形如 Ptr[ 1 ][ 1 ] 的方式访问其内容；但它们的差别却是很大的。下面我从四个方面对它们进行讨论：</p>
<h5 id="一、内容："><a href="#一、内容：" class="headerlink" title="一、内容："></a>一、内容：</h5><pre><code>它们本身都是指针，它们的最终内容都是整数。注意我这里说的是最终内容，而不是中间内容，比如你写 Ptr[ 0 ]，对于三者来说，其内容都是一个整数指针，即 int \*；Ptr[ 1 ][ 1  ] 这样的形式才是其最终内容。
</code></pre><h5 id="二、意义："><a href="#二、意义：" class="headerlink" title="二、意义："></a>二、意义：</h5><pre><code>(1)、int \*\*Ptr 表示指向&quot;一群&quot;指向整数的指针的指针。
(2)、int \*Ptr[ 5 ] 表示指向 5 个指向整数的指针的指针。
(3)、int ( \*Ptr )[ 5 ] 表示指向&quot;一群&quot;指向 5 个整数数组的指针的指针。
</code></pre><h5 id="三、所占空间："><a href="#三、所占空间：" class="headerlink" title="三、所占空间："></a>三、所占空间：</h5><pre><code>(1)、int \*\*Ptr 和 (3)、int ( \*Ptr )[ 5 ] 一样，在32位平台里，都是4字节，即一个指针。但 (2)、int \*Ptr[ 5 ] 不同，它是 5 个指针，它占5 * 4 = 20个字节的内存空间。
</code></pre><h5 id="四、用法："><a href="#四、用法：" class="headerlink" title="四、用法："></a>四、用法：</h5><p>(1)、int **Ptr<br>因为是指针的指针，需要两次内存分配才能使用其最终内容。首先，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptr = ( int ** )new int *[ 5 ]；</span><br></pre></td></tr></table></figure></p>
<p>这样分配好了以后，它和(2)的意义相同了；然后要分别对 5 个指针进行内存分配，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptr[ 0 ] = new int[ 20 ];</span><br></pre></td></tr></table></figure></p>
<p>它表示为第 0 个指针分配 20 个整数，分配好以后， Ptr[ 0 ] 为指向 20 个整数的数组。这时可以使用下标用法 Ptr[ 0 ][ 0 ] 到<br>Ptr[ 0 ][ 19 ] 了。如果没有第一次内存分配，该 Ptr 是个”野”指针，是不能使用的，如果没有第二次内存分配，则 Ptr[ 0 ] 等也是个”野”指针，也是不能用的。当然，用它指向某个已经定义的地址则是允许的，那是另外的用法（类似于”借鸡生蛋”的做法），这里不作讨论（下同）。</p>
<p>(2)、int *Ptr[ 5 ]<br>这样定义的话，编译器已经为它分配了 5 个指针的空间，这相当于(1)中的第一次内存分配。根据对(1)的讨论可知，显然要对其进行一次内存分配的。否则就是”野”指针。</p>
<p>(3)、int ( *Ptr )[ 5 ]<br>这种定义我觉得很费解，不是不懂，而是觉得理解起来特别吃力，也许是我不太习惯这样的定义吧。怎么描述它呢？它的意义是”一群”指针，每个指针都是指向一个 5 个整数的数组。如果想分配 k 个指针，这样写： Ptr = ( int ( <em> )[ 5 ] ) new int[ sizeof( int ) </em> 5 * k ]。这是一次性的内存分配。分配好以后，Ptr 指向一片连续的地址空间，其中 Ptr[ 0 ] 指向第 0 个 5 个整数数组的首地址，Ptr[ 1 ] 指向第1 个 5 个整数数组的首地址。</p>
<p>综上所述，我觉得可以这样理解它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ** Ptr &lt;==&gt; int Ptr[ x ][ y ];</span><br><span class="line">int *Ptr[ 5 ] &lt;==&gt; int Ptr[ 5 ][ x ];</span><br><span class="line">int ( *Ptr )[ 5 ] &lt;==&gt; int Ptr[ x ][ 5 ];</span><br></pre></td></tr></table></figure></p>
<p>这里 x 和 y 是表示若干的意思。</p>
<h5 id="使用“指向指针的指针”来构造一个二维数组"><a href="#使用“指向指针的指针”来构造一个二维数组" class="headerlink" title="使用“指向指针的指针”来构造一个二维数组"></a>使用“指向指针的指针”来构造一个二维数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define ROW 3</span><br><span class="line">#define COLUMN 5</span><br><span class="line"></span><br><span class="line">int main(void)  </span><br><span class="line">&#123;  </span><br><span class="line">int **pp=0, i,j;</span><br><span class="line"></span><br><span class="line">pp = (int **)malloc(sizeof(int)*ROW);</span><br><span class="line"></span><br><span class="line">for (i=0; i&lt;ROW; i++)</span><br><span class="line">pp[i] = (int *)malloc(sizeof(int)*COLUMN);</span><br><span class="line"></span><br><span class="line">for (i=0; i&lt;ROW; i++)</span><br><span class="line">for (j=0; j&lt;COLUMN; j++)</span><br><span class="line">pp[i][j] = rand()%2;</span><br><span class="line"></span><br><span class="line">for (i=0; i&lt;ROW; i++)</span><br><span class="line">for (j=0; j&lt;COLUMN; j++)</span><br><span class="line">printf(&quot;pp[%d][%d]= %d\n&quot;, i,j,pp[i][j]);</span><br><span class="line"></span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通式"><a href="#通式" class="headerlink" title="通式"></a>通式</h4><p>&amp;a+n所得的新地址实际是按&amp;a+n*sizeof(a)来计算的<br>&amp;a[i]+n所得的新地址实际是按&amp;a[i]+sizeof(a[i])来计算的<br>&amp;a[i][j]+n所得的新地址实际是岸&amp;a[i][j]+sizeof(a[i][j])来计算的</p>
<p>有了它几乎不会在被这样的问题难住了<br>a[N][M]<br>首先要区分&amp;a,a,a[0]，&amp;a[0],&amp;a[0][0]的区别，才能更好的理解公式，他们的值相同，但意义相差很大<br>&amp;a是二维数组的首地址，类型为int（*)[N][M]<br>a和&amp;a[0]是数组元素a[0](二维数组本来就是数组的数组，既可以看作是一个一位数组，只不过它的元素是数组）的首地址，类型为int（*）[M]<br>a[0]和&amp;a[0][0]是一维数组a[0]中第一个元素a[0][0]的首地址，类型为int（*）</p>
<p>也就是说a=&amp;a[0],a[N]=&amp;a[N][0]<br>先把a,a[N]转化为标准的元素取地址（既&amp; ）这种表示，方便看清，以及与元素建立联系<br>也就是说一个首地址加了n,这个n是会根据这个首地址的类型而与此类型同化</p>
<h3 id="9-C-中const、volatile、mutable的用法"><a href="#9-C-中const、volatile、mutable的用法" class="headerlink" title="9.C++中const、volatile、mutable的用法"></a>9.C++中const、volatile、mutable的用法</h3><blockquote>
<p>文章：<a href="http://www.cnblogs.com/xkfz007/articles/2419540.html" target="_blank" rel="noopener">C++中const、volatile、mutable的用法</a></p>
</blockquote>
<h4 id="const修饰普通变量和指针"><a href="#const修饰普通变量和指针" class="headerlink" title="const修饰普通变量和指针"></a>const修饰普通变量和指针</h4><p><strong>const修饰变量</strong>，一般有两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const TYPE value;</span><br><span class="line">TYPE const value;</span><br></pre></td></tr></table></figure>
<p>这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value值不可变。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int nValue；    //nValue是const</span><br><span class="line">int const nValue；    //nValue是const</span><br></pre></td></tr></table></figure>
<p>但是对于指针类型的TYPE，不同的写法会有不同情况：<br><strong>指针本身是常量不可变</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(char*) const pContent;</span><br></pre></td></tr></table></figure>
<p><strong>指针所指向的内容是常量不可变</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const (char) *pContent;</span><br><span class="line">(char) const *pContent;</span><br></pre></td></tr></table></figure>
<p><strong>两者都不可变</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* const pContent;</span><br></pre></td></tr></table></figure>
<p>识别const到底是修饰指针还是指针所指的对象，还有一个较为简便的方法，也就是沿着<em>号划一条线：<br>如果const位于</em>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br>如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。</p>
<p><strong>const修饰函数参数</strong><br>const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)：</p>
<ul>
<li>void function(const int Var);     //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)</li>
<li>void function(const char* Var);   //参数指针所指内容为常量不可变</li>
<li>void function(char* const Var);   //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的)</li>
<li>void function(const Class&amp; Var); //引用参数在函数内不可以改变，同第二点</li>
</ul>
<p>参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。</p>
<p><strong>const修饰类对象/对象指针/对象引用</strong><br>const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。<br>const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class AAA</span><br><span class="line">&#123;</span><br><span class="line">   void func1();</span><br><span class="line">   void func2() const;</span><br><span class="line">&#125;</span><br><span class="line">const AAA aObj;</span><br><span class="line">aObj.func1(); 错误</span><br><span class="line">aObj.func2(); 正确</span><br><span class="line"></span><br><span class="line">const AAA* aObj = new AAA();</span><br><span class="line">aObj-&gt;func1(); 错误</span><br><span class="line">aObj-&gt;func2(); 正确</span><br></pre></td></tr></table></figure>
<p><strong>const修饰数据成员</strong><br>const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    const int size = 100; //错误</span><br><span class="line">    int array[size];       //错误，未知的size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>const数据成员的初始化只能在类的构造函数的初始化列表中进行</strong>。要想建立在整个类中都恒定的常量，可以用类中的枚举常量来实现，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">　　enum &#123;size1=100, size2 = 200 &#125;;</span><br><span class="line">　　int array1[size1];</span><br><span class="line">　　int array2[size2];</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。</p>
<p><strong>const修饰成员函数</strong><br>const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。一般把const写在成员函数的最后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">   …</span><br><span class="line">   void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>const修饰成员函数的返回值</strong><br>１.一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回const对象，或返回const对象的引用，则返回值具有const属性，返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。</p>
<p>2.如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针所指的内容）不能被修改，该返回值只能被赋给加const 修饰的同类型指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * GetString(void);</span><br></pre></td></tr></table></figure>
<p>如下语句将出现编译错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *str=GetString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *str=GetString();</span><br></pre></td></tr></table></figure>
<p>3.函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;…</span><br><span class="line">    A &amp;operate= (const A &amp;other); //赋值函数</span><br><span class="line">&#125;</span><br><span class="line">A a,b,c; //a,b,c为A的对象</span><br><span class="line">…</span><br><span class="line">a=b=c;   //正常</span><br><span class="line">(a=B)=c; //不正常，但是合法</span><br></pre></td></tr></table></figure>
<p>若赋值函数的返回值加const修饰，那么该返回值的内容不允许修改，上例中a=b=c依然正确。(a=b)=c就不正确了。<br><strong>const常量与define宏定义的区别</strong><br><strong>编译器处理方式不同</strong><br>define宏是在预处理阶段展开。<br>const常量是编译运行阶段使用。<br><strong>类型和安全检查不同</strong><br>define宏没有类型，不做任何类型检查，仅仅是展开。<br>const常量有具体的类型，在编译阶段会执行类型检查。<br><strong>存储方式不同</strong><br>define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。<br>const常量会在内存中分配(可以是堆中也可以是栈中)。</p>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile的本意是“易变的”,volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被寄存。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volatile int i=10;</span><br><span class="line">int a = i;</span><br><span class="line">。。。//其他代码，并未明确告诉编译器，对i进行过操作</span><br><span class="line">int b = i;</span><br></pre></td></tr></table></figure>
<p>volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，<strong>所以说volatile可以保证对特殊地址的稳定访问</strong>。<br>注意，在vc6中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无volatile关键字，对程序最终代码的影响。首先用classwizard建一个win32 console工程，插入一个voltest.cpp文件，输入下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int i=10;</span><br><span class="line">int a = i;</span><br><span class="line">printf(&quot;i= %d/n&quot;,a);</span><br><span class="line">//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道</span><br><span class="line">__asm &#123;</span><br><span class="line"> mov dword ptr [ebp-4], 20h</span><br><span class="line">&#125;</span><br><span class="line">int b = i;</span><br><span class="line">printf(&quot;i= %d/n&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在调试版本模式运行程序，输出结果如下：<br>i = 10<br>i = 32<br>然后，在release版本模式运行程序，输出结果如下：<br>i = 10<br>i = 10<br>输出的结果明显表明，release模式下，编译器对代码进行了优化，第二次没有输出正确的i值。下面，我们把 i的声明加上volatile关键字，看看有什么变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">volatile int i=10;</span><br><span class="line">int a = i;</span><br><span class="line">printf(&quot;i= %d/n&quot;,a);</span><br><span class="line">__asm &#123;</span><br><span class="line"> mov dword ptr [ebp-4], 20h</span><br><span class="line">&#125;</span><br><span class="line">int b = i;</span><br><span class="line">printf(&quot;i= %d/n&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别在调试版本和release版本运行程序，输出都是：<br>i = 10<br>i = 32<br>这说明这个关键字发挥了它的作用！<br><strong>关于volatile的补充信息：</strong><br>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li>
<li>多线程应用中被几个任务共享的变量</li>
</ol>
<p>我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile的重要性：</p>
<ol>
<li>一个参数既可以是const还可以是volatile吗？解释为什么。</li>
<li>一个指针可以是volatile 吗？解释为什么。</li>
<li>下面的函数有什么错误：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是答案：</p>
<ol>
<li>是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 一个值可以同时是vonst和volatile。例如，硬件时钟一般设定为不能由程序改变，这一点使他成为const； 但它被程序以外的代理改变，这使它成为volatile的</li>
<li>是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</li>
<li>这段代码的有个恶作剧。这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    b = *ptr;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    return a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a>mutable关键字</h4><p>mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。</p>
<p>我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。下面是一个小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClxTest</span><br><span class="line">&#123;</span><br><span class="line">　public:</span><br><span class="line">　　void Output() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ClxTest::Output() const</span><br><span class="line">&#123;</span><br><span class="line">　cout &lt;&lt; &quot;Output for test!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputTest(const ClxTest&amp; lx)</span><br><span class="line">&#123;</span><br><span class="line">　lx.Output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类ClxTest的成员函数Output是用来输出的，不会修改类的状态，所以被声明为const。</p>
<p>函数OutputTest也是用来输出的，里面调用了对象lx的Output输出方法，为了防止在函数中调用成员函数修改任何成员变量，所以参数也被const修饰。</p>
<p>假如现在，我们要增添一个功能：计算每个对象的输出次数。假如用来计数的变量是普通的变量的话，那么在const成员函数Output里面是不能修改该变量的值的；而该变量跟对象的状态无关，所以应该为了修改该变量而去掉Output的const属性。这个时候，就该我们的mutable出场了，只要用mutalbe来修饰这个变量，所有问题就迎刃而解了。下面是修改过的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ClxTest::ClxTest()</span><br><span class="line">&#123;</span><br><span class="line">	m_iTimes = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClxTest::~ClxTest()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">void ClxTest::Output() const</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;Output for test!&quot; &lt;&lt; endl;</span><br><span class="line">	m_iTimes++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ClxTest::GetOutputTimes() const</span><br><span class="line">&#123;</span><br><span class="line">	return m_iTimes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OutputTest(const ClxTest&amp; lx)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; lx.GetOutputTimes() &lt;&lt; endl;</span><br><span class="line">	lx.Output();</span><br><span class="line">	cout &lt;&lt; lx.GetOutputTimes() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数器m_iTimes被mutable修饰，那么它就可以突破const的限制，在被const修饰的函数里面也能被修改。</p>
<h3 id="关于Windows动态链接库基础知识"><a href="#关于Windows动态链接库基础知识" class="headerlink" title="关于Windows动态链接库基础知识"></a>关于Windows动态链接库基础知识</h3><blockquote>
<p>文章：<a href="http://blog.163.com/bingcaihuang@126/blog/static/198942122010103001327896/" target="_blank" rel="noopener">关于Windows动态链接库基础知识</a></p>
</blockquote>
<p>如我们所知，Windows程序都是一些可执行文件，它们可以创建并显示一个或多个窗体，使用消息循环来接收用户的输入。但是动态链接库并不能直接被执行，它们一般也不会接收消息。它们只是一些包含着函数的独立文件，这些函数可以被Windows程序或者其它DLL调用以完成某项任务。</p>
<p>　　“动态链接”是指Windows程序在运行时才把自己需要存在于某个库中的函数链接进来。“静态链接”是指Windows程序在编译阶段就把各种对象模块（.OBJ）、运行时库（.LIB）和资源文件（.RES）链接到一起以创建一个可执行文件（.EXE）。<br>　　<br>　　DERNAL32.DLL，USER32.DLL，GDI32.DLL，各种驱动程序如KEYBOARD.DRV，SYSTEM.DRV和MOUSE.DRV，显卡和打印机驱动程序等都是动态链接库。这些库可以被所有的Windows程序共同使用。<br>有某些动态链接库（如字体文件）称为“resource-only”。它们只包括数据，而不包括代码。因此，动态链接库的目的之一就是为许多不同的程序提供函数和资源。在传统的操作系统里，用户程序在运行时只能调用操作系统自身的某些函数。而在Windows操作系统下，模块或程序调用另一个模块中的函数来执行是一种非常普遍的操作。因此，从某种角度看，对DLL进行编程，其实是在对Windows操作系统作扩展，也可以看作是在对用户程序作扩展。</p>
<p>　　动态链接库模块可以有其它的扩展名，但是标准的扩展名是.DLL。只有具有标准扩展句的动态链接库模块才可以被Windows自动加载。而如果是其它扩展名的动态链接库模块，程序必须使用LoadLibrary或者LoadLibraryEx函数来显示加载。<br>　　<br>　　我们可以发现，在大型的应用软件中，会常常使用到动态链接库技术。举个例子，假如我们要写一个大型的应用软件，其中包括了多个程序。我们可以发现很多程序可能都会使用到一些同样的通用的函数。我们可以把这些通用的函数放到某个目标库文件中（.LIB），然后在链接是把它加到每个程序中进行静态链接。但是这是一种非常浪费的方法，因为每个程序模块中都会包括这些通用函数的独立拷贝。另外，如果我们要改变库文件中的某个函数，就必须把所有使用到这个函数的程序都重新编译一遍。但是，如果我们使用动态链接库的技术，把所有这些通用函数都放到一个动态链接库文件当中，我们就可以解决以上提到的各种问题。首先，动态链接库在硬盘上只保留一个拷贝，程序只是在运行时才会调用其中使用到的函数，这样我们就可以节省大量的程序存储和运行空间。其次，如果要修改某个通用函数时，只要调用接口没有改变，只是改变它的实现方法，那么我们就不必对每个用到它的程序都进行重新编译，而只要把动态链接库模块重新编译一遍就可以了。<br>　　<br>　　动态链接库模块也可以作为一个单独的产品来发布。这样程序开发人员就可以使用第三方的模块来开发自己的应用程序，提高了程序的复用程序，也节省了大量的时间和精力。<br>　　<br>　　在很多时候时候，我们都会用到“库”（Library）这个词，除了动态链接库（Dynamic-Link   Libraries）之外，还有目标库（Object   Libraries）和导入库（Import   Libraries）。下面，我们分别了解一下这三种库的异同点。<br>　　<br>　　目标库是扩展名为.LIB的文件，包括了用户程序要用到的各种函数。它在用户程序进行链接时，“静态链接”到可执行程序文件当中。例如，在VC++中最常使用到的C运行时目标库文件就是LIBC.LIB。<br>　　<br>　　导入库是一种特殊形式的目标库文件形式。和目标库文件一样，导入库文件的扩展名也是.LIB，也是在用户程序被链接时，被“静态链接”到可执行文件当中。但是不同的是，导入库文件中并不包含有程序代码。相应的，它包含了相关的链接信息，帮助应用程序在可执行文件中建立起正确的对应于动态链接库的重定向表。比如KERNEL32.LIB、USER32.LIB和GDI32.LIB就是我们常用到的导入库，通过它们，我们就可以调用Windows提供的函数了。如果我们在程序中使用到了Rectangle这个函数，GDI32.LIB就可以告诉链接器，这个函数在GDI32.DLL动态链接库文件中。这样，当用户程序运行时，它就知道“动态链接”到GDI32.DLL模块中以使用这个函数。<br>　　<br>　　目标库和导入库都是在程序开发过程中才使用到的，而动态链接库是在程序运行时才使用的。在程序运行时，相应的动态链接库文件必须已经保存在硬盘上了。另外，如果要使用动态链接库文件，该文件必须要保存在同.EXE文件同一个目录下，或者保存在当前目录、Windows系统目录、Windows目录或环境变量中PATH参数指定的目录下。程序也是按照这个顺序来搜寻它需要的动态链接库文件的。</p>
<h3 id="va-start、va-arg、va-end在参数可变函数中的使用"><a href="#va-start、va-arg、va-end在参数可变函数中的使用" class="headerlink" title="va_start、va_arg、va_end在参数可变函数中的使用"></a>va_start、va_arg、va_end在参数可变函数中的使用</h3><blockquote>
<p>文章：<a href="https://lzw.me/a/va-start-va-arg-va-end.html" target="_blank" rel="noopener">va_start、va_arg、va_end在参数可变函数中的使用</a></p>
</blockquote>
<p>当无法列出传递函数的所有实参的类型和数目时，可用省略号指定参数表，在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。</p>
<p><strong>C语言可变参数函数及三个宏va_start、va_arg和va_end的使用</strong><br>一、可变参数函数的实例</p>
<p>大家熟知的printf()函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  printf(const char * format, …);</span><br></pre></td></tr></table></figure>
<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是<br>可变的,例如我们可以有以下不同的调用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;,i);</span><br><span class="line">printf(&quot;%s&quot;,s);</span><br><span class="line">printf(&quot;the number is %d ,string is:%s&quot;, i, s);</span><br></pre></td></tr></table></figure>
<p>二、如何编写一个自已的可变参数函数</p>
<p>查了一下，在&lt;stdarg.h&gt;中定义了三个宏va_start()、va_arg()和va_end()用于实现可变参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void va_start( va_list arg_ptr, prev_param );</span><br><span class="line">type va_arg( va_list arg_ptr, type );</span><br><span class="line">void va_end( va_list arg_ptr );</span><br></pre></td></tr></table></figure>
<p>试编一个示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdarg.h&gt;  </span><br><span class="line">#define ENDING_INT 0  </span><br><span class="line"></span><br><span class="line">int SumAll(int number1,…)  //把参数加总  </span><br><span class="line">&#123;  </span><br><span class="line">    va_list arg_pointer; //首先定义一个va_list型的变量,这个变量是指向参数的指针.  </span><br><span class="line"></span><br><span class="line">    int current_number;  //当前的数字  </span><br><span class="line">    int total;           //数字之和  </span><br><span class="line"></span><br><span class="line">    //用va_start初始化变量arg_pointer,这个宏的第二个参数是第一个可变参数(一个固定的参数)  </span><br><span class="line">    va_start(arg_pointer,number1);  </span><br><span class="line">    total=number1;  </span><br><span class="line"></span><br><span class="line">    do  </span><br><span class="line">      &#123;  </span><br><span class="line">        //用va_arg返回后续的可变参数, 类型是 int  </span><br><span class="line">        current_number=va_arg(arg_pointer,int);  </span><br><span class="line">        total += current_number;  </span><br><span class="line">      &#125;  </span><br><span class="line">    while (current_number!=ENDING_INT);   //如果参数是结束标识(这里是ENDING_INT)，则结束  </span><br><span class="line">    va_end(arg_pointer); //结束参数列表  </span><br><span class="line"></span><br><span class="line">    return total;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">   int n;  </span><br><span class="line"></span><br><span class="line">   n=SumAll(100,200,ENDING_INT);   //返回结果是300  </span><br><span class="line">   printf(&quot;%d /n&quot;,n);  </span><br><span class="line"></span><br><span class="line">   n=SumAll(100,200);  //由于没有结束标识，返回结果不确定  </span><br><span class="line">   printf(&quot;%d /n&quot;,n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为va_start, va_arg, va_end等定义成宏,所以可变参数的类型和个数需要由程序代码控制。<br>一般来说，设一个结束标识，这里是 ENDING_INT。用它来识别不同参数的个数。</p>
<p>  SumAll(100,200,ENDING_INT);   //调用方式正确，返回结果是300</p>
<p>  SumAll(100,200);  //调用方式不正确，由于没有结束标识，返回结果不确定。</p>
<p>三、理解va_start、va_arg和va_end</p>
<p>看一下&lt;stdarg.h&gt;中宏的定义：</p>
<p>定义：typedef char * va_list;<br>理解：va_list 就是一个指针，指向参数列表。</p>
<p>定义：#define _INTSIZEOF(n)   ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) – 1) )<br>定义：#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )<br>理解：va_start 宏, 就是把ap赋值为参数v起始的参数列表的下一个参数</p>
<p>定义：#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )<br>理解：va_arg宏，就是把ap赋值为下一个参数</p>
<p>定义：#define va_end(ap) ( ap = (va_list)0 )<br>理解：va_end宏，就是把ap赋值为空(0)</p>
<p>从va_<em>的实现可以看出，充分运用指针，把C语言的灵活特性表现得淋漓尽致。当然，用不好也容易出错。<br>va_</em>中，为了得到所有传递给函数的参数，需要用va_arg依次遍历。但是有两个要求:</p>
<p><strong>(1)要确定参数的类型。</strong><br>    一般来说，各个参数的类型是一样的。</p>
<p><strong>(2)要有结束标志。</strong><br>如果没有结束标志，va将按默认类型依次返回内存中的内容，直到访问到非法内存而出错退出。</p>
<p>所以上述的调用 SumAll(100,200);  返回的结果是不确定的。</p>
<p>四、再写一个参数类型是 char * 的 可变参数函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;alloc.h&gt;  </span><br><span class="line">#include &lt;stdarg.h&gt;  </span><br><span class="line"></span><br><span class="line">#define ENDING_STRING NULL  </span><br><span class="line"></span><br><span class="line">//把多个字符串连接起来  </span><br><span class="line">char *StrCat(char *src,…)  </span><br><span class="line">&#123;  </span><br><span class="line">    va_list     va;  </span><br><span class="line">    const char  *src_pointer;  </span><br><span class="line">    char        *dest;         /*  结果字符串 */  </span><br><span class="line">    size_t       dest_size;     /*  结果字符串的大小*/  </span><br><span class="line"></span><br><span class="line">    /* 计算字符串的大小 */  </span><br><span class="line">    va_start (va, src);             /*  开始变长参数处理 */  </span><br><span class="line">    src_pointer   = src;  </span><br><span class="line">    dest_size = 1;  </span><br><span class="line">    while (src_pointer!=ENDING_STRING)  /* ENDING_STRING == NULL */  </span><br><span class="line">      &#123;  </span><br><span class="line">        dest_size += strlen (src_pointer);  </span><br><span class="line">        src_pointer = va_arg (va, char *);  /* 取下一个参数 */  </span><br><span class="line">      &#125;  </span><br><span class="line">    va_end (va);                    /*  结束变长参数处理  */  </span><br><span class="line"></span><br><span class="line">    /*  申请内存 */  </span><br><span class="line">    dest = malloc( dest_size );  </span><br><span class="line">    if (dest == NULL) return (NULL);  </span><br><span class="line"></span><br><span class="line">    /*  逐个复制字串到结果字符串  */  </span><br><span class="line">    va_start (va, src);       /*  开始变长参数处理 */  </span><br><span class="line">    src_pointer  = src;  </span><br><span class="line">    dest [0] = &apos;/0&apos;;         /* 先设置为空串 */  </span><br><span class="line">    while (src_pointer!=ENDING_STRING)   /* ENDING_STRING == NULL */  </span><br><span class="line">      &#123;  </span><br><span class="line">        strcat (dest, src_pointer);      /*  复制字串到结果字符串  */  </span><br><span class="line">        src_pointer = va_arg (va, char *);  </span><br><span class="line">      &#125;  </span><br><span class="line">    va_end (va);                      /*  结束变长参数处理  */  </span><br><span class="line">    return (dest);  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">   int n;  </span><br><span class="line">   char *s;  </span><br><span class="line"></span><br><span class="line">   s=StrCat(&quot;hello&quot;,&quot; &quot;,&quot;world&quot;,NULL);  </span><br><span class="line">   printf(&quot;%s /n&quot;,s);   //返回结果是 hello world  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，还是比较好用的，千万不要忘记: 调用时要加上结束标识符哦。</p>
<p>  可能要问，为什么 printf() 函数调用时没有结束标识符呢？</p>
<p>  了解了一下 printf()的源码，我是这样理解的：<br>    printf(char *format,…) 中，在format参数中，就可以判断出后续参数的个数和类型，因此不需要结束标识符就可以知道参数的个数了。比如：<br>   printf( “%s %d”, “hello”, 1);<br>   “%s %d”表明后续参数个数为2个，第一个是 string类型，第二个是 int 类型。</p>
<p> 试一下，如果写成这样<br>  printf( “%s %d %d”, “hello”, 1);</p>
<p> “%s %d %d”表明后续参数个数为3个，实际上是两个，由于缺了一个，返回结果是不可确定的</p>
<p><strong>C/C++ 函数参数 省略号（变参技术，va_start,va_arg,va_end用法）</strong></p>
<p>先看如下的一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdarg.h&gt; // 必须包含的头文件  </span><br><span class="line"></span><br><span class="line">int Add(int start,…) // …是作为占位符  </span><br><span class="line">&#123;  </span><br><span class="line">va_list arg_ptr; // 定义变参起始指针  </span><br><span class="line">int sum=0; // 定义变参的和  </span><br><span class="line">int nArgValue =start; //  </span><br><span class="line"></span><br><span class="line">va_start(arg_ptr,start); // arg_ptr指向第一个变参  </span><br><span class="line">do  </span><br><span class="line">&#123;  </span><br><span class="line">sum+=nArgValue; // 求和  </span><br><span class="line">nArgValue = va_arg(arg_ptr,int); // arg_ptr指向下一个变参  </span><br><span class="line">&#125;  </span><br><span class="line">while(nArgValue != 0); // 判断结束条件；结束条件是自定义为=0时结束  </span><br><span class="line"></span><br><span class="line">va_end(arg_ptr); // 复位指针  </span><br><span class="line">return sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的调用方法为Add(1,2,3,0);这样，必须以0结尾，因为变参函数结束的判断条件就是读到0停止。</p>
<p>解释：</p>
<p>所使用到的宏：</p>
<p>void va_start( va_list arg_ptr, prev_param );<br>type va_arg( va_list arg_ptr, type );<br>void va_end( va_list arg_ptr );</p>
<p>typedef char <em> va_list;<br>#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) – 1) &amp; ~(sizeof(int) – 1) )<br>#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )<br>#define va_arg(ap,t) ( \</em>(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )<br>#define va_end(ap) ( ap = (va_list)0 )</p>
<p>1、首先把va_list被定义成char<em>，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void</em>的</p>
<p>2、定义_INTSIZEOF(n)主要是为了某些需要内存的对齐的系统.这个宏的目的是为了得到最后一个固定参数的实际内存大小。在我的机器上直接用sizeof运算符来代替，对程序的运行结构也没有影响。（后文将看到我自己的实现）。</p>
<p>3、va_start的定义为 &amp;v+_INTSIZEOF(v) ,这里&amp;v是最后一个固定参数的起始地址，再加上其实际占用大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址,有了这个地址，以后的事情就简单了。</p>
<p>这里要知道两个事情：</p>
<p>⑴在intel+windows的机器上，函数栈的方向是向下的，栈顶指针的内存地址低于栈底指针，所以先进栈的数据是存放在内存的高地址处。</p>
<p>(2)在VC等绝大多数C编译器中，默认情况下，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：最后一个固定参数的地址位于第一个可变参数之下，并且是连续存储的。</p>
<p>|————————–|<br>| 最后一个可变参数 | -&gt;高内存地址处<br>|————————–|<br>|————————–|<br>| 第N个可变参数 | -&gt;va_arg(arg_ptr,int)后arg_ptr所指的地方,<br>| | 即第N个可变参数的地址。<br>|————— |<br>|————————–|<br>| 第一个可变参数 | -&gt;va_start(arg_ptr,start)后arg_ptr所指的地方<br>| | 即第一个可变参数的地址<br>|————— |<br>|———————— –|<br>| |<br>| 最后一个固定参数 | -&gt; start的起始地址<br>|————– -| ……………..<br>|————————– |<br>| |<br>|————— | -&gt; 低内存地址处</p>
<p>(3) va_arg():有了va_start的良好基础，我们取得了第一个可变参数的地址，在va_arg()里的任务就是根据指定的参数类型取得本参数的值，并且把指针调到下一个参数的起始地址。<br>因此，现在再来看va_arg()的实现就应该心中有数了：<br>#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )<br>这个宏做了两个事情，<br>①用用户输入的类型名对参数地址进行强制类型转换，得到用户所需要的值<br>②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。</p>
<p>(4)va_end宏的解释：x86平台定义为ap=(char<em>)0;使ap不再 指向堆栈,而是跟NULL一样.有些直接定义为((void</em>)0),这样编译器不会为va_end产生代码,例如gcc在linux的x86平台就是这样定义的. 在这里大家要注意一个问题:由于参数的地址用于va_start宏,所以参数不能声明为寄存器变量或作为函数或数组类型. 关于va_start, va_arg, va_end的描述就是这些了,我们要注意的 是不同的操作系统和硬件平台的定义有些不同,但原理却是相似的.</p>
<h3 id="全局变量的理解"><a href="#全局变量的理解" class="headerlink" title="全局变量的理解"></a>全局变量的理解</h3><ol>
<li><p>使用全局变量会占用更多的内存（因为其生命期长），不过在计算机配置很高的今天，这个不成为什么问题，除非使用的是巨大对象的全局变量，能避免就一定要避免。</p>
</li>
<li><p>使用全局变量程序运行时速度更快一些（因为内存不需要再分配），同样现在也快不了多少。</p>
</li>
<li><p>对于局部变量的名字空间污染，这个在不使用太多变量时是可以避免的。</p>
</li>
</ol>
<p>总之，全局变量可以使用，但是全局变量使用时应注意的是尽可能使期名字易于理解，而且不能太短，避免名字空间的污染；避免使用巨大对象的全局变量。<br>局部变量：在程序中，只在特定的过程或函数中可以访问的变量，是相对与全局变量而言的。<br>全局变量也称为外部变量，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。全局变量全部存放在静态存储区，在程序开始执行时给全局变量分配存储区，程序行完毕就释放。<br>局部变量可以和全局变量重名，但是局部变量会屏蔽全局变量。在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。</p>
<h3 id="pragma-once与-ifndef的区别"><a href="#pragma-once与-ifndef的区别" class="headerlink" title="#pragma once与 #ifndef的区别"></a>#pragma once与 #ifndef的区别</h3><blockquote>
<p>文章：<a href="http://www.cppblog.com/szhoftuncun/archive/2007/10/28/35356.html" target="_blank" rel="noopener">#pragma once与 #ifndef的区别</a></p>
</blockquote>
<p>为了避免同一个文件被include多次</p>
<ol>
<li>#ifndef方式</li>
<li>#pragma once方式</li>
</ol>
<p>在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。<br>方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __SOMEFILE_H__</span><br><span class="line">#define __SOMEFILE_H__</span><br><span class="line">... ... // 一些声明语句</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">... ... // 一些声明语句</span><br></pre></td></tr></table></figure>
<p>#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p>
<p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。</p>
<p>方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p>
<h3 id="C-中参数传递方式讨论"><a href="#C-中参数传递方式讨论" class="headerlink" title="C++中参数传递方式讨论"></a>C++中参数传递方式讨论</h3><blockquote>
<p>文章：<a href="http://blog.csdn.net/barryxt/article/details/4382196" target="_blank" rel="noopener">C++中参数传递方式讨论</a></p>
</blockquote>
<p>众所周知，在C＋＋中调用函数时有三种参数传递方式：<br>（1）传值调用；<br>（2）传址调用（传指针）；<br>（3）引用传递；</p>
<p>实际上，还有一种参数传递方式，就是全局变量传递方式。这里的“全局”变量并不见得就是真正的全局的，所有代码都可以直接访问的，只要这个变量的作用域足够这两个函数访问就可以了，比如一个类中的两个成员函数可以使用一个成员变量实现参数传递，或者使用static关键字定义，或者使用namespace进行限制等，而这里的成员变量在这种意义上就可以称作是“全局”变量（暂时还没有其它比“全局”更好的词来描述）。当然，可以使用一个类外的真正的全局变量来实现参数传递，但有时并没有必要，从工程上讲，作用域越小越好。这种方式有什么优点呢？<br>效率高！</p>
<p>的确，这种效率是所有参数传递方式中效率最高的，比前面三种方式都要高，无论在什么情况下。但这种方式有一个致命的弱点，那就是对多线程的支持不好，如果两个进程同时调用同一个函数，而通过全局变量进行传递参数，该函数就不能够总是得到想要的结果。<br>下面再分别讨论上面三种函数传递方式。</p>
<p>1.从功能上。按值传递在传递的时候，实参被复制了一份，然后在函数体内使用，函数体内修改参数变量时修改的是实参的一份拷贝，而实参本身是没有改变的，所以如果想在调用的函数中修改实参的值，使用值传递是不能达到目的的，这时只能使用引用或指针传递。例如，要实现两个数值交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap(int a, int b);</span><br><span class="line">void main()&#123;</span><br><span class="line">    int a=1, b=2;</span><br><span class="line">    swap(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在main()函数中的a,b值实际上并没有交换，如果想要交换只能使用指针传递或引用传递，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void swap(int* pa, int* pb);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void swap(int&amp; ra, int&amp; rb);</span><br></pre></td></tr></table></figure>
<p>2.从传递效率上。这里所说传递效率，是说调用被调函数的代码将实参传递到被调函数体内的过程，正如上面代码中，这个过程就是函数main()中的a,b传递到函数swap()中的过程。这个效率不能一概而论。对于内建的int, char,  short,long,float等4字节或以下的数据类型而言，实际上传递时也只需要传递1－4个字节，而使用指针传递时在32位CPU中传递的是32位的指针，4个字节，都是一条指令，这种情况下值传递和指针传递的效率是一样的，而传递double, long long等8字节的数据时，在32位CPU中，其传值效率比传递指针要慢，因为8个字节需要2次取完。而在64位的CPU上，传值和传址的效率是一样的。再说引用传递，这个要看编译器具体实现，引用传递最显然的实现方式是使用指针，这种情况下与指针的效率是一样的，而有些情况下编译器是可以优化的，采用直接寻址的方式，这种情况下，效率比传值调用和传址调用都要快，与上面说的采用全局变量方式传递的效率相当。<br>再说自定义的数据类型，class, struct定义的数据类型。这些数据类型在进行传值调用时生成临时对象会执行构造函数，而且当临时对象销毁时会执行析构函数，如果构造函数和析构函数执行的任务比较多，或者传递的对象尺寸比较大，那么传值调用的消耗就比较大。这种情况下，采用传址调用和采用传引用调用的效率大多数下相当，正如上面所说，某些情况下引用传递可能被优化，总体效率稍高于传址调用。</p>
<p>3.从执行效率上讲。这里所说的执行效率，是指在被调用的函数体内执行时的效率。因为传值调用时，当值被传到函数体内，临时对象生成以后，所有的执行任务都是通过直接寻址的方式执行的，而指针和大多数情况下的引用则是以间接寻址的方式执行的，所以实际的执行效率会比传值调用要低。如果函数体内对参数传过来的变量进行操作比较频繁，执行总次数又多的情况下，传址调用和大多数情况下的引用参数传递会造成比较明显的执行效率损失。<br>综合2、3两种情况，具体的执行效率要结合实际情况，通过比较传递过程的资源消耗和执行函数体消耗之和来选择哪种情况比较合适。而就引用传递和指针传递的效率上比，引用传递的效率始终不低于指针传递，所以从这种意义上讲，在C＋＋中进行参数传递时优先使用引用传递而不是指针。</p>
<p>4.从类型安全上讲。值传递与引用传递在参数传递过程中都执行强类型检查，而指针传递的类型检查较弱，特别地，如果参数被声明为 void* ，那么它基本上没有类型检查，只要是指针，编译器就认为是合法的，所以这给BUG的产生制造了机会，使程序的健壮性稍差，如果没有必要，就使用值传递和引用传递，最好不用指针传递，更好地利用编译器的类型检查，使得我们有更少的出错机会，以增加代码的健壮性。<br>这里有个特殊情况，就是对于多态的情况，如果形参是父类，而实参是子类，在进行值传递的时候，临时对象构造时只会构造父类的部分，是一个纯粹的父类对象，而不会构造子类的任何特有的部分，因为办有虚的析构函数，而没有虚的构造函数，这一点是要注意的。如果想在被调函数中通过调用虚函数获得一些子类特有的行为，这是不能实现的。</p>
<p>5.从参数检查上讲。一个健壮的函数，总会对传递来的参数进行参数检查，保证输入数据的合法性，以防止对数据的破坏并且更好地控制程序按期望的方向运行，在这种情况下使用值传递比使用指针传递要安全得多，因为你不可能传一个不存在的值给值参数或引用参数，而使用指针就可能，很可能传来的是一个非法的地址（没有初始化，指向已经delete掉的对象的指针等）。所以使用值传递和引用传递会使你的代码更健壮，具体是使用引用还是使用，最简单的一个原则就是看传递的是不是内建的数据类型，对内建的数据类型优先使用值传递，而对于自定义的数据类型，特别是传递较大的对象，那么请使用引用传递。</p>
<p>6.从灵活性上。无疑，指针是最灵活的，因为指针除了可以像值传递和引用传递那样传递一个特定类型的对象外，还可以传递空指针，不传递任何对象。指针的这种优点使它大有用武之地，比如标准库里的time( )函数，你可以传递一个指针给它，把时间值填到指定的地址，你也可以传递一个空指针而只要返回值。<br>综合以上几种传递方式，列表如下，方便不同情况下选择合适的传递方式。我们将各种指标分高、中、低三个级，别处于同一级别的两种方式，表示这两种方式是等效的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">传递方式</th>
<th style="text-align:center">功能</th>
<th style="text-align:left">传递效率(内嵌/自定义)</th>
<th style="text-align:left">执行效率</th>
<th style="text-align:left">类型安全</th>
<th style="text-align:left">参数检查</th>
<th style="text-align:left">灵活性</th>
<th style="text-align:left">多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">全局变量</td>
<td style="text-align:center">高</td>
<td style="text-align:left">高 / 高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">低</td>
<td style="text-align:left">低</td>
</tr>
<tr>
<td style="text-align:left">值</td>
<td style="text-align:center">低</td>
<td style="text-align:left">高 / 低</td>
<td style="text-align:left">高</td>
<td style="text-align:left">中</td>
<td style="text-align:left">高</td>
<td style="text-align:left">中</td>
<td style="text-align:left">高</td>
</tr>
<tr>
<td style="text-align:left">指针</td>
<td style="text-align:center">高</td>
<td style="text-align:left">低 / 中</td>
<td style="text-align:left">低</td>
<td style="text-align:left">低</td>
<td style="text-align:left">低</td>
<td style="text-align:left">高</td>
<td style="text-align:left">中</td>
</tr>
<tr>
<td style="text-align:left">引用</td>
<td style="text-align:center">高</td>
<td style="text-align:left">中 / 高</td>
<td style="text-align:left">中</td>
<td style="text-align:left">高</td>
<td style="text-align:left">高</td>
<td style="text-align:left">中</td>
<td style="text-align:left">中</td>
</tr>
</tbody>
</table>
<p>以上讨论了四种参数传递方式的优缺点，下面再讨论一下在参数传递过程中一些共同的有用的技术。<br>1.const关键字。当你的参数是作为输入参数时，你总不希望你的输入参数被修改，否则有可能产生逻辑错误，这时可以在声明函数时在参数前加上const关键字，防止在实现时意外修改函数输入，对于使用你的代码的程序员也可以告诉他们这个参数是输入，而不加const关键字的参数也可能是输出。例如strlen，你可以这样声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strlen(char* str);</span><br></pre></td></tr></table></figure>
<p>功能上肯定没有什么问题，但是你想告诉使用该函数的人，参数str是一个输入参数，它指向的数据是不能被修改的，这也是他们期望的，总不会有人希望在请人给他数钱的时候，里面有张100的变成10块的了，或者真钞变成假钞了，他们希望有一个保证，说该函数不会破坏你的任何数据，声明按如下方式便可让他们放心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strlen(const char* str);</span><br></pre></td></tr></table></figure>
<p>可不可以给str本身也加一个限制呢，如果把地址改了数得的结果不就错了吗？总得给人点儿自由吧，只要它帮你数钱就行了，何必介意他怎么数呢？只要不破坏你的钱就OK了，如果给str一个限制，就会出现问题了，按照上面的声明，可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int strlen(const char* str)</span><br><span class="line">&#123;</span><br><span class="line">	int cnt;</span><br><span class="line">	if (!str) return 0;</span><br><span class="line">	cnt = 0;</span><br><span class="line">	while (*(str++)) &#123;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可是，如果你硬要把声明改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strlen(const char* const str);</span><br></pre></td></tr></table></figure>
<p>上面的函数肯定就运行不了了，只能改用其它的实现方式，但这个不是太有必要。只要我们保护好我们的钱就行了，如果它数不对，下次我次不让它数，再换个人就是了。<br>对于成员函数，如果我们要显示给客户代码说某个成员函数不会修改该对象的值，只会读取某些内容，也可以在该函数声明中加一个const.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clas Person</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">    unsigned char Age( void ) const;  // 看到const就放心了，这个函数肯定不会修改m_age</span><br><span class="line">  private:</span><br><span class="line">    unsigned char m_age;   // 我认为这个类型已经足够长了，如果觉得不改可以改为unsigned long</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.默认值。个人认为给参数添加一个默认值是一个很方便的特性，非常好用，这样你就可以定义一个具有好几个参数的函数，然后给那些不常用的参数一些默认值，客户代码如果认为那些默认值正是他们想要的，调用函数时只需要填一些必要的实参就行了，非常方便，这样就省去了重载好几个函数的麻烦。可是我不明白c#为什么把这个特性给去掉了，可能是为了安全，这样就要求每次调用函数时都要显示地给函数赋实参。所以要注意，这可是个双刃剑，如果想用使刀的招跟对手武斗，很可能伤到自己。</p>
<p>3.参数顺序。当同个函数名有不同参数时，如果有相同的参数尽量要把参数放在同一位置上，以方便客户端代码。</p>
<h3 id="C-C-中各种类型int、long、double、char表示范围（最大最小值）-1"><a href="#C-C-中各种类型int、long、double、char表示范围（最大最小值）-1" class="headerlink" title="C/C++中各种类型int、long、double、char表示范围（最大最小值）"></a>C/C++中各种类型int、long、double、char表示范围（最大最小值）</h3><blockquote>
<p>文章：<a href="http://blog.csdn.net/chy555chy/article/details/53405072" target="_blank" rel="noopener">C/C++ 计算时间差的五种方法 / Qt 计算时间差的两种方法</a></p>
</blockquote>
<p>Qt计算时间的两种方法：</p>
<ul>
<li>QTime elapsed() : ms</li>
<li>QTime currentTime() : ms</li>
</ul>
<p>C++计算时间的五种方法：</p>
<ul>
<li>clock() : ms</li>
<li>GetTickCount() : ms</li>
<li>gettimeofday(time_val*, NULL) : us</li>
<li>QueryPerformanceFrequency(LARGE_INTEGER<em>) &amp; QueryPerformanceCounter(LARGE_INTEGER</em>) : us</li>
<li>time(NULL) : s</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QThread&gt;</span><br><span class="line">#include &lt;QTime&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;   //clock, gettimeofday, time</span><br><span class="line">#include &lt;windows.h&gt;    //Sleep, GetTickCount, timeGetTime, QueryPerformanceCounter</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">//#pragma comment(lib, &quot;winmm.lib&quot;) //timeGetTime, 但是这个库Windows或Qt或VS2015都没有自带</span><br><span class="line"></span><br><span class="line">const unsigned long SLEEP_TIME_MILL = 1000;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * QTime的精度为ms级</span><br><span class="line"> */</span><br><span class="line">void calcByQtimeElapsed() &#123;</span><br><span class="line">    QTime time;</span><br><span class="line">    time.start();</span><br><span class="line">    QThread::msleep(SLEEP_TIME_MILL);</span><br><span class="line">    int timeElapsed = time.elapsed();</span><br><span class="line">    qDebug()&lt;&lt;&quot;QTime.start &amp; QTime.elspsed =&quot;&lt;&lt;timeElapsed&lt;&lt;&quot;ms&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * QTime的精度为ms级</span><br><span class="line"> */</span><br><span class="line">void calcByQtimeCurrentTime() &#123;</span><br><span class="line">    QTime startTime = QTime::currentTime();</span><br><span class="line">    QThread::msleep(SLEEP_TIME_MILL);</span><br><span class="line">    QTime stopTime = QTime::currentTime();</span><br><span class="line">    int elapsed = startTime.msecsTo(stopTime);</span><br><span class="line">    qDebug()&lt;&lt;&quot;QTime.currentTime =&quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * clock的精度为ms级</span><br><span class="line"> */</span><br><span class="line">void calcByClock() &#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    clock_t elapsed = endTime - startTime;</span><br><span class="line">    qDebug()&lt;&lt;&quot;clock =&quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * GetTickCount的精度为ms级</span><br><span class="line"> */</span><br><span class="line">void calcByTickCount() &#123;</span><br><span class="line">    //返回自开机以来经历的毫秒数</span><br><span class="line">    DWORD startTime = GetTickCount();</span><br><span class="line">    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">    DWORD stopTime = GetTickCount();</span><br><span class="line">    DWORD elapsed = stopTime - startTime;</span><br><span class="line">    qDebug()&lt;&lt;&quot;GetTickCount = &quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///**</span><br><span class="line">// * timeGetTime的精度为ms级</span><br><span class="line">// * 必须添加Winmm.lib, 否则编译报错undefined reference</span><br><span class="line">// */</span><br><span class="line">//void calcByTimeGetTime() &#123;</span><br><span class="line">//    //返回自开机以来经历的毫秒数</span><br><span class="line">//    DWORD startTime = timeGetTime();</span><br><span class="line">//    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">//    DWORD stopTime = timeGetTime();</span><br><span class="line">//    DWORD elapsed = stopTime - startTime;</span><br><span class="line">//    qDebug()&lt;&lt;&quot;timeGetTime = &quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * gettimeofday的精度为us级</span><br><span class="line"> */</span><br><span class="line">void calcByGetTimeOfDay() &#123;</span><br><span class="line">    struct timeval startTime, stopTime;</span><br><span class="line">    gettimeofday(&amp;startTime, NULL);</span><br><span class="line">    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">    gettimeofday(&amp;stopTime, NULL);</span><br><span class="line">    long elapsed = (stopTime.tv_sec-startTime.tv_sec) * 1000000 + (stopTime.tv_usec - startTime.tv_usec);</span><br><span class="line">    qDebug()&lt;&lt;&quot;gettimeofday =&quot;&lt;&lt;elapsed&lt;&lt;&quot;us&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * QueryPerformanceCounter的精度为us级</span><br><span class="line"> */</span><br><span class="line">void calcByQueryPerformanceCounter() &#123;</span><br><span class="line">    LARGE_INTEGER frequency, startCount, stopCount;</span><br><span class="line">    WINBOOL ret;</span><br><span class="line">    //返回性能计数器每秒滴答的个数</span><br><span class="line">    ret = QueryPerformanceFrequency(&amp;frequency);</span><br><span class="line">    if(ret) &#123;</span><br><span class="line">        ret = QueryPerformanceCounter(&amp;startCount);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">    if(ret) &#123;</span><br><span class="line">        QueryPerformanceCounter(&amp;stopCount);</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret) &#123;</span><br><span class="line">        LONGLONG elapsed = (stopCount.QuadPart - startCount.QuadPart) * 1000000 / frequency.QuadPart;</span><br><span class="line">        qDebug()&lt;&lt;&quot;QueryPerformanceFrequency &amp; QueryPerformanceCounter =&quot;&lt;&lt;elapsed&lt;&lt;&quot;us&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * time(NULL)精确度为s级</span><br><span class="line"> */</span><br><span class="line">void calcByTime() &#123;</span><br><span class="line">    time_t startTime = time(NULL);</span><br><span class="line">    Sleep(SLEEP_TIME_MILL);</span><br><span class="line">    time_t stopTime = time(NULL);</span><br><span class="line">    long elapsed = stopTime - startTime;</span><br><span class="line">    qDebug()&lt;&lt;&quot;time(NULL) =&quot;&lt;&lt;elapsed&lt;&lt;&quot;s&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    calcByQtimeElapsed();</span><br><span class="line">    calcByQtimeCurrentTime();</span><br><span class="line">    calcByClock();</span><br><span class="line">    calcByTickCount();</span><br><span class="line">//    calcByTimeGetTime();</span><br><span class="line">    calcByGetTimeOfDay();</span><br><span class="line">    calcByQueryPerformanceCounter();</span><br><span class="line">    calcByTime();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/08/03/C-基础系列/1533295331354.png" alt=""></p>
<h3 id="C-C-中各种类型int、long、double、char表示范围（最大最小值）-2"><a href="#C-C-中各种类型int、long、double、char表示范围（最大最小值）-2" class="headerlink" title="C/C++中各种类型int、long、double、char表示范围（最大最小值）"></a>C/C++中各种类型int、long、double、char表示范围（最大最小值）</h3><blockquote>
<p>文章：<a href="http://blog.csdn.net/gogokongyin/article/details/51178378" target="_blank" rel="noopener">C++三种容器：list、vector和deque的区别</a></p>
</blockquote>
<p>在写C++程序的时候会发现STL是一个不错的东西，减少了代码量，使代码的复用率大大提高，减轻了程序猿的负担。还有一个就是容器，你会发现要是自己写一个链表、队列，或者是数组的时候，既要花时间还要操心怎么去维护，里面的指针啊，内存够不够用啊，长度问题，有没有可能溢出啊等等一系列的问题等着我们去解决，还是比较头疼的。所以容器的出现解决了这一个问题，它将这些数据结构都封装成了一个类，只需要加上头文件，我们就可以轻松的应用，不用那么复杂，就连指针也被封装成了迭代器，用起来更方便，更人性化，方便了我们的编程，对于程序员来说还是一大福音！！</p>
<p>C++中的容器类包括“顺序存储结构”和“关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。</p>
<ol>
<li><p>vector<br> 连续存储结构，每个元素在内存上是连续的；支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；相当于一个数组，但是与数组的区别为：内存空间的扩展。vector支持不指定vector大小的存储，但是数组的扩展需要程序员自己写。<br> vector的内存分配实现原理：<br> STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacity（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储（VS6.0是两倍，VS2005是1.5倍），所以这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。<br> 扩充空间（不论多大）都应该这样做：<br>（1）配置一块新空间<br>（2）将旧元素一一搬往新址<br>（3）把原来的空间释放还给系统<br> 注：vector 的数据安排以及操作方式，与array 非常相似。两者的唯一差别在于空间的利用的灵活性。Array 的扩充空间要程序员自己来写。<br> vector类定义了好几种构造函数，用来定义和初始化vector对象:<br> vector<t>  v1;  vector保存类型为T的对象。默认构造函数v1为空。<br> vector<t> v2(v1);  v2是v1的一个副本。<br> vector<t> v3(n, i);  v3包含n个值为i的元素。<br> vector<t> v4(n);   v4含有值初始化的元素的n个副本。</t></t></t></t></p>
</li>
<li><p>deque<br> 连续存储结构，即其每个元素在内存上也是连续的，类似于vector，不同之处在于，deque提供了两级数组结构， 第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。这样，deque除了具有vector的所有功能外，还支持高效的首/尾端插入/删除操作。<br> deque   双端队列 double-end queue<br> deque是在功能上合并了vector和list。<br> 优点：(1) 随机访问方便，即支持[ ]操作符和vector.at()</p>
<pre><code>(2) 在内部方便的进行插入和删除操作
(3) 可在两端进行push、pop
</code></pre><p> 缺点：占用内存多<br>使用区别：<br>  （1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector<br>  （2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list<br>  （3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque</p>
</li>
<li><p>list<br> 非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。<br>优点：(1) 不使用连续内存完成动态操作。</p>
<pre><code>(2) 在内部方便的进行插入和删除操作
(3) 可在两端进行push、pop
</code></pre><p>缺点：(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()</p>
<pre><code>(2) 相对于verctor占用内存多
</code></pre><p>使用区别：</p>
<pre><code>（1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector
（2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list
（3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque
</code></pre></li>
<li>vector VS. list VS. deque：<br> a、若需要随机访问操作，则选择vector；<br> b、若已经知道需要存储元素的数目，则选择vector；<br> c、若需要随机插入/删除（不仅仅在两端），则选择list<br> d、只有需要在首端进行插入/删除操作的时候，还要兼顾随机访问效率，才选择deque，否则都选择vector。<br> e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中-deque。<br> f、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，<pre><code>同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。
</code></pre></li>
</ol>
<p>问题一：list和vector的区别：<br>（1）vector为存储的对象分配一块连续的地址空间，随机访问效率很高。但是插入和删除需要移动大量的数据，效率较低。尤其当vector中存储<br>的对象较大，或者构造函数复杂，则在对现有的元素进行拷贝的时候会执行拷贝构造函数。<br>（2）list中的对象是离散的，随机访问需要遍历整个链表，访问效率比vector低。但是在list中插入元素，尤其在首尾插入，效率很高，只需要改变元素的指针。<br>（3）vector是单向的，而list是双向的；</p>
<p>（4）向量中的iterator在使用后就释放了，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的；</p>
<p>  使用原则：<br>（1）如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector；<br>（2）如果需要大量高效的删除插入，而不在乎存取时间，则使用list；<br>（3）如果需要搞笑的随机存取，还要大量的首尾的插入删除则建议使用deque，它是list和vector的折中；<br>问题二：常量容器const<br>     const vector<int> vec(10);//这个容器里capacity和size和值都是不能改变的，const修饰的是vector；<br>     迭代器：const vector<int>::const_iterrator ite; //常量迭代器；<br>      注：const vector <int> vec(10) —— 与const int a[10]是一回事，意思是vec只有10个元素，不能增加了，里面的元素也是不能变化的</int></int></int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a(10);  </span><br><span class="line">const vector&lt;int&gt; b(10);  </span><br><span class="line">a[1]=10;//正确  </span><br><span class="line">b[1]=10;//错误  </span><br><span class="line">a.resize(20);//正确  </span><br><span class="line">b.resize(20);//错误</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;const int&gt; vec(10);  //目前没有这种用法;这样写后也是当作vector &lt;int&gt;vec来用的；  </span><br><span class="line">关于vector&lt;const int&gt; ，在GCC下是没有这种用法的,编译不过  </span><br><span class="line">在VS2008是把它当作vector&lt;int&gt;这种类型来处理的；</span><br></pre></td></tr></table></figure>
<p>问题三：capacity V.S size<br>    a、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。<br>    b、size是容器当前存储的元素的数目。<br>    c、vector默认的容量初始值，以及增长规则是依赖于编译器的。<br>问题四：用vector存储自定义类对象时，自定义类对象须满足：<br>    a、有可供调用的无参构造函数（默认的或自定义的）；<br>    b、有可用的拷贝赋值函数（默认的或自定义的）</p>
<p>问题五：迭代器iterator<br>     a、vector与deque的迭代器支持算术运算，list的迭代器只能进行++/–操作，不支持普通的算术运算。<br>     b、向量中的iterator在使用后就释放了，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的；</p>
<p>vector代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ite=find(vec.begin(),vec.end(),88);  </span><br><span class="line">vec.insert(ite,2,77);  //迭代器标记的位置前，插入数据；  </span><br><span class="line">cout&lt;&lt;*ite&lt;&lt;endl;  //会崩溃，因为迭代器在使用后就释放了，*ite的时候就找不到它的地址了；</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">#include &lt;vector&gt;   //向量的头文件；  </span><br><span class="line">#include &lt;algorithm&gt; //算法的头文件；  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    vector &lt;int&gt; vec(5,8);  </span><br><span class="line">    //--类型是vector&lt;int&gt;，该容器向量中含有5个int类型的数值8，变量名为vec。  </span><br><span class="line">    //vector是一个类模板（class template）,所以必须要声明其类型，int，一个容器中所有的对象必须是同一种类型；  </span><br><span class="line">    // 定义一个容器对象；直接构造出一个数组；用法和数组一样；  </span><br><span class="line">    //    </span><br><span class="line">        for(int i=0;i&lt;vec.size();i++)   //size()是指容器里当前有多少个使用的元素；  </span><br><span class="line">        &#123;  </span><br><span class="line">            cout&lt;&lt;vec[i]&lt;&lt;&quot;  &quot;;  </span><br><span class="line">        &#125;     </span><br><span class="line">        cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  //得到容器里用的多少个空间，和总共的大小；  </span><br><span class="line">     vector&lt;int&gt;::iterator ite;  //定义了一个向量的迭代器；相当于定义了一个指针；  </span><br><span class="line">    for(ite=vec.begin();ite!=vec.end();ite++)   //得到开始、结束  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*ite &lt;&lt;&quot; &quot;;  //迭代器返回的是引用：  </span><br><span class="line">    &#125;  </span><br><span class="line">        cout&lt;&lt;endl;  </span><br><span class="line">    //在尾部插入；  </span><br><span class="line">    vec.push_back(9);  //VS6.0扩充的空间是两倍；在VS2005扩充的空间是1.5倍；  </span><br><span class="line">    for(ite=vec.begin();ite!=vec.end();ite++)   //得到开始、结束  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*ite &lt;&lt;&quot; &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    //尾部删除;容量没变【capacitty】，但是使用空间减少一个；容量一旦增加就不会减小；  </span><br><span class="line">    vec.pop_back();  </span><br><span class="line">    for(ite=vec.begin();ite!=vec.end();ite++)   //得到开始、结束  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*ite &lt;&lt;&quot; &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    vec.push_back(88);    </span><br><span class="line">    vec.push_back(99); //容量刚好够；  </span><br><span class="line"></span><br><span class="line">    for(ite=vec.begin();ite!=vec.end();ite++)   //得到开始、结束  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*ite &lt;&lt;&quot; &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    ite = find(vec.begin(),vec.end(),88);   //查找这个元素；  </span><br><span class="line">    vec.erase(ite);  //利用迭代器指针删除这个元素；  </span><br><span class="line">    for(int i=0;i&lt;vec.size();i++)   //size()是指容器里当前有多少个使用的元素；  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  //得到容器里用的多少个空间，和总共的大小；  </span><br><span class="line"></span><br><span class="line">    vec.clear(); //只是清除了数据，没有回收空间，空间的等到对象的生命周期结束时回收；  </span><br><span class="line">    //使用空间为0，但是容量的空间还在，只有在调用析构函数的时候空间才会回收；  </span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;vec.size();i++)   //size()是指容器里当前有多少个使用的元素；  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;vec[i]&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    ite=find(vec.begin(),vec.end(),88);  </span><br><span class="line">    vec.insert(ite,2,77);  //迭代器标记的位置前，插入数据；  </span><br><span class="line"></span><br><span class="line">    &lt;span style=&quot;color:#ff0000;&quot;&gt;//cout&lt;&lt;*ite&lt;&lt;endl;  //会崩溃，因为迭代器在使用后就释放了，*ite的时候就找不到它的地址了；  </span><br><span class="line">    //和向量的用法一样，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的；&lt;/span&gt;  </span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;vec.size();i++)     </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;vec[i]&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2018/08/03/C-基础系列/1533295351967.png" alt=""></p>
<p>list代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include &lt;list&gt;  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">using namespace  std;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    list&lt;char&gt; lit;   </span><br><span class="line">    //用法和向量一样，  </span><br><span class="line">    //list是一个类模板，template，char是链表里对象的类型，lit是创建的一个对象；  </span><br><span class="line">    //链表可以再头尾两端插入,是双向的；  </span><br><span class="line"></span><br><span class="line">    lit.push_back(&apos;a&apos;);  </span><br><span class="line">    lit.push_back(&apos;b&apos;);  </span><br><span class="line">    lit.push_front(&apos;d&apos;);  </span><br><span class="line">    lit.push_front(&apos;e&apos;);  </span><br><span class="line">    lit.push_front(&apos;f&apos;);  </span><br><span class="line">    lit.push_front(&apos;b&apos;);  </span><br><span class="line">    lit.push_front(&apos;b&apos;);  </span><br><span class="line"></span><br><span class="line">    list&lt;char&gt;::iterator it;  //定义一个list的迭代器，类似一个纸箱链表的指针，但是比一般的指针好用，里面用到了好多重载操作；  </span><br><span class="line">    list&lt;char&gt;::iterator it1;    </span><br><span class="line">    list&lt;char&gt;::iterator it2;    </span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    //-----------链表可以从两端删除-------------------   </span><br><span class="line">    lit.pop_back();    </span><br><span class="line">    lit.pop_front();  </span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    //-------------删除所有的a---------------------------------  </span><br><span class="line">    //lit.remove(&apos;a&apos;);  //删除所有的a;  </span><br><span class="line"></span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    //-------------移除连续且相同的a，只剩下一个;--------------------------------  </span><br><span class="line">    lit.unique();  //移除连续且相同的a，只剩下一个;  </span><br><span class="line"></span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    list&lt;char&gt; lit1;  </span><br><span class="line">    lit1.push_back(&apos;g&apos;);  </span><br><span class="line">    lit1.push_back(&apos;h&apos;);  </span><br><span class="line">    lit1.push_back(&apos;i&apos;);  </span><br><span class="line">    lit1.push_back(&apos;k&apos;);  </span><br><span class="line">    for(it1=lit1.begin();it1!=lit1.end();it1++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it1&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    //-------------将一个链表插入到另一个链表---------------------------------  </span><br><span class="line">    it1=find(lit.begin(),lit.end(),&apos;f&apos;);  //先的找到要插入的位置，在该位置的前一个插入；  </span><br><span class="line">    ////lit.splice(it1,lit1); //将第二个链表插入到第一个链表中；合并后的链表就没了，因为传的是&amp;；  </span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    //------在链表lit中的it前插入lit1中的一个元素it1；在f之前插入k-----  </span><br><span class="line">    //-----拿下来之后那个元素就没有了-------------------  </span><br><span class="line">    it=find(lit.begin(),lit.end(),&apos;f&apos;);  </span><br><span class="line">    it1=find(lit1.begin(),lit1.end(),&apos;k&apos;);  </span><br><span class="line">    lit.splice(it,lit1,it1);  </span><br><span class="line">    //-------------把链表中的一段插入到另一个链表中---------------------------------  </span><br><span class="line">    //把链表lit1中的[it-----it1)段的字符插入到lit的it2指针前；  </span><br><span class="line">    it=find(lit1.begin(),lit1.end(),&apos;h&apos;);  </span><br><span class="line">    it1=find(lit1.begin(),lit1.end(),&apos;k&apos;);  </span><br><span class="line">    it2=find(lit.begin(),lit.end(),&apos;f&apos;);  </span><br><span class="line">    lit.splice(it2,lit1,it,it1);   </span><br><span class="line">    // ----void merge(list&amp; x); //将x合并到*this 身上。两个lists 的内容都必须先经过递增归并排序。  </span><br><span class="line">    lit.sort();   //对两个排序进行归并排序；  </span><br><span class="line">    lit1.sort();  </span><br><span class="line">    lit.merge(lit1);  </span><br><span class="line">    //-----------将list里的数据倒序排列---------------  </span><br><span class="line">    lit.reverse();  </span><br><span class="line">    for(it=lit.begin();it!=lit.end();it++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    for(it1=lit1.begin();it1!=lit1.end();it1++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;*it1&lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2018/08/03/C-基础系列/1533295368357.png" alt=""></p>
<h3 id="17-四舍六入五成双"><a href="#17-四舍六入五成双" class="headerlink" title="17.四舍六入五成双"></a>17.四舍六入五成双</h3><p>四舍六入五成双是一种比较精确比较科学的计数保留法，是一种数字修约规则。<br>　　对于位数很多的近似数，当有效位数确定后，其后面多余的数字应该舍去，只保留有效数字最末一位，这种修约（舍入）规则是“四舍六入五成双”，也即“4舍6入5凑偶”这里“四”是小于五的意思，”六”是大于五的意思，”五”是所精确的位的后一位，当5后有数，舍5入1，5后无数或为0时：<br>        ①5前为奇数，舍5入1；<br>        ②5前为偶数，舍5不进。<br>　　具体规则如下：<br>　　1. 小于5舍去，即舍去部分的数值小于保留部分的末位的半个单位，则末位不变；<br>　　2. 大于5进1，即舍去部分的数值大于保留部分的末位的半个单位，则末位加1；<br>　　3. 等于5时取偶数，即舍去部分的数值，等于保留部分的末位的半个单位，则<br>　　末位凑成偶数，即当末位为偶数时，末位不变；当末位为奇数时，末位加1。<br>　　举例，用上述规则对下列数据保留3位有效数字：<br>　　9.8249=9.82, 9.82671=9.83<br>　　9.8251=9.83, 9.8350 =9.84<br>　　9.8250=9.82, 9.82501=9.83<br>　　从统计学的角度，“四舍六入五成双”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“四舍六入五成双”使测量结果受到舍入误差的影响降到最低。<br>　　例如:1.15+1.25+1.35+1.45=5.2，若按四舍五入取一位小数计算：<br>　　1.2+1.3+1.4+1.5=5.4<br>　　按“四舍六入五成双”计算，1.2+1.2+1.4+1.4=5.2，舍入后的结果更能反映实际结果。</p>
<h3 id="td-setprecision与showpoint和ios-fixed的配合使用"><a href="#td-setprecision与showpoint和ios-fixed的配合使用" class="headerlink" title="td::setprecision与showpoint和ios::fixed的配合使用"></a>td::setprecision与showpoint和ios::fixed的配合使用</h3><blockquote>
<p><a href="http://blog.csdn.net/l281865263/article/details/46239891" target="_blank" rel="noopener">C++随笔 —— std::setprecision与showpoint和ios::fixed的配合使用</a></p>
</blockquote>
<p>今天写代码的时候发现了个bug，而且是非常奇怪的bug。因为float类型的数据A在cout以后显示的值明明是等于B的，可计算机判断A&lt;B却为真。</p>
<p>为了弄明白这是怎么回事，问了同学以后大概知道问题出在cout的precision上。由于精度的限制，cout 跟 printf 类似，打印出来的值并不一定完全等于它的实际值。</p>
<p>事实表明的确是这样的。比如，A = 50.4999994，B = 50.5，显示A&lt;B，而打印A的语句如果是这样：cout &lt;&lt; A &lt;&lt; endl，那么你看到的就是50.5。这让人困惑，以为A=B。</p>
<p>通过在网上仔细查资料学习，明白了为什么。原文总结得已经很全面了，所以直接贴过来。原文转自这里</p>
<p>先写写自己的几点总结：</p>
<p>1、setprecision(n):</p>
<p>表示保留n位有效数字，其中最后一位是四舍五入之后的结果；默认情况下n=6</p>
<p>所以对于50.4999994，如果n&lt;9，cout 打印出来的数值都是50.5，后面的零会省去不打印。</p>
<p>2、如果加上showpoint，后面的零就不省略了。</p>
<p>3、ios::fixed 是用来控制小数点后面的打印数字个数的。</p>
<p>转载正文：</p>
<p>首先要加头文件：iomanip</p>
<p>一：setprecision</p>
<p>作用：控制输出流显示浮点数的数字个数，setprecision(n)就是输出的n个数，会有四舍五入。</p>
<p>比如:double s=20.7843000,</p>
<p>cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;会输出2e+001，因为要输出一个数字，所以只有2.</p>
<p>cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21。</p>
<p>cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.8。</p>
<p>cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.7843。</p>
<p>cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.7843。</p>
<p>cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.7843。</p>
<p>可见，小数部分末尾为0时，是输不出来的！</p>
<p>要想输出来，就得用showpoint了。</p>
<p>特别提示：</p>
<p>（如果再在这些语句后面加个两个语句：</p>
<p>cout&lt;&lt;1&lt;&lt;endl;</p>
<p>cout&lt;&lt;1.00800&lt;&lt;endl;</p>
<p>猜到会输出什么吗？</p>
<p>第一条输出：1。不是浮点型。</p>
<p>第二条为：1.008。承接setprecision(8）的这条规则语句。</p>
<p>注：</p>
<p>如果直接有语句</p>
<p>int main()</p>
<p>{</p>
<p>cout&lt;&lt;1&lt;&lt;endl;</p>
<p>cout&lt;&lt;1.00&lt;&lt;endl;</p>
<p>}</p>
<p>第一条输出：1。</p>
<p>第二条也为：1。按整型输出<br>）</p>
<p>二：setprecision与showpoint</p>
<p>语法：在输出语句前声明：cout.setf(ios::showpoint);就行了！</p>
<p>还比如:double s=20.7843000,</p>
<p>cout.setf(ios::showpoint);</p>
<p>cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;就会输出2.e+001，注意，2和e之间多了一个“.”。</p>
<p>cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21.。多个点！</p>
<p>cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.8。</p>
<p>cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.7843。</p>
<p>cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.78430。</p>
<p>cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.784300。</p>
<p>可见，就会输出想要的数据数目！</p>
<p>特别提示：</p>
<p>（如果再在这些语句后面加个两个语句：</p>
<p>cout&lt;&lt;1&lt;&lt;endl;</p>
<p>cout&lt;&lt;1.0080&lt;&lt;endl;</p>
<p>猜到会输出什么吗？</p>
<p>第一条输出：1。不是浮点型。</p>
<p>第二条也为：1.0080000。承接setprecision(8）的这条规则语句。</p>
<p>三：setprecision与fixed</p>
<p>如果想要保留几位小数，那setprecision就得与fixed合作了！！</p>
<p>语法：在输出语句前声明：cout.setf(ios::fixed);</p>
<p>比如:double s=20.7843909</p>
<p>cout.setf(ios::fixed);</p>
<p>cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;就会输出2.8  。</p>
<p>cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21.78。多个点！</p>
<p>cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.784。</p>
<p>cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.784391。</p>
<p>cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.7843909。</p>
<p>cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.78439090。</p>
<p>特别提示：</p>
<p>（如果也再在这些语句后面加个两个语句：</p>
<p>cout&lt;&lt;1&lt;&lt;endl;</p>
<p>cout&lt;&lt;1.008&lt;&lt;endl;</p>
<p>猜到会输出什么吗？</p>
<p>第一条输出：1。</p>
<p>第二条为：1.00800000。</p>
<p>就是承接了setprecision(8）的这条规则语句，是浮点型的都会保留8个小数。是整型的还是整型！）</p>
<p>语句也可以写成：cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;</p>
<p>就算后面的语句没有写&lt;&lt;fixed，同样会按有&lt;&lt;fixed处理。</p>
<p>比如有语句：</p>
<p>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;</p>
<p>A：cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;</p>
<p>B:cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;</p>
<p>ＡＢ语句均会按保留７个，８个小数处理，不会再按有7或8个浮点数处理。</p>
<p>如果下面有语句c:</p>
<p>cout&lt;&lt;1.008&lt;&lt;endl;也会保留8个小数。</p>
<p>四:setprecision、showpoint与fixed</p>
<p>{cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;123.456&lt;&lt;endl;//输出的结果是123.46<br>cout&lt;&lt;showpoint&lt;&lt;12345.0006666&lt;&lt;endl;//输出12345.0<br>cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;123.456&lt;&lt;endl;}</p>
<p>比如:double s=20.7843909</p>
<p>1.有语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78</span><br></pre></td></tr></table></figure></p>
<p>2.有语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21</span><br><span class="line">cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出21.（有个点）</span><br></pre></td></tr></table></figure>
<p> 3.有语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78391</span><br><span class="line">cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出20.78391</span><br></pre></td></tr></table></figure>
<p>4.有语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78</span><br><span class="line">cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出20.78</span><br></pre></td></tr></table></figure>
<p>5.有语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21</span><br><span class="line">cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//21.（有个点）</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//20.78</span><br></pre></td></tr></table></figure>
<h3 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h3><blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/47906197/how-to-compare-double-values-limiting-the-decimal-places" target="_blank" rel="noopener">How to compare double values limiting the decimal places?</a></p>
</blockquote>
<p>The usual way to compare two floating point values is to subtract them from each other, get the absolute value of the result, and compare it to an epsilon value.</p>
<p>In your case it could be something like<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool compare(double value1, double value2, quint8 precision)</span><br><span class="line">&#123;</span><br><span class="line">    return std::abs(value1 - value2) &lt; std::pow(10, -precision);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For a precision of e.g. <code>6</code> then <code>std::pow(10, -precision)</code> should equal <code>0.000001</code> (this is the epsilon), and if the difference between the two values is smaller than that they are considered equal.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BingcaiHuang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BingcaiHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("zB9W7fUpG8e9iQF9I018I0bj-gzGzoHsz", "RkIarEbWMsL4NVGQPKkJwzAi");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
