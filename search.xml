<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git-submodule用法]]></title>
    <url>%2F2018%2F07%2F26%2FGit-submodule%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参考文章git的submodule功能详解 前言项目的版本库在某些情况下需要引用其他版本库中的文件，例如有一套公用的代码库，可以被多个项目调用，这个公用代码库能直接放在某个项目的代码中，而是要独立为一个代码库，那么其他要调用公用的代码库该如何处理？分别把公用的代码库拷贝到各自的项目中会造成冗余，丢弃了公共代码库的维护历史，这些显示不是好的办法，现在要了解的git子模组(git submodule)就解决了这个问题。 Git 子模块功能允许你将一个Git仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 准备工作首先需要两个版本库例如：1) 一个公共的版本库(例如：libA.git)git@gitlab.szreach.com:fengyang/liba.git 2) 一个引用公共版本库的主版本库(例如：super.git)git@gitlab.szreach.com:fengyang/super.git TortoiseGit上git submodule功能实现添加子模组的步骤####第一步：使用submodule add…添加子模组在需要作添加子模组的Git版本库中右击，选择“TortoiseGit-&gt;Submodule Add…”，在“Repository:”里面输入需要添加子模组的版本库路径，在“Path：”中输入添加子模组存放的目录路径。如下图所示： 此时查看需要添加子模组的Git工作区的目录结构。在根目录下多了一个.gitmodules文件，并且公共代码库被克隆到lib/lib_a目录下。 ####第二步：查看.gitmodules的内容.gitmodules的内容记录着含子模组存放的目录路径及子模组版本库的路径 注：此时工作区尚未提交，完成提交后，子模组才算正式完成在需要作添加子模组的Git版本库中创立。 注：此主版本库(super.git)就变成了一个包含子模组的版本库。 克隆带子模组的版本库的步骤克隆带子模组的git库，并不能自动将子模组的版本库克隆出来，对于只关心项目本身的数据，而不关心项目引用的外部项目数据的用户，这个功能非常好，数据没有冗余而且克隆的速度也很快。 第一步：克隆super主版本库在工作区中克隆主主版本库后，会发现子模组的版本库并没有克隆，只有将存放子模组版本库的目录克隆下来了。 存放子模组版本库的目录路径 第二步：克隆子模组如果需要克隆出子模组形式引用的外部库，首先需要执行Submodule Update操作。 在需要作克隆子模组的Git工作区中右击，选择“TortoiseGit-&gt;Submodule Update…”,点击“OK”即可。 执行Submodule Update…操作后就会把子模组的版本库克隆下来。 对主Git库工作区作commit、checkout、revert、pull、push等更改Git工作区内容的操作时，查看Submodule目录下内容的效果1) 对主Git库工作区作commit操作当在主Git库工作区中变更到达一个适当状态时，我们需要将这些变更提交到Git库，作版本备份和跟踪。 方法： 在工作区内右击，选择“ Commit-&gt; “当前分支名称” ”，在Commit窗口中，选择需要提交的变更path，填写提交说明，点击“Ok”。 结论：在主git工作区作commit操作，只是将主Git工作区的变更历史提交到主Git本地库中，对Submodule没有任何影响。 对主Git库工作区作checkout操作当在主Git库工作区中想要切换到其他某个分支、某个tag、某个commit历史记录。 我们这里举个特殊的例子： 切换到某个commit历史记录(如在主版本库中提交子版本库的历史记录) 方法： 在Git工作区内的某目录上右击，选择“Swicht/Checkout…”在Swicht/Checkout…Checkout窗口中，在Switch to Commmit中列出需要切换的commit历史记录，在此列表中选择需要切换到的commit历史记录，以后点击“Ok”按钮。 注：由于切换到的是在主版本库中提交子版本库的那条历史记录，因此子模组中状态也会改换，也需要在子模组中执行切换。 执行Submodule Update操作即可。 对主Git库工作区作revert操作当在主Git库工作区中这次变更有错误时，就可以使用revert操作来撤销这次次操作。 方法： 在工作区内右击，选择“Revert”，在Revert窗口中，选择需要撤销的变更path，点击“Ok”。 结论：在主git工作区作revert操作，只是将主Git工作区某次的变更操作给撤销，此次操作之前的commit都会被保留，且对Submodule没有任何影响。 对主Git库工作区作push操作当在主Git库工作区中将主Git本地库的数据推送到主Git远程库中。 方法：在工作区的目录上（不要在文件上）右击，选择“Git Sync…” “Local Branch”，”Remote Branch”，“Remote URL”这3栏必须正确才能“推”数据。 结论：在主git工作区作push操作，只是将主Git本地库的变更历史推送到到主Git远程库中，对Submodule没有任何影响。 对主Git库工作区作pull操作当在主Git库工作区中将主Git远程库的拉取到主Git本地库中。 方法：在工作区的目录上（不要在文件上）右击，选择“Git Sync…” “Local Branch”，”Remote Branch”，“Remote URL”这3栏必须正确才能“拉”数据。 结论：在主git工作区作pull操作，只是将主Git远程库的变更历史拉取到到主Git本地库中，对Submodule没有任何影响。 对submodule下的内容进行修改后commit、push，对submodule目录作pull在执行Submodule Update…操作更新出子模组后，都以某个具体的提交版本进行检出，进入子模组目录，会发现其处于非跟踪状态。 显然这种情况下，如果修改lib/lib_a下的文件，提交就会丢失。下面介绍如何在检查的子模组中修改，以及如何更新子模组。 在子模组中切换到master分支(或者其他想要修改的分支)后在进行修改。 切换到master分支，然后在工作区做一些改动。 执行commit后，并且推送到子模组库中后。 回到主版本库中。 在主版本库中查看状态，在主版本库中可以看到子模组已修改，包含了更新的提交。 需要将修改提交在主版本库中进行推送。 对submodule目录作pull当子模组版本库中有新的提交历史记录，就需要做pull操作来更新。 注：对子模组库中做了pull操作，同时需要对调用子模组库的主版本库中也要做Pull操作。 如下图所示： 注意：进入子模组目录，会发现其处于非跟踪状态。显然这种情况下，如果修改lib/lib_a下的文件，提交就会丢失。提示如下： 移除Submodule第一步：用Delete(keep local) 将目录或文件命令从git的索引库中移除子模块目录方法： 在工作区内目录或文件上右击，选择“Delete(keep local)”，在Delete窗口中，点击“Remove”。 Delete(keep local)把目录lib/从git的索引库中移除,但是对目录lib/本身并不进行任何操作。 因此需要彻底删除。 第二步：删除物理文件 第三步：删除.gitmodule文件 第四步：删除.git/config的submodule配置源文件 删除如下图所示红框的部门 第五步：删除后，提交更改]]></content>
      <categories>
        <category>TortoiseGit</category>
      </categories>
      <tags>
        <tag>TortoiseGit</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git cherry-pick用法]]></title>
    <url>%2F2018%2F07%2F26%2FGit-cherry-pick%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[TortoiseGit之cherry-pick使用有这么一个需求，分支节点A作为dev分支，分支节点B和C作为功能分支，某天在B节点上爆发出一个bug，经研究发现该bug是根节点带出的，意味着C上也会有该bug，此时正确的修复手段是从B和C的共同根节点A中拉出分支，对该bug进行修复，而不是分别在B和C上进行代码修改。于此同时也许在A节点上有新的功能增加，此时不能直接把修复bug对应的commit合并到B和C上，而需要用到cherry-pick。参考以下文章： git cherry-pick 把提交到A分支的部分commit 再提交到B分支上 应用环境:有一个主分支 master (这个分支只是用来合并其他通过测试的分支,及上线打版本)另一个分支 dev (开发提交的分支) 当你通过一番挣扎终于搞定一个bug,顺手提交到 git 服务器,心里一阵暗爽. 这时发现你当前所在的分支是 master !!!这个分支不是开发者用来提交代码的,可惜现在剁手也晚了。怎么办?于是你想到,合并分支……合并分支通常会带来各种各样的冲突，而且当前 dev 分支还在开发中,没有进过测试,所以就算合并也是 dev 合并 master 分支。但是车根本太大。这时最好的解决方案就是用 cherry-pick。 使用方法: 先切换到刚才你误操作的分支下 master 1git checkout master 然后找到你的提交信息 1234git logcommit 424037d22c5830ba39b7c46bacd4abcb2abe072dAuthor: bingcaihuang &lt;bingcaihuang@gmail.com&gt;Date: Thu Jul 26 13:31:33 2018 +0800 从提交日志中找到 commitID 1424037d22c5830ba39b7c46bacd4abcb2abe072d 切换到 dev 分支下 1git checkout dev 把 master 下的 bug fixed! 提交重新提交的 dev 分支下 1234git cherry-pick &apos;424037d22c5830ba39b7c46bacd4abcb2abe072d&apos;Finished one cherry-pick.On branch devYour branch is ahead of &apos;origin/dev&apos; by 1 commits. 上面的提示信息告诉我们这个 commit 已经重新提交到了 dev 分支下。注意,这个操作也行会报错,这时需要你手动去合并冲突,然后重新提交。最后 git push Cherry pickingTortoiseGit官方说明书：Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown.Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown.Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown. The Cherry Pick dialog is similar to the Rebase dialog. The top table displays one line for each selected commit to cherry-pick. Buttons below it control the actions (Pick, Squash, Edit, Skip) and the order in which multiple commits are picked. Selecting a line shows the files affected by the commit. git cherry-pick 从其他分支检出指定的commit到当前分支 参考文章：git cherry-pick 从其他分支检出指定的commit到当前分支]]></content>
      <categories>
        <category>TortoiseGit</category>
      </categories>
      <tags>
        <tag>TortoiseGit</tag>
        <tag>cherry-pick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo基于GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F07%2F24%2F%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用 Hexo 基于 GitHub Pages 搭建个人博客（一） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（一） GitHub Pages 是 GitHub 提供的免费开源的静态站点托管服务，利用这个服务可以搭建轻量级的博客系统，本文介绍了如何使用 Hexo 结合 GitHub Pages 服务搭建个人博客。最后博客配置文件以及博文md文件保存在Nas的Git中，通过Git维护数据。 安装配置 Git安装 Git使用 GitHub 首先要安装 Git，可根据操作系统下载不同版本的 Git，Windows 下载地址：https://git-scm.com/download/win 安装过程比较简单，选择默认选项配置即可下一步，不再叙述。 配置 Git设置本地机器默认 commit 的昵称与 Email，姓名与 Email 只用于日志标识，实际推送到远程仓库时，要用有操作权限的账号登录。 12git config --global user.name &quot;ehlxr&quot;git config --global user.email &quot;ehlxr@qq.com&quot; 生成 SSH keysSSH Keys 是 GitHub 推荐的公钥、秘钥形式验证用户合法性的机制，添加 SSH Keys 可以省去每次都要输入密码的步骤，下面将演示如何在本地计算机生成 SSH Keys 的公钥、秘钥。 首先打开安装的 Git Bash 运行 ssh-keygen 命令输入以下命令：（替换 &quot;your_email@example.com&quot; 为注册时候的邮箱） 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 保存秘钥文件当出现以下提示时，直接敲回车键选择默认地址即可（保存私钥文件位置，默认保存在当前用户文件夹下的 .ssh 文件夹中，文件名称为 id_rsa ）1Enter file in which to save the key (/c/Users/lt/.ssh/id_rsa): 如果已经存在会提示，输入：y 敲回车替换即可12/c/Users/lt/.ssh/id_rsa already exists.Overwrite (y/n)? 出现以下提示设置密码提示，不用设置密码，敲回车键即可1Enter passphrase (empty for no passphrase): 再次确认密码提示，不用设密码敲回车即可1Enter same passphrase again: 出现以下提示，表明已经成功生成了 SSH Keys 12345678910111213141516Your identification has been saved in /c/Users/lt/.ssh/id_rsa.Your public key has been saved in /c/Users/lt/.ssh/id_rsa.pub.The key fingerprint is:SHA256:dBtq6OOJs1JQat630kGqh320Y0JSb7smaR6c9jjo7h0 your_email@example.comThe key&apos;s randomart image is:+---[RSA 4096]----+| || . || o . o || = .o o o || + + o. S . ||.oo.*.o. ||oo=E +oo ||o.#+Oooo ||+OoO==o |+----[SHA256]-----+ Github 官网 SSH Keys 生成教程 开启 GitHub Pages 服务GitHub 账户注册比较简单，注册免费使用的账户就可以了，这里就不细说了，需要注意的是尽量不要使用 126/163 邮箱注册，我在测试的时候收不到验证码，等收到验证码的时候已经第二天了，早就过期了，我使用 Gmail 和 QQ 邮箱都能很快收到验证码。 添加生成的 SSH Keys 到 GitHub打开生成的 SSH Keys 公钥 登录注册的 GitHub 账户，按照以下图示 1、2、3、4、5、6、7 步骤操作，复制公钥内容粘贴到下图步骤 5 的 Key 输入框中，在 步骤 6 输入一个标题，点击 步骤 7 的 Add SSH key 按钮，这时候会提示你输入 GitHub 账号密码，输入密码确认即可添加成功。 创建 GitHub 仓库按照下图所示操作，仓库名称按照：yourname.github.io 格式创建，这样就可以通过 yourname.github.io 方式访问你的博客。如果创建名称为：myblog , 则博客的访问路径为 yourname.github.io/myblog 填写完仓库名称，其他选项默认，点击 Create repository 即可完成创建。 测试 GitHub Pages 服务接下来在仓库根目录下创建一个 index.html 文件测试 GitHub Pages 服务是否开启成功。打开刚才创建的仓库，因为我们之前已经添加了 SSH Keys，所以选择复制如下图所示的 SSH 仓库连接 在电脑磁盘创建一个文件夹（我创建在：D:/lxr）在 Git Bash 分别输入以下两条命令：123cd /d/lxr/ # 进入创建的文件夹git init # 初始化本地仓库 在本地文件夹中创建 index.html 文件，随便输入一些内容即可，命令如下：1echo &quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot; &gt;&gt; index.html # 创建 index.html 文件 然后分别执行以下命令：1234git add index.html # 添加文件git commit -m &quot;create index.html&quot; # 提交文件git remote add origin git@github.com:ehlxr/ehlxr.github.io.git # 添加 GitHub 仓库地址，注意地址填写自己注册的 GitHub 仓库地址git push -u origin master # push 到 GitHub 浏览器访问：yourname.github.io 如果出现 index.html 输入的内容，即 GitHub Pages 服务开启成功 使用 Hexo 基于 GitHub Pages 搭建个人博客（二） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（二） Node.js 安装Hexo 是基于 Node.js 安装，所以安装 Hexo 之前首先要安装 Node.js。下载地址：https://nodejs.org/en/download/ 根据自己的操作系统，下载对应版本即可。Windons 安装过程比较简单，一直下一步即可安装完成。 CentOS 7 安装 Node.js Hexo 安装打开 Git Bash 输入以下命令开始安装 Hexo1npm install hexo-cli -g 出现以下界面表示安装完成 Hexo配置文件的设置确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true1post_asset_folder: true 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用1hexo new 生成一篇新文章时，会在1\source\_posts 目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等 有了上面的配置，再加上Atom的图片插入插件，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去。 Hexo 建站安装 Hexo 完成后，在本地磁盘创建一个目录用于存放 Hexo 配置文件和博客源代码，我的 Hexo 存放在 D:/Hexo 目录下。 分别执行下列命令，Hexo 将会在 D:/Hexo 新建所需要的文件1234567891011# 进入 D:/ehlxr 目录cd /d/ehlxr/# 初始化所需要的文件到 Hexo 文件夹hexo init Hexo# 进入 Hexo 文件夹cd Hexo# 安装npm install 分别执行以下命令在本地进行预览 12345# 编译生成博文hexo generate# 启动Hexo服务器hexo server 出现以下画面表示服务启动成功 打开浏览器输入 http://localhost:4000/ 便可以看到最原始的博客了 Hexo 部署到 GitHub Pages更新 Hexo 安装文件夹中 _config.yml 文件，如图 更新 _config.yml 文件中的 deploy 节点，如图所示，可添加多个地址（如一个 GitHub、Coding、oschina），冒号后面要有空格，这是一个坑 分别执行以下命令即可完成部署12345npm install hexo-deployer-git --save # 安装 hexo-deployer-githexo clean # 可简写为 hexo clhexo generate # 可简写为 hexo ghexo deploy # 可简写为 hexo d 访问 https://yourname.github.io 即可看到博客模板的内容，对于 Hexo 的一些详细设置可以参考 Hexo 官方文档 。本站使用的 Hexo 主题是 NexT，详细设置可参考 Next 主题官方网站。 使用以下命令就可以新建一篇博客文章1hexo new &quot;开始blog，哈哈&quot; 打开 Hexo 目录下的 source\_posts 目录就可以看见创建的文章了，如图所示 文章是 MarkDown 格式文件（关于 Markdown 语法可参考 Markdown 语法说明 (简体中文版)），编辑文章后保存，可以先启动本地 Hexo Server 查看效果，然后执行部署命令就完成了博客文章的发布 Markdown 编辑器我推荐使用 小书匠 至此，使用 Hexo 基于 GitHub Pages 搭建个人博客就介绍完了。 使用 Hexo 基于 GitHub Pages 搭建个人博客（三） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（三） 主题基本配置记录一下 Next 主题的基本配置、设置「阅读全文」、关闭新建页面的评论功能、页面文章的篇数、宽度调节、设置「JavaScript 第三方库」等内容、在线字体替换（选择关闭，加快访问速度） 主题安装Next 主题安装与所有 Hexo 主题安装一样。当克隆或者下载（Next 主题 GitHub 地址）完成主题文件后，拷贝至站点目录的 themes 目录下，一般命名为 next，打开站点配置文件， 找到 theme 字段，并将其值更改为 next 即可。 1theme: next 主题宽度调节编辑 themes/next/source/css/_variables/custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 以上方法不适用 Pisces Scheme Pisces Scheme 编辑 themes/next/source/css/_schemes/Picses/_layout.styl 文件，更改以下 css 选项定义值： 123.header&#123; width: 1150px; &#125;.container .main-inner &#123; width: 1150px; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 多说评论安装多说注册多说，登录后在首页选择 “我要安装”。 创建站点按要求填写如下图所示表单： 注意： 多说域名 这一栏填写的即是你的 duoshuo_shortname，在下一步主题配置中需要使用到。 主题配置多说创建站点完成后，在 主题配置文件 中新增 duoshuo_shortname 字段，值设置成上一步创建站点中填写的 多说域名 即可。 开启多说热评文章在 主题配置文件 中，设置 duoshuo_hotartical 配置项的值为 true，即可开启多说热评文章。 多说评论样式调整登录多说后，在首页右上角点击 “后台管理”，选择站点名称打开多说后台管理页面，选择“设置” 下拉找到 “自定义 CSS” 输入框，填写以下CSS样式，效果参考本站文章结尾评论样式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 统计我使用 LeanCloud 统计文章阅读数，使用不蒜子统计站点的 PV 和 UV 数。 文章阅读次数统计（LeanCloud)参考为 NexT 主题添加文章阅读量统计功能 不蒜子统计站点访问统计编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：1234567891011121314151617# count values only if the other configs are falseenable: true# custom uv span for the whole sitesite_uv: truesite_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;site_uv_footer:# custom pv span for the whole sitesite_pv: truesite_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;site_pv_footer:# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: site/page_pv/uv_header 和 site/page_pv/uv_footer 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。 博客主题配置修改_config.yml文件打开NexT主题的根目录下的_config.yml文件，修改：1234leancloud_visitors: enable: true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 配置LeanCloud实际使用过程中LeanCloud已经改版，下面列出配置LeanCloud的过程。在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey这两个参数即可正常使用文章阅读量统计的功能了。 创建应用我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台，如下图所示： 在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的: 创建应用完成后，在应用列表中选择刚创建的HexoBlog应用，点击创建Class：在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。点击左侧右上角的齿轮图标，新建Class：在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:点击创建Class之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为Counter: 由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。 创建完成之后，点击设置，选择应用Key:在弹出的界面中，选择左侧的应用Key选项，即可发现我们创建应用的AppID以及AppKey，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了: 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:1234leancloud_visitors: enable: true app_id: zB9W7fUpG8e9iQF9I018I0bj-aaaaaaaa app_key: RkIarEbWMsL4NVGQPKkJaaaa 这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 设置 RSS安装 hexo-generator-feed在站点的根目录下执行以下命令：1$ npm install hexo-generator-feed --save 启用 RSS编辑 站点配置文件，新增以下内容到任意位置：123456789# RSS订阅支持plugin:- hexo-generator-feed# Feed Atomfeed:type: atompath: atom.xmllimit: 20 内容分享使用 JiaThis 作为内容分享服务，具体步骤如下：编辑 站点配置文件， 添加字段 jiathis，值为 true 即可。 搜索服务在站点的根目录下执行以下命令：1$ npm install hexo-generator-search --save 编辑 站点配置文件，新增以下内容到任意位置：12345search:path: search.xmlfield: postformat: htmllimit: 10000 背景效果介绍博客背景动态效果图和点击小红心效果的相关设置。 添加 JS 文件把 js 文件 love.js 和 particle.js 放在\themes\next\source\js\src文件目录下。 引用添加的 JS 文件更新\themes\next\layout\_layout.swig文件，在末尾（在前面引用会出现找不到的 bug）添加以下 js 引入代码：1234&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 图片模式新建博文新建博文，设置type: &quot;picture&quot;，使用{\% gp x-x \%} ... {\% endgp \%}标签引用要展示的图片地址，如下所示：12345678910111213141516---title: Naruto-Picturescategories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 999---&#123;% gp 5-3 %&#125;![](/images/post/18210.jpg)![](/images/post/196232.jpg)![](/images/post/224147.jpg)![](/images/post/199301.jpg)![](/images/post/213318.jpg)&#123;% endgp %&#125; 图片展示效果{\% gp 5-3 \%}：设置图片展示效果，参考 theme/next/scripts/tags/group-pictures.js 注释示意图。 修复图片展示主题目前首页可以正常显示步骤 8.2 设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 插件虽然使用比较简单，而且可以压缩图片，但是发现对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用第二种压缩手段。 hexo-all-minifier 配置使用安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 生产博文的时候就会自动压缩 HTML、JS、图片，详情参考插件介绍 gulp 插件配置使用hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：12345678910111213141516171819202122232425262728293031323334var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶修改 hexo-generator-index 插件替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：123456789---title: Naruto 图集categories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 10--- 头像圆形旋转头像圆形修改修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码：123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 头像循环旋转效果修改修改 sidebar-author.styl 文件，添加如下代码：12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码：12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125; 完整 sidebar-author.styl 文件参考地址。 参考文章： 【Hexo搭建独立博客全纪录】（一）使用Git和Github【Hexo搭建独立博客全纪录】（二）使用Markdown【Hexo搭建独立博客全纪录】（三）使用Hexo搭建博客如何用 Atom + GitHub 做知识管理]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QFileSystemModel的应用文件浏览器]]></title>
    <url>%2F2018%2F07%2F23%2FQFileSystemModel%E7%9A%84%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[QTreeView + QFileSystemModel rename的实现，qtreeview 参考文章：QTreeView + QFileSystemModel rename的实现，qtreeview 以前在写Markdown编辑器的时候, 写了一个基于QTreeView+QFileSystemModel的简单资源浏览器, 现在想给其增加一个rename的功能. 其实实现rename还是比较简单的, 首先在QTreeView中设置setEditTriggers(QAbstractItemView::EditKeyPressed);这样就可以按键盘上的F2来来进行rename. 但是如果想做成有一个右键菜单上有rename, 如下图: 那该怎么做呢. 这里需要加一个menu,当然并不是重点, 重点在于如何才会触发rename这个操作, 在前面我们设置好setEditTriggers之后按键盘F2是可以触发rename的.但是我们并不知道在按下F2之后发生了什么.当然我们可以完全不比理会按下F2之后发生了什么, 既然按下F2可以进行rename, 那么我们就产生一个按下F2的事件也是可以实现目的的代码片段如下: 123456789101112connect(menu_, &amp;ProjectExplorerMenu::signalRename, [this]()&#123; QString path = model_-&gt;filePath(currentIndex()); if(path.isNull()) &#123; qDebug() &lt;&lt; &quot;file path is null&quot;; return; &#125; //真逗比但有效... QKeyEvent event(QEvent::KeyPress, Qt::Key_F2, Qt::NoModifier); keyPressEvent(&amp;event);&#125;); 这里面当menu选中rename这一项的时候发出signalRename的信号, 在对应的槽中实例化了一个QKeyEvent对象, 并将其key设置为Qt::key_F2, 即产按下F2的这个事件, 然后把这个事件传给处理键盘按下的事件过滤器keyPressEvent. 就此目标实现. 但是这样做并不是太干净,想做得更干净一点可以查QTreeView的源码. 在QTreeView的keyPressEvent中: 123456789101112131415161718192021222324252627282930313233void QTreeView::keyPressEvent(QKeyEvent *event)&#123; Q_D(QTreeView); QModelIndex current = currentIndex(); //this is the management of the expansion if (d-&gt;isIndexValid(current) &amp;&amp; d-&gt;model &amp;&amp; d-&gt;itemsExpandable) &#123; switch (event-&gt;key()) &#123; case Qt::Key_Asterisk: &#123; QStack&lt;QModelIndex&gt; parents; parents.push(current); while (!parents.isEmpty()) &#123; QModelIndex parent = parents.pop(); for (int row = 0; row &lt; d-&gt;model-&gt;rowCount(parent); ++row) &#123; QModelIndex child = d-&gt;model-&gt;index(row, 0, parent); if (!d-&gt;isIndexValid(child)) break; parents.push(child); expand(child); &#125; &#125; expand(current); break; &#125; case Qt::Key_Plus: expand(current); break; case Qt::Key_Minus: collapse(current); break; &#125; &#125; QAbstractItemView::keyPressEvent(event);&#125; 代码很简单没几行, 处理了按下键盘上+,-,*三个按键. +号展开, -号收缩, *号递归展开其他的键盘事件扔给其基类去处理(不看代码我都不知道原来已经有这样的处理……..), 再来看看QAbstractItemView中对F2做了什么特别的处理这里代码就比较多了有几百行, 代码虽长但是F2处理的部分还是很简单的: 123456789101112void QAbstractItemView::keyPressEvent(QKeyEvent *event)&#123; ... switch (event-&gt;key()) &#123; case Qt::Key_F2: if (!edit(currentIndex(), EditKeyPressed, event)) event-&gt;ignore(); break; ... &#125; ...&#125; 原来按下F2的时候是使用了edit这个函数来进行处理的, 由此修改我们之前直接生成一个QKeyEvent实例并传递给keyPressEvent的代码可以更改为: 1234567891011connect(menu_, &amp;ProjectExplorerMenu::signalRename, [this]()&#123; QString path = model_-&gt;filePath(currentIndex()); if(path.isNull()) &#123; qDebug() &lt;&lt; &quot;file path is null&quot;; return; &#125; QKeyEvent event(QEvent::KeyPress, Qt::Key_F2, Qt::NoModifier); edit(currentIndex(), EditKeyPressed, &amp;event);&#125;); 呵呵很多时候文档里面没查到的东西, 看看代码就知道了, 源码之下无秘密! QFileSystemModel QDirModel 示例代码，使用方法 参考文章：QFileSystemModel QDirModel 示例代码， 使用方法 QFileSystemModel 查看，添加和删除目录 实现代码dialog.h 123456789101112131415161718192021222324#ifndef DIALOG_H #define DIALOG_H #include &lt;QDialog&gt; #include &lt;QtGui&gt; class Dialog : public QDialog &#123; Q_OBJECT public: Dialog(QWidget *parent = 0); private slots: void createDirectory(); void remove(); private: QFileSystemModel *model; QTreeView *treeView; &#125;; #endif // DIALOG_H dialog.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;dialog.h&quot; Dialog::Dialog(QWidget *parent) : QDialog(parent) &#123; setWindowTitle(&quot;QFileSystemModel&quot;); model = new QFileSystemModel; model-&gt;setReadOnly(false); model-&gt;setRootPath(QDir::currentPath()); treeView = new QTreeView; treeView-&gt;setModel(model); treeView-&gt;header()-&gt;setStretchLastSection(true); treeView-&gt;header()-&gt;setSortIndicator(0, Qt::AscendingOrder); treeView-&gt;header()-&gt;setSortIndicatorShown(true); treeView-&gt;header()-&gt;setClickable(true); QModelIndex index = model-&gt;index(QDir::currentPath()); treeView-&gt;expand(index); treeView-&gt;scrollTo(index); treeView-&gt;resizeColumnToContents(0); QPushButton *createButton = new QPushButton(tr(&quot;Create Dir&quot;)); QPushButton *removeButton = new QPushButton(tr(&quot;Remove Dir&quot;)); connect(createButton, SIGNAL(clicked()), this, SLOT(createDirectory())); connect(removeButton, SIGNAL(clicked()), this, SLOT(remove())); QHBoxLayout *hLayout = new QHBoxLayout; hLayout-&gt;addWidget(createButton); hLayout-&gt;addWidget(removeButton); QVBoxLayout *vLayout = new QVBoxLayout; vLayout-&gt;addWidget(treeView); vLayout-&gt;addLayout(hLayout); setLayout(vLayout); &#125; void Dialog::createDirectory() &#123; QModelIndex index = treeView-&gt;currentIndex(); if( !index.isValid() ) return; QString dirName = QInputDialog::getText(this, tr(&quot;create Dir&quot;), tr(&quot;Dir name&quot;)); if( !dirName.isEmpty() ) &#123; if( !model-&gt;mkdir(index, dirName).isValid() ) QMessageBox::information(this, tr(&quot;Create Dir&quot;), tr(&quot;Failed to create Dir&quot;)); &#125; &#125; void Dialog::remove() &#123; QModelIndex index = treeView-&gt;currentIndex(); if( !index.isValid() ) return; bool ok; if( model-&gt;fileInfo(index).isDir() ) ok = model-&gt;rmdir(index); else ok = model-&gt;remove(index); if(!ok) QMessageBox::information(this, tr(&quot;Remove&quot;), tr(&quot;Failed to remove Dir&quot;).arg(model-&gt;fileName(index))); &#125; main.cpp 123456789101112#include &quot;dialog.h&quot; #include &lt;QApplication&gt; int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); Dialog w; w.setSizeIncrement(400,300); w.show(); return a.exec(); &#125; A Cross-platform Faster File System Model than QFileSystemModel 参考文章：A Cross-platform Faster File System Model than QFileSystemModel BackgroundYou know that, QDirModel is obsolete and Qt recommend to use QFileSystemModel. However, QFileSystemModel is not fast enough as windows explorer. Here I will create an explorer as fast as windows explorer. Model Related ClassesFileSystemItem: This class represent an item (dir/file/folder) in the model. Here source listing of this class. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &quot;filesystemmodel.h&quot;#include &lt;QDir&gt;#include &lt;QFileIconProvider&gt;#include &lt;QDateTime&gt;#define SEPARATOR QString(&quot;/&quot;)// This class represents a row in FileSystemModelclass FileSystemItem&#123;public: FileSystemItem(const QFileInfo&amp; fileInfo,FileSystemItem* parent = 0) &#123; mParent = parent; mFileInfo = fileInfo; if(parent)&#123; parent-&gt;addChild(this); // NOTE: absoluteFilePath method of QFileInfo class cause the file system // query hence causes slower performance, We are going to keep the // absolutepath of an item. Absolute path means the absolute path of parent // plus a separator plus filename of this item. if(0 == parent-&gt;parent())&#123; // for drives, there is no filename, so we used canonicalPath mAbsFilePath = fileInfo.canonicalPath(); &#125; else&#123; mAbsFilePath = parent-&gt;absoluteFilePath() + SEPARATOR + fileInfo.fileName(); &#125; &#125; else&#123; // Path of root item, which is not visible; mAbsFilePath = &quot;&quot;; &#125; &#125; ~FileSystemItem() &#123; qDeleteAll(mChildren); &#125; FileSystemItem* childAt(int position) &#123; return mChildren.value(position,0); &#125; int childCount() const &#123; return mChildren.count(); &#125; // returns the position of this son among his siblings int childNumber() const &#123; if (mParent)&#123; return mParent-&gt;mChildren.indexOf(const_cast&lt;FileSystemItem*&gt;(this)); &#125; return 0; &#125; FileSystemItem* parent() &#123; return mParent; &#125; QString absoluteFilePath()const &#123; return mAbsFilePath; &#125; QString fileName()const &#123; if(mParent)&#123; // for drives, there is no filename, so we used canonicalPath if(0 == mParent-&gt;parent())&#123; return mFileInfo.canonicalPath(); &#125; else&#123; return mFileInfo.fileName(); &#125; &#125; return &quot;&quot;; &#125; QFileInfo fileInfo()const &#123; return mFileInfo; &#125; void addChild(FileSystemItem *child) &#123; if(!mChildren.contains(child))&#123; mChildren.append(child); &#125; &#125; // This is a recursive method which tries to match a path to a specifiq // FileSystemItem item which has the path; // Here startIndex is the position of the separator FileSystemItem* matchPath(const QStringList&amp; path, int startIndex = 0) &#123; foreach(FileSystemItem* child, mChildren)&#123; QString match = path.at(startIndex); if(child-&gt;fileName() == match)&#123; if(startIndex + 1 == path.count())&#123; return child; &#125; else&#123; return child-&gt;matchPath(path,startIndex + 1); &#125; &#125; &#125; return 0; &#125;private: FileSystemItem* mParent; QList&lt;FileSystemItem*&gt; mChildren; QFileInfo mFileInfo; QString mAbsFilePath;&#125;;// End of FileSystemItem class FileSystemModel: This class is the Model itself. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266class FileSystemModel : public QAbstractItemModel&#123;Q_OBJECTpublic: enum Column&#123;NAME, SIZE, TYPE, DATE, LASTCOLUMN&#125;;FileSystemModel(QObject* parent) : QAbstractItemModel(parent),mIconFactory(new QFileIconProvider())&#123; // Now it is time to fix the headers mHeaders &lt;&lt; &quot;Name&quot; &lt;&lt; &quot;Size&quot; &lt;&lt; &quot;Type&quot; &lt;&lt; &quot;Date Modified&quot;; // Create the root item [NOTE: Root item is not visible, but is the parent // of all drives] mRootItem = new FileSystemItem(QFileInfo(),0); mCurrentPath = &quot;&quot;; QFileInfoList drives = QDir::drives(); foreach(QFileInfo drive, drives)&#123; new FileSystemItem(drive,mRootItem); &#125;&#125;~FileSystemModel()&#123; delete mRootItem; delete mIconFactory;&#125;QVariant headerData(int section, Qt::Orientation orientation, int role) const&#123; if(orientation == Qt::Horizontal)&#123; switch(role)&#123; // in case of DisplayRole, just return the header text case Qt::DisplayRole: return mHeaders.at(section); break; // in case of TextAlignmentRole, only SIZE column will be right align, // others will be left align case Qt::TextAlignmentRole: return int(SIZE) == section ? Qt::AlignRight : Qt::AlignLeft; break; &#125; &#125; return QVariant();&#125;Qt::ItemFlags flags(const QModelIndex &amp;index) const&#123; if (!index.isValid()) return 0; // Our model is read only. return Qt::ItemIsEnabled | Qt::ItemIsSelectable;&#125;int columnCount(const QModelIndex &amp; /* parent */) const&#123; return LASTCOLUMN; // here it is; 4.&#125;int rowCount(const QModelIndex &amp;parent) const&#123; FileSystemItem *parentItem = getItem(parent); return parentItem-&gt;childCount();&#125;QVariant data(const QModelIndex &amp;index, int role) const&#123; // invalid work, invalid return if (!index.isValid())&#123; return QVariant(); &#125; // in case of TextAlignmentRole, only SIZE column will be right align, // others will be left align if(int(SIZE) == index.column() &amp;&amp; Qt::TextAlignmentRole == role)&#123; return Qt::AlignRight; &#125; // At present, I don&apos;t want pay attention other than DisplayRole &amp; DecorationRole if (role != Qt::DisplayRole &amp;&amp; role != Qt::DecorationRole)&#123; return QVariant(); &#125; FileSystemItem *item = getItem(index); if(!item)&#123; return QVariant(); &#125; // if the role is for decoration &amp; column is zero, we send the item&apos;s icon if(role == Qt::DecorationRole &amp;&amp; index.column() == int(NAME) )&#123; return mIconFactory-&gt;icon(item-&gt;fileInfo()); &#125; QVariant data; Column col = Column(index.column()); switch(col)&#123; case NAME: data = item-&gt;fileName(); break; case SIZE: if(item-&gt;fileInfo().isDir())&#123; data = &quot;&quot;; // we don&apos;t want to show zero. &#125; else&#123; data = item-&gt;fileInfo().size(); &#125; break; case TYPE: data = mIconFactory-&gt;type(item-&gt;fileInfo()); break; case DATE: data = item-&gt;fileInfo().lastModified().toString(Qt::LocalDate); break; default: data = &quot;&quot;; break; &#125; return data;&#125;QModelIndex index(int row, int column, const QModelIndex &amp;parent) const&#123; // As the NAME column is a tree, we will only create index which parent is NAME column if (parent.isValid() &amp;&amp; parent.column() != int(NAME)) return QModelIndex(); FileSystemItem *parentItem = getItem(parent); // if there is a parent index, we want to work if(parentItem)&#123; FileSystemItem *childItem = parentItem-&gt;childAt(row); if (childItem)&#123; return createIndex(row, column, childItem); &#125; &#125; return QModelIndex();&#125;QModelIndex index(const QString&amp; path, int column) const&#123; if(path.length() &gt; 0)&#123; FileSystemItem *item = mRootItem-&gt;matchPath(path.split(SEPARATOR)); if(item)&#123; return createIndex(item-&gt;childNumber(),column,item); &#125; &#125; return QModelIndex();&#125;QModelIndex parent(const QModelIndex &amp;index) const&#123; // invalid work, invalid return if(!index.isValid())&#123; return QModelIndex(); &#125; FileSystemItem* childItem = getItem(index); // If there is no child, there is no index if(!childItem)&#123; return QModelIndex(); &#125; FileSystemItem *parentItem = childItem-&gt;parent(); // if there is no parent or parent is invisible, there is no index if (!parentItem || parentItem == mRootItem)&#123; return QModelIndex(); &#125; return createIndex(parentItem-&gt;childNumber(), NAME, parentItem);&#125;bool isDir(const QModelIndex &amp;index)&#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item &amp;&amp; item != mRootItem)&#123; return item-&gt;fileInfo().isDir(); &#125; return false;&#125;// NOTE: absoluteFilePath method of QFileInfo class cause the file system// query hence causes slower performance, We are going to keep the// absolutepath of an item. Absolute path means the absolute path of parent// plus a separator plus filename of this item.QString absolutePath(const QModelIndex &amp;index)&#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item &amp;&amp; item != mRootItem)&#123; return item-&gt;absoluteFilePath(); &#125; return &quot;&quot;;&#125;QString currentPath()const&#123; return mCurrentPath;&#125;QModelIndex setCurrentPath(const QString&amp; path)&#123; mCurrentPath = path; // find the file system item FileSystemItem *item = mRootItem-&gt;matchPath(path.split(SEPARATOR)); // if there is a item and item&apos;s child is zero, we are going to find the // entries in the directory if(item &amp;&amp; item != mRootItem &amp;&amp; item-&gt;childCount() == 0)&#123; populateItem(item); &#125; return index(path);&#125;private:void populateItem(FileSystemItem *item)&#123; QDir dir(item-&gt;absoluteFilePath()); QFileInfoList all = dir.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot); // loop through all the item and construct the childs foreach(QFileInfo one, all)&#123; new FileSystemItem(one,item); &#125;&#125;FileSystemItem *getItem(const QModelIndex &amp;index) const&#123; // just return the internal pointer we set at creating index if the index is valid if(index.isValid()) &#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item) &#123; return item; &#125; &#125; return mRootItem;&#125;private: FileSystemItem* mRootItem; QString mCurrentPath; QStringList mHeaders; QFileIconProvider* mIconFactory;&#125;; FileSystemSortProxyModel: Sort/Proxy Model 123456789101112131415161718192021222324252627class FileSystemSortProxyModel : public QSortFilterProxyModel&#123;Q_OBJECTpublic:FileSystemSortProxyModel(QObject *parent) : QSortFilterProxyModel(parent)&#123;&#125;protected:bool lessThan(const QModelIndex &amp;left, const QModelIndex &amp;right) const&#123; FileSystemModel* fsModel = dynamic_cast&lt;FileSystemModel*&gt;(sourceModel()); // To keep the the folder always on the up, we need to do the followings // while the compare indice are folder &amp; file exclusively. if(fsModel)&#123; if((fsModel-&gt;isDir(left) &amp;&amp; !fsModel-&gt;isDir(right)))&#123; return sortOrder() == Qt::AscendingOrder; &#125; else if( (!fsModel-&gt;isDir(left) &amp;&amp; fsModel-&gt;isDir(right)))&#123; return sortOrder() == Qt::DescendingOrder; &#125; &#125; return QSortFilterProxyModel::lessThan(left,right);&#125;&#125;; View classDirBrowser: Now the view class. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class DirBrowser : public QTableView&#123;Q_OBJECTpublic:DirBrowser(QWidget *parent) : QTableView(parent)&#123; grabKeyboard(); /* IMPORTANT Construct the QFileSystemModel. This is relatively faster that QDirModel. ****** TODO ****** However, QFileSystemModel is not fast enough as windows system explorer. We have to consider platform specifiq API in this case, like FindFirstFile or FindFirstFileEx with looping FindNextFile. In this case we have to completely make a View class to show contents on this. I have worked with this APIs at past, yet need some R&amp;D&apos;s on this. In this case, there are challenges like finding the item&apos;s icon &amp; item&apos;s text color. */ //mFSModel = new QFileSystemModel(this); mFSModel = new FileSystemModel(this); //mFSModel-&gt;setRootPath(QDir::currentPath()); // This will populate the filesystem mSortModel = new FileSystemSortProxyModel(this); mSortModel-&gt;setSourceModel(mFSModel); this-&gt;setShowGrid(false); this-&gt;verticalHeader()-&gt;hide(); this-&gt;setModel(mSortModel); this-&gt;setSortingEnabled(true); /* Now, binds the necessary signals &amp; corresponding slots. One thing ro remember is that, we are the setting the signal ConnectionType to AutoConnection (default). So if a signal is emitted in another thread, yet the slot will run on invoked objects thread. */ // Binds the doubleClicked signal to handleDirItemDoubleClicked slot of this class connect(this,SIGNAL(doubleClicked(QModelIndex)),SLOT(handleDirItemDoubleClicked(QModelIndex)));&#125;private slots:void handleDirItemDoubleClicked(const QModelIndex &amp;index)&#123; if(mFSModel-&gt;isDir(mSortModel-&gt;mapToSource(index)))&#123; updateCurrentPath(index); &#125;&#125;protected:void keyPressEvent(QKeyEvent *e)&#123; // if bakcspace key is pressed, view the dir browser to updates // parent folder if(e-&gt;key() == Qt::Key_Backspace)&#123; // If parent model-index is valid, up one level; Otherwise // back to topmost level if(this-&gt;rootIndex().parent().isValid())&#123; updateCurrentPath(this-&gt;rootIndex().parent()); &#125; else&#123; this-&gt;setRootIndex(mSortModel-&gt;mapFromSource(mFSModel-&gt;setCurrentPath(&quot;&quot;))); &#125; &#125;&#125;private:void updateCurrentPath(const QModelIndex &amp;index)&#123; if(index.isValid())&#123; // update the model for current path mFSModel-&gt;setCurrentPath(mFSModel-&gt;absolutePath(mSortModel-&gt;mapToSource(index))); // update the view as necessarily this-&gt;setRootIndex(mSortModel-&gt;mapFromSource(mFSModel-&gt;index(mFSModel-&gt;currentPath()))); &#125;&#125;private: FileSystemModel* mFSModel; FileSystemSortProxyModel* mSortModel;&#125;; How to make “Browse for folder” dialog? 参考文章：How to make “Browse for folder” dialog? I’m trying to make a folder selection dialog which looks like this: The images come from this thread: can the Open File dialog be used to select a Folder? I tried both QFileDialog::getExistingDirectory() and making an instance of QFileDialog and setting the properties. It just shows the Open File dialog with hidden files. Header file: 12345678910111213141516171819202122232425#pragma once#include &lt;QtWidgets/QDialog&gt;class QTreeView;class QFileSystemModel;class QLineEdit;class QPushButton;class CDirSelectionDlg : public QDialog &#123; Q_OBJECTpublic: CDirSelectionDlg(const QString initialPath, QWidget *parent = nullptr); QDir directory() const;private: void onCurrentChanged(); QTreeView *m_treeView; QFileSystemModel *m_model; QLineEdit *m_folderName; QPushButton *m_OKbutton; QString m_initialPath;&#125;; Source file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;DirSelectionDlg.h&quot;#include &lt;QLabel&gt;#include &lt;QBoxLayout&gt;#include &lt;QDialogButtonBox&gt;#include &lt;QTreeView&gt;#include &lt;QFileSystemModel&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;CDirSelectionDlg::CDirSelectionDlg(const QString initialPath, QWidget *parent) : QDialog(parent), m_initialPath(initialPath)&#123; setMinimumSize(200, 300); resize(400, 430); m_model = new QFileSystemModel(this); auto rootIdx = m_model-&gt;setRootPath(m_initialPath); m_treeView = new QTreeView(this); m_treeView-&gt;setModel(m_model); m_treeView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); m_treeView-&gt;setHeaderHidden(true); m_treeView-&gt;setSortingEnabled(true); m_treeView-&gt;sortByColumn(0, Qt::AscendingOrder); for(int i = 1; i &lt; m_model-&gt;columnCount(); i ++) // don&apos;t show Size, Type, etc. m_treeView-&gt;setColumnHidden(i, true); m_treeView-&gt;scrollTo(rootIdx); m_treeView-&gt;selectionModel()-&gt;setCurrentIndex(rootIdx, QItemSelectionModel::Current | QItemSelectionModel::Select); connect(m_treeView-&gt;selectionModel(), &amp;QItemSelectionModel::selectionChanged, this, &amp;CDirSelectionDlg::onCurrentChanged); auto buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel); connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;CDirSelectionDlg::accept); connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;CDirSelectionDlg::reject); m_OKbutton = buttonBox-&gt;button(QDialogButtonBox::Ok); auto label = new QLabel(tr(&quot;Folder:&quot;)); m_folderName = new QLineEdit(this); m_folderName-&gt;setReadOnly(true); m_folderName-&gt;setText(QFileInfo(m_initialPath).fileName()); auto pathLayout = new QHBoxLayout(); pathLayout-&gt;addWidget(label); pathLayout-&gt;addSpacing(10); pathLayout-&gt;addWidget(m_folderName); auto mainLayout = new QVBoxLayout(); mainLayout-&gt;addWidget(m_treeView); mainLayout-&gt;addSpacing(10); mainLayout-&gt;addLayout(pathLayout); mainLayout-&gt;addSpacing(10); mainLayout-&gt;addWidget(buttonBox); setLayout(mainLayout);&#125;void CDirSelectionDlg::onCurrentChanged()&#123; auto fileInfo = m_model-&gt;fileInfo(m_treeView-&gt;selectionModel()-&gt;currentIndex()); m_folderName-&gt;setText(fileInfo.fileName()); m_OKbutton-&gt;setEnabled(fileInfo.isDir()); m_OKbutton-&gt;setDefault(fileInfo.isDir());&#125;QDir CDirSelectionDlg::directory() const&#123; return QDir(m_model-&gt;fileInfo(m_treeView-&gt;selectionModel()-&gt;currentIndex()).absoluteFilePath());&#125; QTreeView和QFileSystemModel 参考文章：QTreeView和QFileSystemModel 用Qt来显示一个文件目录是很简单的，如下：例子1：查找显示所有的图片 12345678910111213141516QFileSystemModel *model = new QFileSystemModel(); model-&gt;setRootPath(&quot;/&quot;); //model-&gt;setFilter(QDir::Dirs|QDir::NoDotAndDotDot); //只显示文件夹 // 设置过滤器 QStringList filter; filter &lt;&lt; &quot;*.png&quot; &lt;&lt; &quot;*.jpg&quot; &lt;&lt; &quot;*.bmp&quot; &lt;&lt; &quot;*.gif&quot;; model-&gt;setNameFilters(filter); // 没有通过过滤器的文件disable还是隐藏,true为disable false为隐藏 model-&gt;setNameFilterDisables(false); mTreeView = new QTreeView(); mTreeView-&gt;setAnimated(false); mTreeView-&gt;setSortingEnabled(true); mTreeView-&gt;setModel(model); QDirModel已经不建议使用了，应使用QFileSystemModel 设置一些特殊属性的过滤 setFilter 如只显示文件夹或系统文件 显示项的名字过滤器这个非常有用，如我们想显示所有的”png,jpg,bmp,gif”图片 setNameFilterDisables这个效果如下图： setNameFilterDisables(false)表示不符合名字过滤要求的隐藏而不是disable 例子2：创建一个简单的可以添加文件夹删除文件夹的资源管理 实现也很简单： 1234567891011121314151617181920212223242526model = new QFileSystemModel(); model-&gt;setRootPath(QDir::currentPath()); mTreeView = new QTreeView(); mTreeView-&gt;setAnimated(false); mTreeView-&gt;setSortingEnabled(true); mTreeView-&gt;setModel(model); mTreeView-&gt;setRootIndex(model-&gt;index(QDir::currentPath())); QPushButton* mkdirButton = new QPushButton(tr(&quot;Make directory&quot;), this); QPushButton* rmButton = new QPushButton(tr(&quot;Remove&quot;), this); QHBoxLayout* buttonLayout = new QHBoxLayout; buttonLayout-&gt;addWidget(mkdirButton); buttonLayout-&gt;addWidget(rmButton); QVBoxLayout* layout = new QVBoxLayout(); layout-&gt;addWidget(mTreeView); layout-&gt;addLayout(buttonLayout); setLayout(layout); setWindowTitle(&quot;File system...&quot;); resize(960,640); //connect(mTreeView, SIGNAL(doubleClicked(QModelIndex)), this, SLOT(on_treeView_doubleClicked(QModelIndex))); connect(mkdirButton, SIGNAL(clicked()), this, SLOT(mkdir())); connect(rmButton, SIGNAL(clicked()), this, SLOT(rm())); 添加目录： 1234567891011121314151617void Dialog::mkdir() &#123; QModelIndex index = mTreeView-&gt;currentIndex(); if ( !index.isValid() ) &#123; return; &#125; QString name = QInputDialog::getText(this, tr(&quot;Create directory&quot;), tr(&quot;Directory name&quot;)); if ( !name.isEmpty() ) &#123; if ( !model-&gt;isDir(index) ) &#123; index = model-&gt;parent(index); &#125; if ( !model-&gt;mkdir(index, name).isValid() ) &#123; QMessageBox::information(this, tr(&quot;Create directory failed...&quot;), tr(&quot;Failed to create directory&quot;)); &#125; &#125; &#125; 删除目录和文件 12345678910111213141516171819void Dialog::rm() &#123; QModelIndex index = mTreeView-&gt;currentIndex(); if ( !index.isValid() ) &#123; return; &#125; bool ok; QFileInfo info = model-&gt;fileInfo(index); if ( info.isDir() ) &#123; ok = model-&gt;rmdir(index); &#125; else &#123; ok = model-&gt;remove(index); &#125; if ( !ok ) &#123; QMessageBox::information(this, tr(&quot;Removed&quot;), tr(&quot;Filed to remove %1&quot;).arg(model-&gt;fileName(index))); &#125; &#125; GitHub上的开源项目 file-browser]]></content>
      <categories>
        <category>Qt - Gui</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Qt中实现QThread线程同步QFtp]]></title>
    <url>%2F2018%2F07%2F23%2FQt%E4%B8%AD%E5%AE%9E%E7%8E%B0QThread%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5QFtp%2F</url>
    <content type="text"><![CDATA[Qt中实现QThread线程同步QFtp 参考文章：Qt中实现QThread线程同步QFtp 在Qt中实现QThread线程同步QFtp ，对于QFtp，它是一个用来实现FTP协议的类，详情查阅资料。接触Qt没有多长时间，但简单几个小例子已经让我感受到Qt在C++运用方面的强大。写了一个小程序，需要在一个单独的线程中使用QFtp来获取FTP服务器上面的文件。FTP是FileZilla。 有两个问题我比较关心： QThread到底如何使用 QFtp是Async（异步）操作，也就是说例如connectToHost这样的函数都是立刻返回，当操作完成后QFtp会发出signal。然而既然我的Ftp操作是在一个单独的线程，我想写一个函数downloadFtpFile() 来完成从connect到login到下载文件等一系列的操作，然后再返回。相当于我需要Sync（同步）的操作，所以需要等待（block）每个Ftp命令的结果。 在该文章最后有一个推荐的使用QThread的方法。我在这里想补充一点：obj.moveToThread(&amp;thread); 这句话将obj从主线程移动到了thread对象所在的线程。但如果obj的对象里面有其他的变量，那么这些变量是在主线程中生成的。所以如果这些变量中有类变量，不能将obj的this指针作为parent传给他们。 对于第二个问题，我使用了QSemaphore类来完成我的block和同步操作：在slot函数里面接收QFtp命令执行结果的signal，释放信号，同时downloadFtpFile()函数里在调用完每一个QFtp异步命令后等待信号。在有点令人失望的是QSemaphore在通过tryAcquire()等待信号的时候是不处理事件event的。但是我需要在等待的时候程序也能触发slot，告诉我当前命令的执行情况。所以我使用了一个小循环，里面调用qApp-&gt;processEvents();来让我的slot函数被触发。下面是代码例子（只是样例，并不完全符合C++语法）： 首先是我的下载Ftp文件的函数： 12345678910111213141516171819202122232425262728293031323334353637383940downloadFtpFile() //该函数在单独线程里执行 &#123; int m_idFtpOp; // 该变量用来存放每一个QFtp命令ID int nVal; QFtp*pFtp = newQFtp(this); // 生成QFtp工具对象 connect(pFtp, SIGNAL(listInfo(QUrlInfo)), this, SLOT(slotFtpListInfo(QUrlInfo))); // 我们需要listinfo，因为我们需要下载ftp所有当前目录文件 connect(pFtp, SIGNAL(commandFinished(int, bool)), this, SLOT(slotFtpCmdFinished(int, bool))); // 每个QFtp命令完成之后，会发出commandFinished信号，我们在槽函数中处理该信号 m_idFtpOp = pFtp-&gt;connectToHost(&lt;FTP地址&gt;, 21); // 连接到远程FTP Server bRet = false; nVal = 100; while (bRet == false) // 使用nVal变量来做一个10000ms（10s）的超时 &#123; nVal--; if (nVal == 0) break; qApp-&gt;processEvents(); // 这里每100ms处理一次event，使slot函数能够被调用 bRet = m_SemOp.tryAcquire(1, 100); // 等待信号100ms &#125; if (!bRet || m_bFtpOpError) // 如果超时，或者slot函数中将m_bFtpOpError置成true，则关闭Ftp，返回错误 &#123; pFtp-&gt;abort(); pFtp-&gt;deleteLater(); return ERRCODE_FCC_FTP_CONN_TIMEOUT; &#125;&#125;下面是槽函数slotFtpCmdFinished(int id, bool error)&#123; if (m_idFtpOp == id) // 如果返回的id是当前正在操作的命令 &#123; if (error) m_bFtpOpError = true; else m_bFtpOpError = false; m_SemOp.release(); // 释放信号（使downloadFtpFile函数中m_SemOp.tryAcquire()返回true） &#125;&#125; 以上的代码只演示了对QFtp第一个命令connectToHost的等待过程。下面的login，list，get等操作都使用这个方法。 注意：在此例中，QFtp是在当前线程生成的，所以信号listInfo(QUrlInfo)的connect方式是direct连接。如果QFtp是在另一个线程生成（比如说是在函数downloadFtpFile所在类的构造函数中），那么第一：不能将this指针作为parent传给QFtp对象，第二：需要使用qRegisterMetaType(“QUrlInfo”);来注册QUrlInfo类，因为信号发射与接收在不通的线程中，信号使用queued的方式。如果不注册QURlInfo类，会在运行时动态报告错误。 总结：本文介绍的是在Qt中如何实现QThread线程同步QFtp ，看过本文之后，如果对于QThread不了解的话，那么请参考Qt中QThread使用方法这篇文章。使用本文介绍的方法，可以在独立的线程中用同步的方式使用QFtp。在某些场合，尤其是采用应答机制的系统中，这样的实现可以很大程度上简化程序流程。]]></content>
      <categories>
        <category>Qt - 网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IPC研究之QLocalServer和QLocalSocket]]></title>
    <url>%2F2018%2F07%2F23%2FIPC%E7%A0%94%E7%A9%B6%E4%B9%8BQLocalServer%E5%92%8CQLocalSocket%2F</url>
    <content type="text"><![CDATA[IPC研究之QLocalServer和QLocalSocket 参考文章：IPC研究之QLocalServer和QLocalSocket 在Qt中，提供了多种IPC方法，作者所用的是QLocalServer和QLocalSocket。看起来好像和Socket搭上点边，实则底层是windows的name pipe。这应该是支持双工通信的。 QLocalServer用来监听某个管道。可以这样建立一个监听 12345678910111213141516171819202122232425262728QLocalServer *localServer;localServer = new QLocalServer(this);localServer-&gt;setMaxPendingConnections(MAX_CONNECTION);if (localServer-&gt;listen(&quot;commandpipe&quot;))&#123; qDebug() &lt;&lt; &quot;listen commandpipe namepipe sucessful.&quot;;&#125;else&#123; qDebug() &lt;&lt; &quot;failed to listen commandpipe. &quot;;&#125;connect(localServer, SIGNAL(newConnection()), this, SLOT(DealConnection()));void IPCServer::DealConnection()&#123; QLocalSocket *socket = localServer-&gt;nextPendingConnection(); socket-&gt;waitForReadyRead(); QDataStream ds(socket); ds.setVersion(QDataStream::Qt_4_6); QString qstr; ds &gt;&gt; qstr; qDebug() &lt;&lt; &quot;Server received: &quot; &lt;&lt; qstr; qDebug() &lt;&lt; &quot;Server processing...&quot;; ds &lt;&lt; qstr.append(&quot; processed&quot;); qDebug() &lt;&lt; &quot;Server send &quot; &lt;&lt; qstr;&#125; 在这里主要采用的是QDataStream读取socket是的内容。读取完了之后，又使用这个socket再把内容转发回去。 12345678910111213QLocalSocket这一块包含连接，和发送信息这一块。QLocalSocket _socket = new QLocalSocket(this);_socket-&gt;connectToServer(&quot;commandpipe&quot;);qDebug() &lt;&lt; &quot;socket connect to namepipe&quot;;QDataStream ds(_socket);ds.setVersion(QDataStream::Qt_4_6);ds &lt;&lt; QString(&quot;hello&quot;);_socket-&gt;waitForBytesWritten();qDebug() &lt;&lt; &quot;send one command&quot;;_socket-&gt;waitForReadyRead();QString bbq;ds &gt;&gt; bbq;qDebug() &lt;&lt; &quot;received servered &quot; &lt;&lt; bbq; 注意，这边我一开始发送的时候是使用的发送char *，但接收的时候却是用QString，结果就不对了。因为QString是unicode编码的。所以出错了。不过现在己经正常了。。。。现在Shark中的Service，IPC，都己经走通了。下面主要还有编码格式，QWebKit模块，数据库模块需要完成。]]></content>
      <categories>
        <category>Qt - 网络</category>
      </categories>
  </entry>
</search>
