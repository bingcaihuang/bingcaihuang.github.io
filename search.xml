<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[QT线程池实验研究与分析（QThread与和QThreadPool + QRunnable使用上的区别）]]></title>
    <url>%2F2018%2F11%2F23%2FQT%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E9%AA%8C%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%88QThread%E4%B8%8E%E5%92%8CQThreadPool-QRunnable%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[QT线程池实验研究与分析（QThread与和QThreadPool + QRunnable使用上的区别） QT线程池实验研究与分析（QThread与和QThreadPool + QRunnable使用上的区别） QT线程池的构建与使用网上关于QT线程池QThreadPool的文章很多，而且大都千篇一律，基本上都是参考QT的帮助文档介绍QT全局线程池的用法。这样就往往会使人产生误解，QT是不是推荐大家使用其全局线程池，而不推荐使用自定义构造的线程池？ 实际情况并不是这样的。而且在实际的项目当中我们通常并不希望仅仅使用一个全局的线程池，而是在需要线程池的工程中都构建和维护自己一个小小的线程池（我们知道一个良好架构的项目通常是由多个工程组成的）。综上，我们来分析以下两个问题： (1)非全局的线程池如果构建与使用呢？12345678910111213141516171819202122232425262728293031#include &lt;QObject&gt;#include &lt;QRunnable&gt;#include &lt;QThread&gt;#include &lt;QThreadPool&gt;#include &lt;QDebug&gt;class HelloWorldTask : public QRunnable&#123; // 线程执行任务：每间隔1s打印出线程的信息 void run() &#123; for (int nCount = 0; nCount &lt; 5; nCount++) &#123; qDebug() &lt;&lt; QThread::currentThread(); QThread::msleep(1000); &#125; &#125;&#125;;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); QThreadPool threadpool; // 构建一个本地的线程池 threadpool.setMaxThreadCount(3); // 线程池中最大的线程数 for (int nNum = 0; nNum &lt; 100; nNum++) &#123; HelloWorldTask *task; // 循环构建可在线程池中运行的任务 threadpool.start(task); //线程池分配一个线程运行该任务 QThread::msleep(1000); &#125; return a.exec();&#125; 上述程序，构建了一个线程最大数量为3的本地线程池。每间隔1s的时间创建一个线程任务并置入到线程池的任务队列中（QT内部机制实现该队列，我们只需要调用QThreadPool的start函数置入即可）。每个线程任务的持续时间为5s。 (2)程序当中QRunnable是以指针的形式创建的，该指针是需要程序员去释放，还是QThreadPool在运行完线程后自动释放？解答：在上述例子当中，我们创建的QRunnable类型的指针 QRunnable *task 是不需要我们手动去回收内存的，QThreadPool在结束该任务的执行后会将对该内存进行清空。 上述解答并不是凭空猜测，一方面根据是QT文档中的一句话：QThreadPool takes ownership and deletes ‘hello’automatically 用直白的话说就是：QThreadPool会占有这个指针的句柄并在运行结束后释放指针所占的内存。另一方面，我们也通过改进上面的例子进行验证。 123456789101112131415161718192021222324252627282930313233#include &lt;QObject&gt;#include &lt;QRunnable&gt;#include &lt;QThread&gt;#include &lt;QThreadPool&gt;#include &lt;QDebug&gt;class HelloWorldTask : public QRunnable&#123; // 线程执行任务：每间隔1s打印出线程的信息 void run() &#123; int m_dataMem[256*1000]; // 占约 1MB内存空间 for (int nCount = 0; nCount &lt; 5; nCount++) &#123; qDebug() &lt;&lt; QThread::currentThread(); QThread::msleep(1000); &#125; &#125;&#125;;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); QThreadPool threadpool; threadpool.setMaxThreadCount(1); for (int nNum = 0; nNum &lt; 100; nNum++) &#123; HelloWorldTask *task; threadpool.start(task); QThread::msleep(1000); &#125; return a.exec();&#125; 在程序运行过程中，我们观察发现程序的进程一直仅占用约1MB的内存空间。如果在main函数中所创建的100个HelloWorldTask 指针对象没有被QThreadPool释放的话，随着程序的运行该程序所占内存空间应该逐步攀升到约100MB。然而实际情况是，该程序最高仅占用1MB的内存空间。 综上两个方面可以得出以下结论：QRunnable创建的对象QThreadPool在执行完该对象后会帮助我们来清空内存，不需要我们手动回收内存。 QThread 与QRunnable + QThreadPool适用的应用场景QThread是QT的线程类，通过继承QThread然后重写run函数即可实现一个线程类。QThreadPool+ QRunnable配合构建线程池的方法也可以实现线程。我们通过以下问题对上述两种构建线程的方法进行分析和说明。 (1) 既然QThread这么简单我们为什么还要使用QThreadPool + QRunnable创建线程池的方法来使用线程机制呢？主要原因：当线程任务量非常大的时候，如果频繁的创建和释放QThread会带来比较大的内存开销，而线程池则可以有效避免该问题，相关的基础支持可以自行百度线程池的优点。 (2)QThread与 QThreadPool + QRunnable分别适用于哪种应用场景？QThread适用于那些常驻内存的任务。而且QThread可以通过信号/槽的方式与外界进行通信。而QRunnable则适用于那些不常驻内存，任务数量比较多的情况。 QRunnable 如何与外界进行通信方法1：QRunnable并不继承自QObject类，因此无法使用信号/槽的方式与外界进行通信。我们就必须的使用其他方法，这里给大家介绍的是使用：QMetaObject::invokeMethod()函数。 方法2：使用多重继承的方法，任务子类同时继承自QRunnable和QObject。]]></content>
      <categories>
        <category>Qt多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>QThread</tag>
        <tag>QRunnable</tag>
        <tag>QThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio 同时配置Qt 32位和64位版本开发环境]]></title>
    <url>%2F2018%2F11%2F20%2FVisual-Studio-%E5%90%8C%E6%97%B6%E9%85%8D%E7%BD%AEQt-32%E4%BD%8D%E5%92%8C64%E4%BD%8D%E7%89%88%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Visual Studio 同时配置Qt 32位和64位版本开发环境 Visual Studio 同时配置Qt 32位和64位版本开发环境 本文章旨在给使用Visual Studio开发Qt程序的开发人员提供一套同时构建32位版本Qt和64位版本Qt开发环境的方案，因为我自己也遇到了这个问题，国内的网上好像并没有好的解决方案，希望能够帮到有同样需求的开发人员。 Qt有32位版本的，同样也有64位版本的，在64位机器上可以同时安装32位版本的Qt和64位版本的Qt，但是做开发的时候编译64位程序只能用64位版本的Qt，32位程序只能用32位的Qt。这给使用Visual Studio 和Qt做集成环境开发的开发人员带来了不小的麻烦，在Visual Studio里对一个工程我们知道是可以编译32位程序，也可以编译64位程序的。如果我们的一个使用Qt并在Visual Studio下开发的程序既要发布32位版本又要发布64位版本，这给开发人员带来了不小的挑战： 通过Qt VS Tools我们可以将Qt版本切换到32位或者64位，但QTDIR环境变量不会变，所以工程配置里关于Qt的相关路径只会是你环境变量里配置的路径； 搞定了环境变量的问题，还有一个棘手的问题，就是Qt调试时需要plugins\platforms目录的支持，我们一般发布程序时是直接将platforms拷贝到exe文件同级目录下，我们调试的时候也可以这样做，但这样做并不好，每次建立工程都要拷贝。 解决问题1：取消系统环境变量里对QTDIR的设置，而在将QTDIR配置成Visual Studio工程里的用户自定义宏，像下面这样，在属性管理器中，找到Microsoft.Cpp.Win32.user和Microsoft.Cpp.x64.user点击，分别创建用户宏QTDIR，分别指向32位版本和64位版本Qt的路径（属性管理器：视图-其他窗口-属性管理器），这样当你切换X86和X64配置的时候对应Qt相关的库配置、调试路径配置就会改变到正确的Qt版本上： 解决问题2：问题1解决之后，在工程中切换x86和x64配置，就都可以正确编译和链接了，但是问题又来了，比如我的电脑上之前默认配置的x64版本的Qt，这是后调试x86版本的程序会提示下面的问题（这个问题大家都不陌生，但一般是在发布程序时会遇到）： 那么这个问题怎么解决呢，查了很多资料都没找到满意的解决办法，最后在外网找到国外的一个大牛利用Windows文件重定向算是完美解决了(https://superuser.com/questions/740323/qts-plugin-path-and-wow64)。 (Windows文件重定向原理：https://docs.microsoft.com/zh-cn/windows/desktop/WinProg64/file-system-redirector) 解决方法：在系统环境变量中设置QT_PLUGIN_PATH = %windir%\system32\Qt-plugins ，将64位Qt下的msvc2015_64\plugins\platforms目录拷贝到C:\Windows\System32\Qt-plugins下，将32位Qt下的msvc2015\plugins\platforms拷贝到C:\Windows\SysWOW64\Qt-plugins下，重启之后就能在Visual Studio下正常编译调试32位Qt程序和64位Qt程序了，目录结构： 注意:如果设置了QT_PLUGIN_PATH影响了系统里安全的第三方QT应用，可以这样设置QT_PLUGIN_PATH=./;%windir%\system32\Qt-plugins , 让第三方应用加载运行目录下的QT插件。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QDateTime本地时间和UTC时间转换问题]]></title>
    <url>%2F2018%2F11%2F13%2FQDateTime%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E5%92%8CUTC%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[QDateTime本地时间和UTC时间转换问题 QDateTime 本地时间和UTC时间转换问题 先说一下UTC，搜索360百科： 协调世界时，又称世界统一时间、世界标准时间、国际协调时间，简称UTC，是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。1979年12月3日在内瓦举行的世界无线电行政大会通过决议，确定用“世界协调时间”取代“格林威治时间”，作为无线电通信领域内的国际标准时间。应用于天文学及天体，是测绘学上的一类用语。 UTC时间同本地时间关系UTC +时间差=本地时间 时间差根据时区定，东边为正，西边为负，如北京东八区，时间差0800,8小时。如果UTC时间是 2014-04-03 00:00:00 那么北京时间就是 2014-04-03 08:00:00。 好，UTC时间介绍到此，继续关于QDateTime与UTC时间转换： 将QDateTime 本地时间转换成UTC时间QDateTime 提供toUTC（）函数，可将QDateTime 代表的时间转换成UTC时间，还以北京时间为例，如果当前时间1970-01-01 08:00:00, 则转换成UTC时间应该是 1970-01-01 00:00:00 ,测试代码如下： 123QDateTime testTime = QDateTime::fromString(&quot;1970-01-01 08:00:00&quot;,&quot;yyyy-MM-dd hh:mm:ss&quot;);QDateTime utcTime = testTime::toUTC();QString sUTCTime = utcTime.toString(&quot;yyyy-MM-dd hh:mm:ss&quot;); 则sUTCTime 为yyyy-MM-dd hh:mm:ss QDateTime 的 toTime_t()函数，QT帮助大致意思是将当前时间转换成距1970-1-1 0:0：0的秒数。时间坐标是UTC时间。 QDateTime::toTime_t()QT 帮助告诉我们，toTime_t 是将QDateTime 表示的转换为距1970-01-01 00:00:00 的秒数，转换时间坐标是UTC时间。 关键就是最后这句话：UTC时间坐标。这句话的意思就是，toTime_t()，转换的是QDateTime时间对应的UTC时间距1970-01-01 00:00:00 的秒数。 我们知道，一般情况下，QDateTime，表示的是本地时间Qt::LocalTime,特殊情况下会设置成Qt::UTC,表示时间直接表示的就是UTC时间。对应于LocalTime，toTime_t()转换时，首先会将QDateTime的时间转换成UTC时间(toUTC),然后计算秒数。对于Qt::UTC,则直接计算QDateTime距 1970-01-01 00:00:00，例： 12345QDateTime dateTime = QDateTime::fromString(&quot;1970-01-01 08:00:00&quot;,&quot;yyyy-MM-dd hh:mm:ss&quot;);dateTime.setTimeSpec(Qt::LocalTime);uint secondsLocal= dateTime.toTime_t(); //secondsLocal =0;dateTime.setTimeSpec(Qt::UTC);uint secondsUTC = dateTime.toTime_t(); //secondsUTC = 28800;8小时 QDateTime::fromTime_t(uint seconds)[static]查看帮助，是将距1970-01-01 00:00:00 秒数转换为QDateTime,时间坐标还是UTC。也就是说，seconds 表示的是UTC时间距 1970-01-01 00:00:00 的秒数。 如果根据 toTime_t() 反向理解，应该是fromTime_t 函数在执行时，首先根据秒数计算出UtC时间，然后根据时间的QTimeSpec，判断，如果是Qt::LocalTime,则加时间差，计算出本地时间（如：北京时间加8小时），如果是Qt::UTC,则不变。 但由于fromTime_t()是静态函数，返回QDateTime,缺省直接转换成Qt::LocalTime，即以下操作，不管如何，返回时间值都不变，例：1QDateTime dateTime = QDateTime::fromTime_t(0); 如果dateTime为Qt::LocalTime,则 dateTime，表示的是1970-01-01 08:00:00如果datetime 设为Qt::UTC, dateTime.SetTimeSpec(Qt:UTC); dateTime代表的时间还是 1970-01-01 08:00:00 QDateTime::setTime_t(uint seconds)不同于 fromTime_t，可区分出LocalTime 和 UTC。例：12345678QDateTime time ;time.setTime_t(0);QString strLocal =time.toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);//strLocal =&quot;1970-01-01 08:00:00&quot;QDateTime timeUTC;timeUTC.setTimeSpec(Qt::UTC);timeUTC.setTime_t(0);QString strUTC = timeUTC.toString(&quot;yyyy-MM-dd hh:mm:ss&quot;); //strUTC = &quot;1970-01-01 00:00:00&quot;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QDateTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QTransform类]]></title>
    <url>%2F2018%2F09%2F12%2FQTransform%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[QTransform类 QTransform类 QTransform类用于控制二维坐标系之间的转换包含：位移、缩放、扭曲、旋转还有映射首先看它的核心内容： 这是一个仿射变换矩阵(affine transformation)，它包含了坐标系转换所需要的所有信息 element description m11 水平缩放 m22 垂直缩放 m21 水平扭曲 m12 垂直扭曲 m31(dx) 水平位移 m32(dy) 垂直位移 m13 水平映射 m23 垂直映射 m33 额外的映射因子 他们具体的功能可以看下图： 你可以直接使用1void setMatrix(qreal m11, qreal m12, qreal m13, qreal m21, qreal m22, qreal m23, qreal m31, qreal m32, qreal m33) 来设置这些元素 当然，QTransform也提供了很多方法来方便你使用 method descripiton QTransform.translate(qreal dx, qreal dy) dx,dy为任意大小的实数，保存到m31(dx)和m32(dy)中 QTransform.scale(qreal sx, qreal sy) sx，sy为任意大小的实数，保存到m11和m22中 QTransform.rotate(qreal angle) angle为任意大小的实数，不过为了便于阅读，最好是0到360之间 QTransform.shear(qreal sh, qreal sv) sh，sv为任意大小的实数，保存到m12和m21中]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QTransform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective-C++]]></title>
    <url>%2F2018%2F09%2F07%2FEffective-C%2F</url>
    <content type="text"><![CDATA[Effective-C++Item 1：将C++视作一系列的语言 文章：Item 1：将C++视作一系列的语言 最初，C++只是C语言加上一些面向对象的特性，所以C++的原名是“C with Classes”。 现在的C++已经逐渐成熟，成为一门多范式的程序设计语言（multiparadigm programming language）。同时支持过程式、面向对象、函数式、泛型编程，以及元编程。 C++的灵活使得它在很多问题上并没有统一的规则，而是取决于具体的程序设计范式和当前架构的设计意图。这样的情况下，我们最好把C++看做是一系列的编程语言，而非一种特定的编程语言。 C++有四种主要的子语言： C。C++是基于C设计的，你可以只使用C++中C的那部分语法。此时你会发现你的程序反映的完全是C的特征：没有模板、没有异常、没有重载。 Object-Oriented C++。面向对象程序设计也是C++的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。 Template C++。这是C++的泛型编程部分，多数程序员很少涉及，但模板在很多情况下仍然很方便。另外模板元编程（template metaprogramming）也是一个新兴的程序设计范式，虽然有点非主流。 STL。这是一个特殊的模板库，它的容器、迭代器和算法优雅地结合在一起，只是在使用时你需要遵循它的程序设计惯例。当然你也可以基于其他想法来构建模板库。 总之C++并非单一的一门语言，它有很多不同的规则集。因而C++可以被视为四种主要子语言的集合，每个子语言都有自己的程序设计惯例。 C++程序设计的惯例并非一尘不变，而是取决于你使用C++语言的哪一部分。例如， 在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。 然而当你接触Object-Oriented C++时会发现，传常量指针是更好的选择。 但是你如果又碰到了STL，其中的迭代器和函数对象都是基于C语言的指针而设计的， 这时又回到了原来的规则：传值比传引用更好。 Item 2：避免使用define 文章：Item 2：避免使用define 尽量使用常量、枚举和内联函数，代替#define。我们知道#define定义的宏会在编译时进行替换，属于模块化程序设计的概念。 宏是全局的，面向对象程序设计中破坏了封装。因此在C++中尽量避免它！ 接着我们具体来看#define造成的问题。 不易理解众所周知，由于预处理器会直接替换的原因，宏定义最好用括号括起来。#define函数将会产生出乎意料的结果： 12#define MAX(a,b) a&gt;b?a:bMAX(i++,j) i自加次数将取决于j的大小，然而调用者并不知情。宏的行为不易理解，本质上是因为宏并非C++语言的一部分，它只是源代码的预处理手段。 不利于调试宏替换发生在编译时，语法检查之前。因此相关的编译错误中不会出现宏名称，我们不知道是哪个宏出了问题。例如： 12#define PERSON alicePERSON = bob; 如果alice未定义，PERSON=bob;便会出错：use of undeclared identifier &#39;alice&#39;。 然而我们可能不知道alice是什么东西，PERSON才是我们定义的“变量”。 宏替换是在预处理过程中进行的，原则上讲编译器不知道宏的概念。然而，在现代的编译器中（例如Apple LLVM version 6.0）， 编译器会记录宏替换信息，在编译错误中给出宏的名称： 123456test.cpp:8:5: error: use of undeclared identifier &apos;alice&apos; PERSON = bob; ^test.cpp:4:16: note: expanded from macro &apos;PERSON&apos;#define PERSON alice; ^ 于是，Meyers提到的这个问题已经不存在了。然而作者的本意在于：尽量使用编译器，而不是预处理器。 因为#define并不是C++语言的一部分。 enum 比 const 更好用既然#define不能封装在一个类中，我们可以用static const来定义一个常量，并把它的作用于局限在当前类： 1234class C&#123; static const int NUM = 3; int a[NUM];&#125;; 通常C++要求所有的声明都给出定义，然而数值类型（char, int, long）的静态常量可以只给声明。这里的NUM就是一个例子。 然而，如果你想取NUM的地址，则会得到编译错误： 12345Undefined symbols for architecture x86_64: &quot;C::NUM&quot;, referenced from: _main in a-88bbac.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 因此如果你要取地址，那么就给出它的定义： 12345class C&#123; static const int NUM = 3; int a[NUM];&#125;;const int C::NUM; 因为声明NUM时已经给定了初始值，定义时不允许再次给初始值。如果使用enum，事情会简单很多： 1234class C&#123; enum &#123; NUM = 3 &#125;; int a[NUM];&#125;; Item 3：尽量使用常量 Item 3：尽量使用常量 Item 3: Use const whenever possible 尽量使用常量。不需多说，这是防卫型（defensive）程序设计的原则， 尽量使用常量限定符，从而防止客户错误地使用你的代码。 常量的声明总结一下各种指针的声明方式吧：123456char greeting[] = &quot;Hello&quot;;char *p = greeting; // non-const pointer, non-const dataconst char *p = greeting; // non-const pointer, const datachar * const p = greeting; // const pointer, non-const dataconst char * const p = greeting; // const pointer, const data const 出现在 * 左边则被指向的对象是常量，出现在 * 右边则指针本身是常量。 然而对于常量对象，有人把 const 放在类型左边，有人把 const 放在 * 左边，都是可以的：12void f1(const Widget *pw); // f1 takes a pointer to a constant Widget objectvoid f2(Widget const *pw); // 等效 STL的iterator也是类似的，如果你希望指针本身是常量，可以声明 const iterator； 如果你希望指针指向的对象是常量，请使用 const_iterator：1234567891011std::vector&lt;int&gt; vec;// iter acts like a T* constconst std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // OK, changes what iter points to++iter; // error! iter is const//cIter acts like a const T*std::vector&lt;int&gt;::const_iterator cIter = vec.begin();*cIter = 10; // error! *cIter is const++cIter; // fine, changes cIter 返回值声明为常量可以防止你的代码被错误地使用，例如实数相加的方法：1const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs); 当用户错误地使用 = 时：1234Rational a, b, c;if (a * b = c)&#123; ...&#125; 编译器便会给出错误：不可赋值给常量。 常量成员方法声明常量成员函数是为了确定哪些方法可以通过常量对象来访问，另外一方面让接口更加易懂： 很容易知道哪些方法会改变对象，哪些不会。 成员方法添加常量限定符属于函数重载。常量对象只能调用常量方法， 非常量对象优先调用非常量方法，如不存在会调用同名常量方法。 常量成员函数也可以在类声明外定义，但声明和定义都需要指定 const 关键字。 例如：12345678910111213141516class TextBlock &#123;public: const char&amp; operator[](std::size_t position) const // operator[] for &#123; return text[position]; &#125; // const objects char&amp; operator[](std::size_t position) // operator[] for &#123; return text[position]; &#125; // non-const objectsprivate: std::string text;&#125;;TextBlock tb(&quot;Hello&quot;);const TextBlock ctb(&quot;World&quot;);tb[0] = &apos;x&apos;; // fine — writing a non-const TextBlockctb[0] = &apos;x&apos;; // error! — writing a const TextBlock 比特常量和逻辑常量比特常量（bitwise constness）：如果一个方法不改变对象的任何非静态变量，那么该方法是常量方法。 比特常量是C++定义常量的方式，然而一个满足比特常量的方法，却不见得表现得像个常量， 尤其是数据成员是指针时：1234567891011class TextBlock&#123; char* text;public: char&amp; operator[](int pos) const&#123; return text[pos]; &#125;&#125;;const TextBlock tb;char *p = &amp;tb[1];*p = &apos;a&apos;; 因为 char* text 并未发生改变，所以编译器认为我们的操作都是合法的。 然而我们定义了一个常量对象 tb，只调用它的常量方法，却能够修改tb的数据。 对数据的操作甚至可以放在 operator[]() 方法里面。 这一点不合理之处引发了 逻辑常量（logical constness）的讨论：常量方法可以修改数据成员， 只要客户检测不到变化就可以。可是常量方法修改数据成员C++编译器不会同意的！这时我们需要 mutable 限定符：123456789101112131415161718class CTextBlock &#123;public: std::size_t length() const;private: char *pText; mutable std::size_t textLength; // these data members may mutable bool lengthIsValid; // always be modified&#125;; std::size_t CTextBlock::length() const&#123; if (!lengthIsValid) &#123; textLength = std::strlen(pText); lengthIsValid = true; &#125; return textLength;&#125; 避免常量/非常量方法的重复通常我们需要定义成对的常量和普通方法，只是返回值的修改权限不同。 当然我们不希望重新编写方法的逻辑。最先想到的方法是常量方法调用普通方法，然而这是C++语法不允许的。 于是我们只能用普通方法调用常量方法，并做相应的类型转换：12345678910const char&amp; operator[](size_t pos) const&#123; ...&#125;char&amp; operator[](size_t pos)&#123; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt;(*this) [pos] );&#125; *this 的类型是 TextBlock，先把它强制隐式转换为 const TextBlock，这样我们才能调用那个常量方法。 调用 operator[](size_t) const，得到的返回值类型为 const char&amp;。 把返回值去掉 const 属性，得到类型为 char&amp; 的返回值。 Item 4：确保变量的初始化 Item 4：确保变量的初始化 Item 4: Make sure that objects are initialized before they’re used. 出于效率原因，C++不保证内置类型数据成员的初始化。对于成员变量的内置类型， 会在构造函数进入之前进行初始化。例如：1234class C&#123; int a; B b;&#125;; 其中数据成员a是基本数据类型，b是成员对象。有些情况下C++会初始化a，有些情况下则不会。 对象类型的b却是总会被初始化的，它的无参数的构造函数将被调用。 有成员对象的类称为封闭类（C就是一个），如果B没有不带参数的构造函数，则必须在C的构造函数中进行b的初始化。 C++中变量的初始化规则较为复杂，大致的规则是这样的： 对于C风格的C++：如果初始化会产生额外的负担，则不会初始化。 对于面向对象风格的C++：类的构造函数中一般都会进行所有成员的初始化（所以你也应该这样做！）。 全局/静态变量会自动初始化，自动变量（栈里面的）不会自动初始化。 构造函数中初始化所有成员在C++程序设计中的绝大多数场景下，由构造函数上进行变量的初始化。于是规则很简单：在构造函数中初始化所有成员。 值得注意的是，在构造函数进入之前成员已经进行了初始化。下面的代码会使得成员对象构造两次：12345class C&#123; B b;public: C()&#123; b = B(); &#125; // 这个是赋值啦&#125;; 正确的做法是在构造函数前给出初始化列表：12345678class C&#123; B b; int i;public: C():b(), i()&#123;&#125;&#125;;// 或者C::C() : b(), i(1)&#123;&#125; 在构造函数前总是列出所有成员变量，以免遗漏。 类静态变量的初始化类的静态变量除了在类声明中进行声明外，还需要在类声明外进行定义。 （static const int是个例外，参见：Effective C++笔记：避免使用define） 静态变量的生命周期不同于栈或者堆中的对象，从它被构造开始一直存在，直到程序结束。 包括全局变量、命名空间下的变量、类中和函数中定义的static对象。 其中，定义在函数中的称为 local static，其他的称为 non-local static。 多个编译单元的 non-local static 对象初始化次序是不确定的。因此可能会在使用时造成未初始化的问题， 解决办法便是把它变成一个 local static，C++保证了在第一次函数调用遇到该 local static 声明时， 它会被初始化。这也是Singleton(local static) 的典型实现：123456class FileSystem&#123;...&#125;;FileSystem&amp; tfs()&#123; //将在首次进入函数时构造 static FileSystem fs; return fs;&#125; 以下提供较完整的Signleton C++实现：1234567891011class Singleton&#123;private: Singleton()&#123;&#125; Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp; rhs);public: static Singleton&amp; getInstance()&#123; static Singleton instance; return instance; &#125;&#125;; 一旦声明了任何形式的构造函数（包括拷贝构造函数），编译器将不会生成默认的无参构造函数。所以上述的无参数的构造函数可以省略。]]></content>
      <categories>
        <category>Effective-C++</category>
      </categories>
      <tags>
        <tag>Effective-C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++进阶系列]]></title>
    <url>%2F2018%2F09%2F07%2FC-%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[C++进阶系列抽象类 文章：抽象类 纯虚函数定义纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 引入原因： 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重载以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 带有纯虚函数的类称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。 抽象类的主要作用是将有关的组织在一个继承层次结构中，由它来为它们提供一个公共的根，相关的子类是从这个根派生出来的。 抽象类刻画了一组子类的操作接口的通用语义，这些语义也传给子类。一般而言，抽象类只描述这组子类共同的操作接口，而完整的实现留给子类。 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类没有重新定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然还是一个 抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体类了。 抽象类的规定 抽象类只能用作其他类的基类，不能建立抽象类对象。 抽象类不能用作参数类型、函数返回类型或显式转换的类型。 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;const double PI=3.14159;class Shapes //抽象类&#123;protected: int x, y;public: void setvalue(int d, int w=0)&#123;x=d;y=w;&#125; virtual void disp()=0;//纯虚函数&#125;;class Square:public Shapes&#123;public: void disp()&#123; cout&lt;&lt;&quot;矩形面积:&quot;&lt;&lt;x*y&lt;&lt;endl; &#125;&#125;;class Circle:public Shapes&#123;public: void disp()&#123; cout&lt;&lt;&quot;圆面积:&quot;&lt;&lt;PI*x*x&lt;&lt;endl; &#125;&#125;;int main()&#123; Shapes *ptr[2]; //定义对象指针数组 Square s1; Circle c1; ptr[0] = &amp;s1; ptr[0]-&gt;setvalue(10, 5); ptr[0]-&gt;disp(); ptr[1] = &amp;c1; ptr[1]-&gt;setvalue(10); ptr[1]-&gt;disp(); return 0;&#125; 相似概念： 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。a.编译时多态性： 通过函数重载和运算符重载来实现的。b.运行时多态性：通过继承和虚函数来实现的。 虚函数虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载纯虚函数的声明有着特殊的语法格式：virtual 返回值类型成员函数名（参数表）=0；请注意，纯虚函数应该只有声明，没有具体的定义，即使给出了纯虚函数的定义也会被编译器忽略。 抽象类包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。在C++中，我们可以把只能用于被继承而不能直接创建对象的类设置为抽象类（Abstract Class）。 之所以要存在抽象类，最主要是因为它具有不确定因素。我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为纯虚函数。纯虚函数是一种特殊的虚函数，它只有声明，没有具体的定义。抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。 12345678910111213141516171819202122232425262728293031323334353637383940//基类:class A&#123;public: A(); void f1(); virtual void f2(); virtual void f3()=0; virtual ~A();&#125;;//子类:class B : public A&#123;public: B(); void f1(); void f2(); void f3(); virtual ~B();&#125;;//主函数:int main(int argc, char* argv[])&#123; A *m_j=new B(); m_j-&gt;f1(); m_j-&gt;f2(); m_j-&gt;f3(); delete m_j; return 0;&#125;/*f1()是一个普通的重载.调用m_j-&gt;f1();会去调用A类中的f1(),它是在我们写好代码的时候就会定好的.因为f1()不是虚函数，不会动态绑定也就是根据它是由A类定义的,这样就调用这个类的函数.f2()是虚函数.调用m_j-&gt;f2();会调用m_j中保存的对象中,对应的这个函数.这是由于new的B对象.f3()与f2()一样,只是在基类中不需要写函数实现.*/ 虚函数和纯虚函数有以下所示方面的区别： 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，这样编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现，这就像Java的接口一样。通常把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为很难预料到父类里面的这个函数不在子类里面不去修改它的实现。 带纯虚函数的类叫虚基类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。这样的类也叫抽象类。抽象类和大家口头常说的虚基类还是有区别的，在C#中用abstract定义抽象类，而在C++中有抽象类的概念，但是没有这个关键字。抽象类被继承后，子类可以继续是抽象类，也可以是普通类，而虚基类，是含有纯虚函数的类，它如果被继承，那么子类就必须实现虚基类里面的所有纯虚函数，其子类不能是抽象类。 四、抽象类和接口的区别： 类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类.而接口只是一个行为的规范或规定，微软的自定义接口总是后带able字段，证明其是表述一类类“我能做。。。”.抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中. 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法; 一个类一次可以实现若干个接口,但是只能扩展一个父类 接口可以用于支持回调,而继承并不具备这个特点. 抽象类不能被密封。 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的. （接口）与非抽象类类似，抽象类也必须为在该类的基类列表中列出的接口的所有成员提供它自己的实现。但是，允许抽象类将接口方法映射到抽象方法上。 抽象类实现了oop中的一个原则，把可变的与不可变的分离。抽象类和接口就是定义为不可变的，而把可变的座位子类去实现。 好的接口定义应该是具有专一功能性的，而不是多功能的，否则造成接口污染。如果一个类只是实现了这个接口的中一个功能，而不得不去实现接口中的其他方法，就叫接口污染。 尽量避免使用继承来实现组建功能，而是使用黑箱复用，即对象组合。因为继承的层次增多，造成最直接的后果就是当你调用这个类群中某一类，就必须把他们全部加载到栈中！后果可想而知.（结合堆栈原理理解）。同时，有心的朋友可以留意到微软在构建一个类时，很多时候用到了对象组合的方法。比如asp.net中，Page类，有Server Request等属性，但其实他们都是某个类的对象。使用Page类的这个对象来调用另外的类的方法和属性，这个是非常基本的一个设计原则。 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法. C++ 虚重载操作符 virtual operator= 使用方法 C++中虚操作符和其他虚函数的规则一样，操作符可以为虚函数，进行动态绑定， 虽然这种情况并不多见。本文以赋值操作符operator=举例。 派生类中要重定义基类虚函数，要注意参数必须为基类引用类型，否则与基类中虚函数是完全不同的，无法进行预期的动态绑定。 派生类除了重定义基类的虚操作符，还要定义自身的操作符重载。即派生层次每增加一层，理论上派生类就需要多定义一个操作符重载。 以下程序使用引用reference，通过指针调用赋值操作符（例：*p = value）情况是一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt; using namespace std; class Base &#123; public: virtual Base&amp; operator=(const Base&amp; rhs) //重载操作符可设为virtual &#123; cout &lt;&lt; &quot;Base&quot; &lt;&lt; endl; return *this; &#125; &#125;; class Derived : public Base &#123; public: //与基类的operator=完全不同，不是重新定义，不会动态绑定。 //如果不定义该操作符，会自动合成一个，并自动调用基类的operator=，不会动态绑定 Derived&amp; operator=(const Derived&amp; rhs) &#123; cout &lt;&lt; &quot;Derived_D&quot; &lt;&lt; endl; return *this; &#125; //重新定义基类的operator=，会动态绑定 //virtual Base&amp; operator=(const Base&amp; rhs) //返回值两种都可以 virtual Derived&amp; operator=(const Base&amp; rhs) &#123; cout &lt;&lt; &quot;Derived_B&quot; &lt;&lt; endl; return *this; &#125; &#125;; class Derived2 : public Derived &#123; //此类需要3个operator= //可定义private的copy函数，由3个operator=调用 //可使用dynamic_cast将基类引用参数转为子类，并捕获异常。 //如果未发生异常，则调用copy，发生异常则不需赋值 &#125;; int main() &#123; Base b1, b2; Derived d1, d2; Derived &amp;rd = d1; Base &amp;rb1 = b1; //动态类型为Base Base &amp;rb2 = d2; //动态类型为Derived rb1 = d1; //输出&quot;Base&quot; rb2 = d2; //输出&quot;Derived_B&quot; rb1 = rb2; //输出&quot;Base&quot; rb2 = rb1; //输出&quot;Derived_B&quot; rd = d1; //输出&quot;Derived_D&quot; rd = b1; //输出&quot;Derived_B&quot; getchar(); return 0; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[基于C++或者Qt的开源库Asynchronous programming in Qt/C++ using tasks and continuations基于Qt/C++的异步库 Poly2Tri基于C++的多边形三角化库 Game Math and Geometry Library游戏、数学、几何库 ternary_search_tree查找树包含ternary_search_tre的源码文件 binary-search-tree-in-qt基于Qt的二叉树 x3py可与Python等集成的轻量级C++插件框架 Qt PluginManagerPlugin manager library using Qt framework to create Qt applications based on custom loadable plugins. nodeeditorQt节点编辑器 chigraph图形化编程 imageutilities工业相机取图片刷新例子代码 mars一个应用软件，里面部分代码用到Qt属性表，可以参考该软件的使用 qt-solutions一个Qt的类库包，里面包含属性表，单例程序使用，还有其他库的GitHub库 QtXlsxWriterQt读写Excel库 qt-serialport-arduinoQt串口通信 dunnartQt写的一个节点编辑器 CS_Offer有时间值得一看的C++教程 madplotlibA C++ wrapper of Qt Charts that looks, tastes and smells like matplotlib but isn’t. cppfbpC++流式编程库，结合lua QFlowC++流式编程库 libgitlmvcC++ MVC 框架，Qt5 QBox2DAn attempt to use Erin Catto’s Box2D (http://www.box2d.org) API with Qt/C++ Graphics VIew Framework QtnPropertyQt属性表 Multi-Threaded-Image-Processing-using-Qt-Camera-with-Android-USB Qt多线程使用相机处理 sa这是一个数据预处理软件，主要负责数据挖掘的数据清洗工作，如对一些科研实验数据的清洗和预处理 LeksysINI开源读写INI配置文件库 tasksQt异步多任务执行类库 Qt-SyncWokerQt同步、异步任务模型]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>开源库</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt中文乱码问题]]></title>
    <url>%2F2018%2F08%2F13%2FQt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Qt中文乱码问题VC2010下Qt5的中文乱码问题 参考文章：VC2010下Qt5的中文乱码问题 要搞清楚这个问题，先要弄明白编码。但是编码问题实在太复杂，这里肯定讲不开。 我先找一个例子，比如：”中文” 的 Unicode 码点/UTF8编码/GBK 分别是多少。 先去这个网站，输入 “中文” 查询对应的 Unicode 码点/UTF8编码： http://www.mytju.com/classcode/tools/encode_utf8.asp Unicode的码点分别是(十进制)：中(20013)，文(25991)。 对应的UTF8编码分别(16进制): 中(E4B8AD)，文(E69687)。 然后再去下面这个网站，输入 “中文” 查询对应的 GBK 编码： http://www.mytju.com/classcode/tools/encode_gb2312.asp GBK编码16进制(GBK内码)分别是：中(D6D0)，文(CEC4)。 现在已经知道了”中文”的UTF8和GBK编码的具体值。 我们再看看VC2010是怎么处理的。 先看无 BOM 的 UTF8 编码的代码 (utf8_no_bom.cpp)12345678910111213// utf8 no bom// 文件中包含不能在当前代码页（936）中表示的字符#include &lt;stdio.h&gt;int main() &#123; const char* str = &quot;中文&quot;; for(int i = 0; i &lt; sizeof(str); ++i) &#123; printf(&quot;0x%x &quot;, str[i]&amp;0xFF); &#125; return 0; // Output: // 0xe4 0xb8 0xad 0xe6&#125; 输出是：0xe4 0xb8 0xad 0xe6。 感觉好像是对的。 但是，先别急：VC编译时输出了一条警告信息： utf8_no_bom.cpp : warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。 请将该文件保存为 Unicode 格式以防止数据丢失。 潜台词就是，你这个代码有GBK不能表示的字符，请用Unicode方式保存。 VC根本就没把 代码(utf8_no_bom.cpp) 当作UTF8，VC只是把它作为GBK处理罢了。 那为什么又输出了正确的结果呢？ 因为 VC 把 (utf8_no_bom.cpp) 当作 GBK，而编译时也要转换为本地编码(也是GBK)。 因此，UTF8编码的 “中文”，被VC当作编码为 “0xe4 0xb8 0xad 0xe6” 的其他中文处理了。 VC已经不知道 “0xe4 0xb8 0xad 0xe6” 是对应 “中文” 字面值了。 但是在GBK(实际是无BOM的UTF8)转GBK的过程中，发现了一些UTF8编码的字符并不是 GBK能表达的合理方式，因此就出现了那个C4819编译警告。 再看带BOM的UTF8是怎么处理的 (utf8_with_bom.cpp)123456789101112// utf8 with bom#include &lt;stdio.h&gt;int main() &#123; const char* str = &quot;中文&quot;; for(int i = 0; i &lt; sizeof(str); ++i) &#123; printf(&quot;0x%x &quot;, str[i]&amp;0xFF); &#125; return 0; // Output: // 0xd6 0xd0 0xce 0xc4&#125; 编译没有警告，但是输出有问题：0xd6 0xd0 0xce 0xc4。 源文件明明是 UTF8 编码的格式”0xe4 0xb8 0xad 0xe6”， 怎么变成了 “0xd6 0xd0 0xce 0xc4” (这个是GBK编码)？ 这就是VC私下干的好事：它自作聪明的将UTF8源代码转换为GBK处理了！ VC为何要做这样蠢事？ 原因是为了兼容老的VC版本。 因为以前的VC不能处理UTF8，都是用本地编码处理的。 在看看真的GBK是怎么处理的 (gbk.cpp)123456789101112// gbk#include &lt;stdio.h&gt;int main() &#123; const char* str = &quot;中文&quot;; for(int i = 0; i &lt; sizeof(str); ++i) &#123; printf(&quot;0x%x &quot;, str[i]&amp;0xFF); &#125; return 0; // Output: // 0xd6 0xd0 0xce 0xc4&#125; 没有编译错误，输出也和源代码一致：”0xd6 0xd0 0xce 0xc4”。 因为源文件就是GBK，cl在编译时GBK转化为GBK，没有改变字符串。 只是，现在很多人不想用GBK了（因为只能在中国地区用，不能表示全球字符）。 到这里，可以初步小结一下： VC编辑器和VC编译器是2个概念，VC编辑器支持UTF8并不能表示VC编译器也支持UTF8 VC编辑器从2008?开始支持带BOM的UTF8(不带BOM的暂时没戏，因为会本地编码冲突) VC编译器从2010开始重要可以支持UTF8了(虽然支持方式很不优雅) 看看VC2010是怎么处理带BOM的UTF8的 (utf8_with_bom_2010.cpp)VC2010重要增加了UTF8的编译支持(#pragma execution_character_set(“utf-8”)), 具体查看: http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/2f328917-4e99-40be-adfa-35cc17c9cdec 1234567891011121314// utf8 with bom (VC2010), 这句是重点！#pragma execution_character_set(&quot;utf-8&quot;)#include &lt;stdio.h&gt;int main() &#123; const char* str = &quot;中文&quot;; for(int i = 0; i &lt; sizeof(str); ++i) &#123; printf(&quot;0x%x &quot;, str[i]&amp;0xFF); &#125; return 0; // Output: // 0xe4 0xb8 0xad 0xe6&#125; 没有编译错误，输出也和源代码一致：”0xe4 0xb8 0xad 0xe6”。 UTF8编码，UTF8输出。完美! 回到 Qt5 的中文输出问题。Qt默认支持 VS2010/MinGW/Gcc 等编译器，而它们现在都已经真正支持UTF8了。 当然，VS2010 对UTF8的支持会入侵代码(#pragma execution_character_set(“utf-8”))。 看看Qt官方论坛别人是怎么说的： http://qt-project.org/forums/viewthread/17617 Nothing special need to do, it will works by default. If the exec-charset of your your compiler is UTF-8. 简单的说，从Qt5开始，源代码就是默认UTF8编码的。 当然，VC2010编辑器对带BOM的UTF8也是认识，只可惜VC2010编译器根本承认它是UTF8！ 在继续看官方论坛的回复： You can write a simple example like this 123456789101112131415#include &lt;QApplication&gt;#include &lt;QLabel&gt; #if _MSC_VER &gt;= 1600 #pragma execution_character_set(&quot;utf-8&quot;) #endif int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); QLabel label(&quot;ąśćółęńżź&quot;); label.show(); return a.exec(); &#125; If other people can reproduce your problem, you can file a bug. 教完整的解决方案(增加了Qt4/Qt5和非VC环境的判断): 1234567891011121314151617181920212223242526// Coding: UTF-8(BOM)#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)# pragma execution_character_set(&quot;utf-8&quot;)#endif#include &lt;QApplication&gt;#include &lt;QTextCodec&gt;#include &lt;QLabel&gt;int main(int argc, char* argv[])&#123; QApplication app(argc, argv);#if QT_VERSION &lt; QT_VERSION_CHECK(5,0,0)#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1600) QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;GB18030-0&quot;));#else QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;UTF-8&quot;));#endif#endif QLabel *label = new QLabel(QObject::tr(&quot;你好！&quot;)); label-&gt;show(); return app.exec();&#125; 有以下几种类型(源代码必须是带BOM的UTF8): Qt5+/VC2010+: 包含了 # pragma execution_character_set(“utf-8”) 已经支持中文 Qt5/VC2008-: 这个暂时误解(我还没找到方法) Qt4+/VC2008-: 采用以前老的方式, 指定代码为 “GB18030-0” 编码 Qt4/Qt5/Linux: 只要是默认的UTF8环境, 应该都没问题 其实这个问题不是Qt特有的, 追根溯源还是C/C++和编译器的问题. 即使是支持UTF16的Java也同样难逃此问题. Qt5中解决中文乱码的方法 文章：Qt5中解决中文乱码的方法 在 Qt 4 的时代，解决中文乱码挺麻烦。要考虑用的是什么编译器，具体的可以参考下面这篇文章：http://blog.csdn.net/brave_heart_lxl/article/details/7186631 到了 Qt 5 的年代，这个问题变得简单了些。因为根据 Qt 的文档：http://doc.qt.io/qt-5.6/qstring.html#QString-7 中规定 QString 的 const char* 构造函数是调用 fromUtf8() 构造的。所以要求字符串字面量是 UTF-8 编码的字节。 这里先要解释一下下面两个概念： 源码字符集(the source character set)：源码文件是使用何种编码保存的 执行字符集(the execution character set)：可执行程序内保存的是何种编码(程序执行时内存中字符串编码) 源码字符集很容易理解，就是我们源代码的编码。为了我们的代码能够跨平台，源文件要保存为带 BOM 的 utf-8。 执行字符集就麻烦多了。比如我们下面的代码片段：1QString str(&quot;我是中文&quot;); 即使这个文件存为 utf-8 格式了，编译成 exe 文件时，编译器也可能对这个字符串常量进行转码，转为别的编码格式。 在 gcc 中，控制这个转码操作的命令行参数是：1-fexec-charset=charset 如果不指定的话默认是 utf-8。所以我们用 gcc 时很少关注这个问题。 Viual Stdio 中就麻烦多了。这里先说 Visual stdio 2015，这个是我现在用的编译环境。VS2015 中如果源代码是 utf-8的，执行字符集默认是本地 Locale 字符集，对于简体中文的 windows 系统来说，这个 本地Locale字符集是 gb18030。所以直接显示汉字会全是乱码。解决这个乱码有三个办法，第一个办法是编译时加入命令行参数，在 Qt 的 pro 文件中可以这样：1msvc:QMAKE_CXXFLAGS += -execution-charset:utf-8 第二个办法是在源文件中加入：1#pragma execution_character_set(&quot;utf-8&quot;) 更好的办法是源代码写为：1QString str(u8&quot;我是中文&quot;); 当然，这里要求编译器支持 C++11，因此上面的代码在 VS2005、VS2008 上是无法编译通过的。 另外，如果源代码保存为不带 BOM 的 utf-8。那需要告诉 VS2015 我们的编码格式是 utf-8，可以在 pro 文件中加入如下的代码：1msvc:QMAKE_CXXFLAGS += -source-charset:utf-8 另外再说说 VS2005、VS2008 下该如何设置。首先这两个编译器都不支持 C++11，也不支持执行字符集的设置，执行字符集就是默认的本地 Locale 字符集。所以我们的代码只能写为：1QString str = QString::fromLocal8Bit(&quot;我是中文&quot;);]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt Plugin框架结构]]></title>
    <url>%2F2018%2F08%2F13%2FQt-Plugin%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Qt Plugin框架结构 参考文章：基于QT Plugin框架结构 qt plugin 介绍Qt Plugin和其他类型的插件一样，是一种计算机应用程序，它和主应用程序(host application)互相交互，以提供特定的功能。应用程序支持Plugin有许多原因，一些主要原因包括：使得第三方开发者有能力扩展应用程序，以提供无法先期预料的特色；减小应用程序的大小；由于软件版权之间的不兼容性将源代码和应用程序分享。Qt Plugin 分动态插件和静态插件两种。 qt plugin 创建和使用方法Qt有两种与插件有关的API。一种用来扩展Qt本身的功能，如自定义数据库驱动，图像格式，文本编解码，自定义分格，等等，称为Higher-Level API。另一种用于应用程序的功能扩展，称为Lower-Level API。前一种是建立在后一种的基础之上的。这里讨论的是后一种，即用来扩展应用程序的Lower-level API。 让应用程序支持插件扩展的步骤： 定义一个接口集(只有纯虚函数的类)，用来与插件交流。 用宏Q_DECLARE_INTERFACE()将该接口告诉Qt元对象系统。 Q_DECLARE_INTERFACE(BrushInterface,”com.trolltech.PlugAndPaint.BrushInterface/1.0”) 应用程序中用QPluginLoader来装载插件。 用宏qobject_cast()来确定一个插件是否实现了接口。 12QObject *obj = new QTimer;QTimer *timer = qobject_cast&lt;QTimer *&gt;(obj); 写一个插件的步骤： 声明插件类，该类从QObject和该插件希望实现的接口继承而来。 用宏Q_INTERFACES()将该接口告诉Qt元对象系统。 1234567891011class BasicToolsPlugin : public QObject, public BrushInterface, public ShapeInterface, public FilterInterface&#123; Q_OBJECT Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)public: ...&#125;; 用宏Q_EXPORT_PLUGIN2()导出插件。 1Q_EXPORT_PLUGIN2 ( PluginName, ClassName ) 用适当的.pro文件构建插件。 下面的代码声明了一个接口类： 123456789class FilterInterface&#123; public: virtual ~FilterInterface() &#123;&#125; virtual QStringList filters() const = 0; virtual QImage filterImage(const QString &amp;filter, const QImage &amp;image, QWidget* parent)=0;&#125;;Q_DECLARE_INTERFACE(FilterInterface, &quot;com.trolltech.PlugAndPaint.FilterInterface/1.0&quot;) 这里是实现该接口的插件类的定义： 123456789101112131415#include &lt;QObject&gt;#include &lt;QStringList&gt;#include &lt;QImage&gt;#include &lt;plugandpaint/interfaces.h&gt;class ExtraFiltersPlugin : public QObject, public FilterInterface&#123;Q_OBJECTQ_INTERFACES(FilterInterface)public: QStringList filters() const; QImage filterImage(const QString &amp;filter, const QImage &amp;image, QWidget *parent);&#125;; 根据插件的类型不同，pro文件中配置上有不同。下面是pro文件分析： TEMPLATE = lib // 声明为lib，动态和静态插件一样。 CONFIG += plugin static // 声明为plugin，带static表面为静态，否则为动态。 INCLUDEPATH += ../.. HEADERS = basictoolsplugin.h SOURCES = basictoolsplugin.cpp TARGET = $$qtLibraryTarget(pnp_basictools) // 指明插件的名称 DESTDIR = ../../plugandpaint/plugins 加载插件的主应用程序默认在当前目录下的plugins文件夹中寻找可用插件，如果是动态插件，则直接放在plugins文件夹中便可，如果是静态，则需要在主应用程序的main函数的开始的地方用宏：Q_IMPORT_PLUGIN(pluginname(和pro文件中声明的一致))声明需要加载的插件并在工程配置中指明插件的lib位置。 基于qt plugin 技术的框架结构设想 愿景由于我们目前系统功能多，模块多，缺乏系统的整体性。我们想借助Qt Plugin技术，把各个独立的功能模块实现为一个个插件，统一在主体框架中，并能根据不同地方的用户的不同需求，在主框架中加载不同的功能模块，以实现整个系统的功能集中，体现出系统的整体性。 plugin 接口通过技术验证得出，目前我们采用动态插件，各个功能的插件实现定义的统一接口，具体功能放在插件界面中实现，此部分就像开发独立的应用程序，只是需要注意的是： 功能部分的主界面需要继承至插件界面基类：PluginWidget，插件接口中用具体的实现类指针给插件界面基类指针赋值，在加载插件的主框架中通过插件接口中定义的基类指针统一调用，利用C++动态技术动态识别具体指向的实现类。 插件界面类必须实现基类的虚函数：CreateActions()用于创建Action 创建Action需要使用基类的方法newAction创建，在此函数中加入了保存创建的Action功能。 插件接口定义如下： 12345678910111213141516171819202122232425class QPluginInterface&#123;public: // 析构函数 virtual ~QPluginInterface() &#123;&#125; // 插件名称 virtual QString PluginName() = 0; // 插件显示在主框架中的图标文件路径 virtual QString PluginIconurl() = 0; // 插件提供的对外操作接口集 virtual QList&lt;QAction*&gt;* Actions() = 0; // 创建插件提供的操作方法 virtual void CreateActions()=0; // 插件的主界面 virtual QWidget* Widget() = 0;protected: // 插件的主界面基类 PluginWidget *pluginWidget;&#125;; 插件界面基类定义如下：12345678910111213141516class PluginWidget :public QMainWindow&#123; Q_OBJECTpublic: PluginWidget(QWidget*parent=0); ~PluginWidget(); QList&lt;QAction*&gt;* Actions(); virtual void CreateActions()&#123;&#125; QAction *newAction(const QIcon &amp;icon,const QString &amp;text,QObject*parent); QAction *newAction(const QString &amp;text,QObject*parent); void AppendAction(QAction*act);protected: // action链表 QList&lt;QAction*&gt; *m_actlist;&#125;; 下图是一个实现案例中各类之间的关系图： 插件调用 插件在主框架中动态加载，目前考虑主框架基本结构是继承至QMainWindow，工具栏上显示当前加载的插件的功能键，并留有返回键可以回退到上一级。主工作区是一个QStackWidget,保存插件的界面，并把插件序号和插件对应的界面建立映射，保存在QMap&lt;int,QWidget&gt;中。通过序号到QStackWidget中切换界面。 下图是把DBManager做成插件加载到主框架的运行界面： 下图是把一个简单的绘图程序做成了插件，加载到主框架的运行界面： 总结目前只是通过实现两个动态插件在主框架中运行，基本算是功能性的验证，离具体实施还有很多工作需要进一步的研究，比如主框架的风格，插件的管理等等。由于本人的能力有限，可能有很多认识不够的地方，请指正。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QtPlugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式PK]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%A8%A1%E5%BC%8FPK%2F</url>
    <content type="text"><![CDATA[模式PK一张记住图例的图片 抽象工厂模式VS建造者模式 抽象工厂模式VS建造者模式 概述抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品，两者的区别还是比较明显的。 现代化的汽车工厂能够批量生产汽车（不考虑手工打造的豪华车）。不同的工厂生产不同的汽车，宝马工厂生产宝马牌子的车，奔驰工厂生产奔驰牌子的车。车不仅具有不同品牌，还有不同的用途分类，如商务车Van，运动型车SUV等，我们按照两种设计模式分别实现车辆的生产过程。 抽象工厂模式生产车辆类图按照抽象工厂模式，首先需要定义一个抽象的产品接口即汽车接口，然后宝马和奔驰分别实现该接口，由于它们只具有了一个品牌属性，还没有定义一个具体的型号，属于对象的抽象层次，每个具体车型由其子类实现，如R系列的奔驰车是商务车，X系列的宝马车属于SUV，我们来看类图。 在类图中，产品类很简单，我们从两个维度看产品：品牌和车型，每个品牌下都有两个车型，如宝马SUV，宝马商务车等，同时我们又建造了两个工厂，一个专门生产宝马车的宝马工厂BMWFactory，一个是生产奔驰车的奔驰车生产工厂BenzFactory。当然，汽车工厂也有两个不同的维度，可以建立这样两个工厂：一个专门生产SUV车辆的生产工厂，生产宝马SUV和奔驰SUV，另外一个工厂专门生成商务车，分别是宝马商务车和奔驰商务车，这样设计在技术上是完全可行的，但是在业务上是不可行的，为什么？这是因为你看到过有一个工厂既能生产奔驰SUV也能生产宝马SUV吗？这是不可能的，因为业务受限，除非是国内的山寨工厂。 代码产品类123456789class CICar&#123;public: CICar()&#123;&#125;; ~CICar()&#123;&#125;; //汽车的生产商， 也就是牌子 virtual string msGetBand() = 0; virtual string msGetModel() = 0;&#125;; 在产品接口中我们定义了车辆有两个可以查询的属性：品牌和型号，奔驰车和宝马车是两个不同品牌的产品，但不够具体，只是知道它们的品牌而已，还不能够实例化，因此还是一个抽象类。 抽象宝马车123456789101112131415class CAbsBMW :public CICar&#123;public: CAbsBMW() &#123; msBand = &quot;宝马汽车&quot;; &#125; ~CAbsBMW()&#123;&#125;; //宝马车 string msGetBand()&#123; return msBand; &#125; // 型号由具体的实现类实现 virtual string msGetModel() = 0;private: string msBand;&#125;; 抽象产品类中实现了产品的类型定义，车辆的型号没有实现，两实现类分别实现商务车和运动型车。 宝马商务车1234567891011class CBMWVan : public CAbsBMW&#123;public: CBMWVan()&#123; msModel = &quot;7系列车型商务车&quot;; &#125;; ~CBMWVan()&#123;&#125;; string msGetModel()&#123; return msModel; &#125;;private: string msModel;&#125;; 宝马SUV1234567891011class CBMWSuv : public CAbsBMW&#123;public: CBMWSuv()&#123; msModel = &quot;X系列车型SUV&quot;; &#125;; ~CBMWSuv()&#123;&#125;; string msGetModel()&#123; return msModel; &#125;;private: string msModel;&#125;; 奔驰抽象类奔驰车与宝马车类似，都已经有清晰品牌定义，但是型号还没有确认，也是一个抽象的产品类。 123456789101112131415class CAbsBenz :public CICar&#123;public: CAbsBenz() &#123; msBand = &quot;奔驰汽车&quot;; &#125; ~CAbsBenz()&#123;&#125;; //奔驰车 string msGetBand()&#123; return msBand; &#125; // 型号由具体的实现类实现 virtual string msGetModel() = 0;private: string msBand;&#125;; 奔驰商务车由于分类的标准是相同的，因此奔驰车也应该有商务车和运动车两个类型。 1234567891011class CBenzVan : public CAbsBenz&#123;public: CBenzVan()&#123; msModel = &quot;R系列商务车&quot;; &#125;; ~CBenzVan()&#123;&#125;; string msGetModel()&#123; return msModel; &#125;;private: string msModel;&#125;; 奔驰SUV1234567891011class CBenzSuv : public CAbsBenz&#123;public: CBenzSuv()&#123; msModel = &quot;G系列SUV&quot;; &#125;; ~CBenzSuv()&#123;&#125;; string msGetModel()&#123; return msModel; &#125;;private: string msModel;&#125;; 抽象工厂所有的产品类都已经实现了，剩下的工作就是要定义工厂类进行生产，由于产品类型多样，也导致了必须有多个工厂类来生产不同产品，首先就需要定义一个抽象工厂，声明每个工厂必须完成的职责。抽象工厂定义了每个工厂必须生产两个类型车：SUV（运动车）和VAN（商务车），否则一个工厂就不能被实例化 12345678class CICarFactory&#123;public: CICarFactory()&#123;&#125;; ~CICarFactory()&#123;&#125;; virtual CICar * mopCreateSuv() = 0; virtual CICar * mopCreateVan() = 0;&#125;; 宝马车工厂123456789101112class CBMWFactory : public CICarFactory&#123;public: CBMWFactory()&#123;&#125;; ~CBMWFactory()&#123;&#125;; //生产SUV CICar * mopCreateSuv() &#123; return new CBMWSuv; &#125; //生产商务车 CICar * mopCreateVan() &#123; return new CBMWVan; &#125;&#125;; 很简单，你要我生产宝马商务车，没问题，直接产生一个宝马商务车对象，返回给调用者，这对调用者来说根本不需要关心到底是怎么生产的，它只要找到一个宝马工厂，即可生产出自己需要的产品（汽车）。 奔驰车工厂123456789101112class CBenzFactory : public CICarFactory&#123;public: CBenzFactory()&#123;&#125;; ~CBenzFactory()&#123;&#125;; //生产SUV CICar * mopCreateSuv() &#123; return new CBenzSuv; &#125; //生产商务车 CICar * mopCreateVan() &#123; return new CBenzVan; &#125;&#125;; 调用场景产品和工厂都具备了，剩下的工作就是建立一个场景类模拟调用者调用 1234567891011121314151617int main()&#123; //要求生产一辆奔驰SUV cout &lt;&lt; &quot;===要求生产一辆奔驰SUV===&quot; &lt;&lt; endl; //首先找到生产奔驰车的工厂 cout &lt;&lt; &quot;A、 找到奔驰车工厂&quot; &lt;&lt; endl; CICarFactory *op_factory = new CBenzFactory; //开始生产奔驰SUV cout &lt;&lt; &quot;B、 开始生产奔驰SUV&quot; &lt;&lt; endl; CICar *op_benz_suv = op_factory-&gt;mopCreateSuv(); //生产完毕， 展示一下车辆信息 cout &lt;&lt; &quot;C、 生产出的汽车如下： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;汽车品牌： &quot; &lt;&lt; op_benz_suv-&gt;msGetBand().c_str() &lt;&lt; endl; cout &lt;&lt; &quot;汽车型号： &quot; &lt;&lt; op_benz_suv-&gt;msGetModel().c_str() &lt;&lt; endl; return 0;&#125; 运行结果 小结对外界调用者来说，只要更换一个具备相同结构的对象，即可发生非常大的改变，如我们原本使用BenzFactory生产汽车，但是过了一段时间后，我们的系统需要生产宝马汽车，这对系统来说不需要很大的改动，只要把工厂类使用BMWFactory代替即可，立刻可以生产出宝马车，注意这里生产的是一辆完整的车，对于一个产品，只要给出产品代码（车类型）即可生产，抽象工厂模式把一辆车认为是一个完整的、不可拆分的对象。它注重完整性，一个产品一旦找到一个工厂生产，那就是固定的型号，不会出现一个宝马工厂生产奔驰车的情况。 造者模式生产车辆那现在的问题是我们就想要一辆混合的车型，如奔驰的引擎，宝马的车轮，那该怎么处理呢？使用我们的建造者模式！ 类图按照建造者模式设计一个生产车辆需要把车辆进行拆分，拆分成引擎和车轮两部分，然后由建造者进行建造，想要什么车，你只要有设计图纸就成，马上可以制造一辆车出来。它注重的是对零件的装配、组合、封装，它从一个细微构件装配角度看待一个对象。我们来看生产车辆的类图。 注意看我们类图中的蓝图类Blueprint，它负责对产品建造过程定义。既然要生产产品，那必然要对产品进行一个描述，在类图中我们定义了一个接口来描述汽车。车辆产品描述，我们定义一辆车必须有车轮和引擎 12345678class CICar&#123;public: //汽车车轮 virtual string msGetWheel() = 0; //汽车引擎 virtual string msGetEngine() = 0;&#125;; 代码具体车辆123456789101112131415161718192021222324class CCar : public CICar&#123;public: CCar(const string &amp;sEngine, const string &amp;sWheel) &#123; msEngine = sEngine; msWheel = sWheel; &#125;; ~CCar()&#123;&#125;; //汽车车轮 string msGetWheel() &#123; return msWheel; &#125;; //汽车引擎 string msGetEngine() &#123; return msEngine; &#125;; string msGetInfo()&#123; return &quot;车的轮子是： &quot; + msWheel + &quot;\n车的引擎是： &quot; + msEngine; &#125;private: //汽车引擎 string msEngine; //汽车车轮 string msWheel;&#125;; 简单定义产品的属性，明确对产品的描述。我们继续来思考，因为我们的产品是比较抽象的，它没有指定引擎的型号，也没有指定车轮的牌子，那么这样的组合方式有很多，完全要靠建造者来建造，建造者说要生产一辆奔驰SUV那就得用奔驰的引擎和奔驰的车轮，该建造者对于一个具体的产品来说是绝对的权威，我们来描述一下建造者。 抽象建造者12345678910111213141516171819class CCarBuilder&#123;public: CCarBuilder() &#123;&#125;; ~CCarBuilder()&#123;&#125;; // 接收一份设计蓝图 void mvSetBlueprint(CBlueprint *opBlueprint)&#123; mopBluprint = opBlueprint; &#125;; CCar *mopBuildCar() &#123; return new CCar(msBuildEngine(), msBuildWheel()); &#125;;protected: // 查看蓝图， 只有真正的建造者才可以查看蓝图 CBlueprint *mopGetBlueprint() &#123; return mopBluprint; &#125;; virtual string msBuildWheel() = 0; virtual string msBuildEngine() = 0;protected: //设计蓝图 CBlueprint *mopBluprint;&#125;; 看到Blueprint类了，它中文的意思是“蓝图”，你要建造一辆车必须有一个设计样稿或者蓝图吧，否则怎么生产？怎么装配？该类就是一个可参考的生产样本。 生产蓝图12345678910111213class CBlueprint&#123;public: string msGetWheel()&#123; return msWheel; &#125; void mvSetWheel(const string &amp;sWheel)&#123; msWheel = sWheel; &#125; string msGetEngine()&#123; return msEngine; &#125; void mvSetEngine(const string &amp;sEngine) &#123; msEngine = sEngine; &#125;private: string msWheel; string msEngine;&#125;; 这和一个具体的产品Car类是一样的？错，不一样！它是一个蓝图，是一个可以参考的模板，有一个蓝图可以设计出非常多的产品，如有一个R系统的奔驰商务车设计蓝图，我们就可以生产出一系列的奔驰车。它指导我们的产品生产，而不是一个具体的产品。我们来看宝马车建造车间。 宝马车建造车间12345678class CBMWBuilder : public CCarBuilder&#123;public: CBMWBuilder()&#123;&#125;; ~CBMWBuilder()&#123;&#125;; string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125; string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;&#125;; 这是非常简单的类。只要获得一个蓝图，然后按照蓝图制造引擎和车轮即可，剩下的事情就交给抽象的建造者进行装配。奔驰车间与此类似。 奔驰车建造车间12345678class CBenzBuilder : public CCarBuilder&#123;public: CBenzBuilder()&#123;&#125;; ~CBenzBuilder()&#123;&#125;; string msBuildWheel() &#123; return mopBluprint-&gt;msGetWheel(); &#125; string msBuildEngine() &#123; return mopBluprint-&gt;msGetEngine(); &#125;&#125;; 两个建造车间都已经完成，那现在的问题就变成了怎么让车间运作，谁来编写蓝图？谁来协调生产车间？谁来对外提供最终产品？于是导演类出场了，它不仅仅有每个车间需要的设计蓝图，还具有指导不同车间装配顺序的职责。 导演类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class CDirector&#123;public: CDirector() &#123; mopBenzBuilder = new CBenzBuilder; mopBMWBuilder = new CBMWBuilder; &#125; ~CDirector()&#123;&#125;; //生产奔驰SUV CCar *mopCreateBenzSuv() &#123; //制造出汽车 return mopCreateCar(mopBenzBuilder, &quot;benz的引擎&quot;, &quot;benz的轮胎&quot;); &#125; // 生产出一辆宝马商务车 CCar *mopCreateBMWVan() &#123; return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;BMW的轮胎&quot;); &#125; // 生产出一个混合车型 CCar *mopCreateComplexCar() &#123; return mopCreateCar(mopBMWBuilder, &quot;BMW的引擎&quot;, &quot;benz的轮胎&quot;); &#125;private: // 生产车辆 CCar *mopCreateCar(CCarBuilder *opCarBuilder, const string &amp;sEngine, const string &amp;sWheel) &#123; //导演怀揣蓝图 CBlueprint *op_bp = new CBlueprint(); op_bp-&gt;mvSetEngine(sEngine); op_bp-&gt;mvSetWheel(sWheel); opCarBuilder-&gt;mvSetBlueprint(op_bp); return opCarBuilder-&gt;mopBuildCar(); &#125;private: CCarBuilder *mopBenzBuilder; CCarBuilder *mopBMWBuilder;&#125;; 这里有一个私有方法mopCreateCar，其作用是减少导演类中的方法对蓝图的依赖，全部由该方法来完成。 场景调用12345678910111213141516171819202122int main()&#123; //定义出导演类 CDirector o_director; //给我一辆奔驰车SUV cout &lt;&lt; &quot;===制造一辆奔驰SUV===&quot; &lt;&lt; endl; CCar *op_benz_suv = o_director.mopCreateBenzSuv(); cout &lt;&lt; op_benz_suv-&gt;msGetInfo().c_str() &lt;&lt; endl; //给我一辆宝马商务车 cout &lt;&lt; &quot;===制造一辆宝马商务车===&quot; &lt;&lt; endl; CCar *op_bmw_van = o_director.mopCreateBMWVan(); cout &lt;&lt; op_bmw_van-&gt;msGetInfo().c_str() &lt;&lt; endl; //给我一辆混合车型 cout &lt;&lt; &quot;===制造一辆混合车===&quot; &lt;&lt; endl; CCar *op_complex_car = o_director.mopCreateComplexCar(); cout &lt;&lt; op_complex_car-&gt;msGetInfo().c_str() &lt;&lt; endl; return 0;&#125; 调用结果场景类只要找到导演类（也就是车间主任了）说给我制造一辆这样的宝马车，车间主任马上通晓你的意图，设计了一个蓝图，然后命令建造车间拼命加班加点建造，最终返回给你一件最新出品的产品，运行结果如下所示 小结注意最后一个运行结果片段，我们可以立刻生产出一辆混合车型，只要有设计蓝图，这非常容易实现。反观我们的抽象工厂模式，它是不可能实现该功能的，因为它更关注的是整体，而不关注到底用的是奔驰引擎还是宝马引擎，而我们的建造者模式却可以很容易地实现该设计，市场信息变更了，我们就可以立刻跟进，生产出客户需要的产品。 总结注意看上面的描述，我们在抽象工厂模式中使用“工厂”来描述构建者，而在建造者模式中使用“车间”来描述构建者，其实我们已经在说它们两者的区别了，抽象工厂模式就好比是一个一个的工厂，宝马车工厂生产宝马SUV和宝马VAN，奔驰车工厂生产奔驰车SUV和奔驰VAN，它是从一个更高层次去看对象的构建，具体到工厂内部还有很多的车间，如制造引擎的车间、装配引擎的车间等，但这些都是隐藏在工厂内部的细节，对外不公布。也就是对领导者来说，他只要关心一个工厂到底是生产什么产品的，不用关心具体怎么生产。而建造者模式就不同了，它是由车间组成，不同的车间完成不同的创建和装配任务，一个完整的汽车生产过程需要引擎制造车间、引擎装配车间的配合才能完成，它们配合的基础就是设计蓝图，而这个蓝图是掌握在车间主任（导演类）手中，它给建造车间什么蓝图就能生产什么产品，建造者模式更关心建造过程。虽然从外界看来一个车间还是生产车辆，但是这个车间的转型是非常快的，只要重新设计一个蓝图，即可产生不同的产品，这有赖于建造者模式的功劳。 相对来说，抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。 工厂模式VS建造者模式 工厂模式VS建造者模式Create by bingcaihaung 概述工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，才能创造一个超人。 工厂方法建造超人类图首先我们按照工厂方法创造超人，我们来看类图。类图中我们按照年龄段把超人分为两种类型：成年超人（如克拉克、超能先生）和未成年超人（如Dash、Jack）。这是一个非常正宗的工厂方法模式，定义一个产品的接口，然后再定义两个实现，通过超人制造工厂制造超人。 抽象超人想想看我们对超人最大印象是什么？当然是他的超能力，我们以specialTalent（特殊天赋）方法来代表，先看抽象产品类。 1234567class CISuperMan&#123;public: CISuperMan()&#123;&#125;; ~CISuperMan()&#123;&#125;; virtual void mvSpecialTalent() = 0;&#125;; 成年超人产品的接口定义好了，我们再来看具体的产品。先看成年超人，很简单。 12345678910class CAdultSuperMan : public CISuperMan&#123;public: CAdultSuperMan()&#123;&#125;; ~CAdultSuperMan()&#123;&#125;; void mvSpecialTalent() &#123; cout &lt;&lt; &quot;超人力大无穷&quot; &lt;&lt; endl; &#125;&#125;; 未成年超人12345678910class ChildSuperMan : public CISuperMan&#123;public: ChildSuperMan()&#123;&#125;; ~ChildSuperMan()&#123;&#125;; void mvSpecialTalent() &#123; cout &lt;&lt; &quot;小超人的能力是刀枪不入、 快速运动&quot; &lt;&lt; endl; &#125;&#125;; 工厂产品都具备，那我们编写一个工厂类，其意图就是生产超人，具体是成年超人还是未成年超人，则由客户端决定。 123456789101112131415161718192021class CSuperManFactory&#123;public: CSuperManFactory()&#123;&#125;; ~CSuperManFactory()&#123;&#125;; CISuperMan *mopCreateSuperMan(string sType) &#123; if (&quot;adult&quot; == sType) &#123; return new CAdultSuperMan; &#125; else if (&quot;child&quot; == sType) &#123; return new CChildSuperMan; &#125; else &#123; return NULL; &#125; &#125;&#125;; 调用产品有了，工厂类也有了，剩下的工作就是开始生产超人。 12345678int main()&#123; CSuperManFactory o_factory; CISuperMan *op_super = o_factory.mopCreateSuperMan(&quot;adult&quot;); op_super-&gt;mvSpecialTalent(); return 0;&#125; 总结建立了一个超人生产工厂，年复一年地生产超人，对于具体生产出的产品，不管是成年超人还是未成年超人，都是一个模样：深蓝色紧身衣、胸前S标记、内裤外穿，没有特殊的地方。但是我们的目的达到了——生产出超人，这就是我们的意图。具体怎么生产、怎么组装，这不是工厂方法模式要考虑的，也就是说，工厂模式关注的是一个产品整体，生产出的产品应该具有相似的功能和架构。 注意：通过工厂方法模式生产出对象，然后由客户端进行对象的其他操作，但是并不代表所有生产出的对象都必须具有相同的状态和行为，它是由产品所决定。 建造者模式建造超人类图我们在抽象建造者上使用了模板方法模式，每一个建造者都必须返回一个产品，但是产品是如何制造的，则由各个建造者自己负责。 代码产品类超人这个产品是由三部分组成：躯体、特殊技能、身份标记，这就类似于电子产品，首先生产出一个固件，然后再安装一个灵魂（软件驱动），最后再打上产品标签。一个崭新的产品就诞生。我们的超人也是这样生产的，先生产一个普通的躯体，然后注入特殊技能，最后打上S标签，一个超人生产完毕。 1234567891011121314151617181920class CSuperMan&#123;public: CSuperMan()&#123;&#125;; ~CSuperMan()&#123;&#125;; string msGetBody() &#123; return msBody; &#125;; void mvSetBody(const string &amp;sBody) &#123; msBody = sBody; &#125;; string msGetSpecialTalent() &#123; return msSpecialTalent; &#125;; void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; msSpecialTalent = sSpecialTalent; &#125;; string msGetSpecialSymbol() &#123; return msSpecialSymbol; &#125;; void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; msSpecialSymbol = sSpecialSymbol; &#125;;private: string msBody; //超人的躯体 string msSpecialTalent; //超人的特殊技能 string msSpecialSymbol; //超人的标志&#125;; 抽象建造者一个典型的模板方法模式，超人的各个部件（躯体、灵魂、标志）都准备好了，具体怎么组装则是由实现类来决定。 12345678910111213141516class CBuilder&#123;protected: CBuilder() &#123; mopSuperMan = new CSuperMan; &#125;; ~CBuilder(); void mvSetBody(const string &amp;sBody) &#123; this-&gt;mopSuperMan-&gt;mvSetBody(sBody); &#125;; void mvSetSpecialTalent(const string &amp;sSpecialTalent) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialTalent(sSpecialTalent); &#125;; void mvSetSpecialSymbol(const string &amp;sSpecialSymbol) &#123; this-&gt;mopSuperMan-&gt;mvSetSpecialSymbol(sSpecialSymbol); &#125;;public: virtual CSuperMan *mopGetSuperMan() = 0;protected: CSuperMan *mopSuperMan;&#125;; 成年超人设计模式只是提供了一个解决问题的意图：复杂对象的构建与它的表示分离，而没有具体定出一个设计模式必须是这样的实现，必须是这样的代码，灵活运用模式才是其根本，我们通过模版方法加上建造者模式来建造超人。 123456789101112131415class CAdultSuperManBuilder : public CBuilder&#123;public: CAdultSuperManBuilder()&#123;&#125;; ~CAdultSuperManBuilder()&#123;&#125;; CSuperMan *mopGetSuperMan() &#123; mvSetBody(&quot;强壮的躯体&quot;); mvSetSpecialTalent(&quot;会飞行&quot;); mvSetSpecialSymbol(&quot;胸前带S标记&quot;); return mopSuperMan; &#125;&#125;; 未成年超人123456789101112131415class CChildSuperManBuilder : public CBuilder&#123;public: CChildSuperManBuilder()&#123;&#125;; ~CChildSuperManBuilder()&#123;&#125;; CSuperMan *mopGetSuperMan() &#123; mvSetBody(&quot;强壮的躯体&quot;); mvSetSpecialTalent(&quot;刀枪不入&quot;); mvSetSpecialSymbol(&quot;胸前带S标记&quot;); return mopSuperMan; &#125;&#125;; 大家注意看我们这两个具体的建造者，它们都关注了产品的各个部分，在某些应用场景下甚至会关心产品的构建顺序，即使是相同的部件，装配顺序不同，产生的结果也不同，这也正是建造者模式的意图：通过不同的部件、不同装配产生不同的复杂对象。 导演类导演类很简单就不多说了。 12345678910111213class CDirector &#123;public: CDirector()&#123;&#125;; ~CDirector()&#123;&#125;; //两个建造者的应用 CBuilder *mopAdultBuilder = new CAdultSuperManBuilder(); //未成年超人的建造者 CBuilder *CChildBuilder = new CChildSuperManBuilder(); //建造一个成年、 会飞行的超人 CSuperMan *mopGetAdultSuperMan()&#123; return mopAdultBuilder-&gt;mopGetSuperMan(); &#125; // 建造一个未成年、 刀枪不入的超人 CSuperMan *mopGetChildSuperMan()&#123; return CChildBuilder-&gt;mopGetSuperMan(); &#125;&#125;; 场景调用123456789101112int main()&#123; CDirector o_director; //建造一个成年超人 CSuperMan *op_adult = o_director.mopGetAdultSuperMan(); // 展示超人信息 cout &lt;&lt; op_adult-&gt;msGetSpecialTalent().c_str() &lt;&lt; endl; return 0;&#125; 这个场景类的写法与工厂方法模式是相同的，但是你可以看到，在建立超人的过程中，建造者必须关注超人的各个部件，而工厂方法模式则只关注超人的整体，这就是两者的区别。 总结工厂方法模式和建造者模式都属于对象创建类模式，都用来创建类的对象。但它们之间的区别还是比较明显的。 意图不同 在工厂方法模式里，我们关注的是一个产品整体，如超人整体，无须关心产品的各部分是如何创建出来的；但在建造者模式中，一个具体产品的产生是依赖各个部件的产生以及装配顺序，它关注的是“由零件一步一步地组装出产品对象”。简单地说，工厂模式是一个对象创建的粗线条应用，建造者模式则是通过细线条勾勒出一个复杂对象，关注的是产品组成部分的创建过程。 产品的复杂度不同 工厂方法模式创建的产品一般都是单一性质产品，如成年超人，都是一个模样，而建造者模式创建的则是一个复合产品，它由各个部件复合而成，部件不同产品对象当然不同。这不是说工厂方法模式创建的对象简单，而是指它们的粒度大小不同。一般来说，工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。 两者的区别有了，那在具体的应用中，我们该如何选择呢？是用工厂方法模式来创建对象，还是用建造者模式来创建对象，这完全取决于我们在做系统设计时的意图，如果需要详细关注一个产品部件的生产、安装步骤，则选择建造者，否则选择工厂方法模式。 装饰模式VS适配器模式 装饰模式VS适配器模式 概述装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类），适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。 大家都应该听过丑小鸭的故事吧，我们今天就用这两种模式分别讲述丑小鸭的故事。话说鸭妈妈有5个孩子，其中4个孩子都是黄白相间的颜色，而最小的那只也就是叫做丑小鸭的那只，是纯白色的，与兄弟姐妹不相同，在遭受了诸多的嘲讽和讥笑后，最终丑小鸭变成了一只美丽的天鹅。那我们如何用两种不同模式来描述这一故事呢？ 装饰模式描述丑小鸭类图用装饰模式来描述丑小鸭，首先就要肯定丑小鸭是一只天鹅，只是因为她小或者是鸭妈妈的无知才没有被认出是天鹅，经过一段时间后，它逐步变成一个漂亮、自信、优美的白天鹅。根据分析我们可以这样设计，先设计一个丑小鸭，然后根据时间先后来进行不同的美化处理，怎么美化呢？先长出漂亮的羽毛，然后逐步展现出异于鸭子的不同行为，如飞行，最终在具备了所有的行为后，它就成为一只纯粹的白天鹅了。类图比较简单，非常标准的装饰模式。 代码天鹅接口我们按照故事的情节发展一步一步地实现程序。初期的时候，丑小鸭表现得很另类，叫声不同，外形不同，致使周围的亲戚、朋友都对她鄙视，那我们来建立这个过程，由于丑小鸭的本质就是一个天鹅，我们就先生成一个天鹅的接口。 12345678910111213class CISwan&#123;public: CISwan()&#123;&#125;; ~CISwan()&#123;&#125;; //天鹅会飞 virtual void mvFly() = 0; //天鹅会叫 virtual void mvCry() = 0; //天鹅都有漂亮的外表 virtual void mvDesAppaearance() = 0;&#125;; 丑小鸭我们定义了天鹅的行为，都会飞行、会叫，并且可以描述她们漂亮的外表。丑小鸭是一只白天鹅，是”is-a”的关系，也就是需要实现这个接口了。 123456789101112131415class CUglyDuckling : public CISwan&#123;public: CUglyDuckling()&#123;&#125;; ~CUglyDuckling()&#123;&#125;; //丑小鸭的叫声 void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;; //丑小鸭的外形 void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是脏兮兮的白色， 毛茸茸的大脑袋&quot; &lt;&lt; endl; &#125; //丑小鸭还比较小，不能飞 void mvFly()&#123; cout &lt;&lt; &quot;不能飞行&quot; &lt;&lt; endl; &#125;;&#125;; 抽象装饰类丑小鸭具备了天鹅的所有行为和属性，因为她本来就是一只白天鹅，只是因为她太小了还不能飞行，也不能照顾自己，所以丑丑的，在经过长时间的流浪生活后，丑小鸭长大了。终于有一天，她发现自己竟然变成了一只美丽的白天鹅，有着漂亮、洁白的羽毛，而且还可以飞行，这完全是一种升华行为。我们来看看她的行为（飞行）和属性（外形）是如何加强的。 12345678910111213class CDecorator : public CISwan&#123;public: CDecorator(CISwan *opSwan)&#123; mopSwan = opSwan; &#125;; ~CDecorator()&#123;&#125;; virtual void mvCry() &#123; mopSwan-&gt;mvCry(); &#125; virtual void mvFly() &#123; mopSwan-&gt;mvFly(); &#125; virtual void mvDesAppaearance() &#123; mopSwan-&gt;mvDesAppaearance(); &#125;private: CISwan *mopSwan;&#125;; 外形装饰这是一个非常简单的代理模式。我们再来看丑小鸭是如何开始变得美丽的，变化是由外及里的，有了漂亮的外表才有内心的实质变化。 12345678class CBeautifyAppearance : public CDecorator&#123;public: CBeautifyAppearance(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;; // 外表美化处理 void mvDesAppaearance() override &#123; cout &lt;&lt; &quot;外表是纯白色的，非常惹人喜爱！&quot; &lt;&lt; endl; &#125;;&#125;; 行为装饰丑小鸭最后发现自己还能飞行，这是一个行为突破，是对原有行为“不会飞行”的一种强化。 123456789class CStrongBehavior : public CDecorator&#123;public: CStrongBehavior(CISwan *opSwan) : CDecorator(opSwan) &#123;&#125;; ~CStrongBehavior()&#123;&#125;; // 会飞行了 void mvFly() override &#123; cout &lt;&lt; &quot;会飞行了！&quot; &lt;&lt; endl; &#125;;&#125;; 场景调用所有的故事元素我们都具备了，就等有人来讲故事了。 1234567891011121314151617181920212223int main()&#123; //很久很久以前， 这里有一个丑陋的小鸭子 cout &lt;&lt; &quot;===很久很久以前， 这里有一只丑陋的小鸭子===&quot; &lt;&lt; endl; CISwan *op_duck = new CUglyDuckling; //展示一下小鸭子 op_duck-&gt;mvDesAppaearance(); op_duck-&gt;mvCry(); op_duck-&gt;mvFly(); cout &lt;&lt; &quot;===小鸭子终于发现自己是一只天鹅====&quot; &lt;&lt; endl; //首先外形变化了 op_duck = new CBeautifyAppearance(op_duck); //其次行为也发生了改变 op_duck = new CStrongBehavior(op_duck); //虽然还是叫丑小鸭， 但是已经发生了很大变化 op_duck-&gt;mvDesAppaearance(); op_duck-&gt;mvCry(); op_duck-&gt;mvFly(); return 0;&#125; 执行结果 使用装饰模式描述丑小鸭蜕变的过程是如此简单，它关注了对象功能的强化，是对原始对象的行为和属性的修正和加强，把原本被人歧视、冷落的丑小鸭通过两次强化处理最终转变为受人喜爱、羡慕的白天鹅。 适配器模式实现丑小鸭类图采用适配器模式实现丑小鸭变成白天鹅的过程要从鸭妈妈的角度来分析，鸭妈妈有5个孩子，它认为这5个孩子都是她的后代，都是鸭类，但是实际上是有一只（也就是丑小鸭）不是真正的鸭类，她是一只小白天鹅，因为太小，差别太细微，很难分辨，导致鸭妈妈认为她是一只鸭子，从鸭子的审美观来看，丑小鸭是丑陋的。通过分析，我们要做的就是要设计两个对象：鸭和天鹅，然后鸭妈妈把一只天鹅看成了小鸭子，最终时间到来的时候丑小鸭变成了白天鹅。 类图非常简单，我们定义了两个接口：鸭类接口和天鹅类接口，然后建立了一个适配器UglyDuckling，把一只白天鹅封装成了小鸭子。 代码鸭类接口123456789101112131415class CIDuck&#123;public: CIDuck()&#123;&#125;; ~CIDuck()&#123;&#125;; //会叫 virtual void mvCry() = 0; //鸭子的外形 virtual void mvDesAppearance() = 0; //描述鸭子的其他行为 virtual void mvDesBehavior() = 0;&#125;; 鸭类有3个行为，一个是鸭会叫，一个是外形描述，还有一个是综合性的其他行为描述，例如会游泳等。 小鸭子123456789101112class CDuckling : public CIDuck&#123;public: CDuckling()&#123;&#125;; ~CDuckling()&#123;&#125;; void mvCry() &#123; cout &lt;&lt; &quot;叫声是嘎——嘎——嘎&quot; &lt;&lt; endl; &#125;; void mvDesAppearance() &#123; cout &lt;&lt; &quot;外形是黄白相间，嘴长&quot; &lt;&lt; endl; &#125;; // 鸭子的其他行为， 如游泳 void mvDesBehavior() &#123; cout &lt;&lt; &quot;会游泳&quot; &lt;&lt; endl; &#125;;&#125;; 白天鹅4只正宗的小鸭子形象已经清晰地定义出来了。鸭妈妈还有一个孩子，就是另类的丑小鸭，她实际是一只白天鹅。我们先定义出白天鹅。 1234567891011121314151617181920212223242526272829class CISwan&#123;public: CISwan()&#123;&#125;; ~CISwan()&#123;&#125;; //天鹅会飞 virtual void mvFly() = 0; //天鹅会叫 virtual void mvCry() = 0; //天鹅都有漂亮的外表 virtual void mvDesAppaearance() = 0;&#125;;class CWhiteSwan : public CISwan&#123;public: CWhiteSwan()&#123;&#125;; ~CWhiteSwan()&#123;&#125;; //白天鹅的叫声 void mvCry() &#123; cout &lt;&lt; &quot;叫声是克噜——克噜——克噜&quot; &lt;&lt; endl; &#125;; //白天鹅的外形 void mvDesAppaearance() &#123; cout &lt;&lt; &quot;外形是纯白色，惹人喜爱&quot; &lt;&lt; endl; &#125; //天鹅是能够飞行的 void mvFly()&#123; cout &lt;&lt; &quot;能够飞行&quot; &lt;&lt; endl; &#125;;&#125;; 当成鸭子的白天鹅但是，鸭妈妈却不认为自己这个另类的孩子是白天鹅，它从自己的观点出发，认为她很丑陋，有碍自己的脸面，于是驱赶她——鸭妈妈把这只小天鹅误认为一只鸭。 1234567891011121314class CUglyDuckling : public CWhiteSwan, public CIDuck&#123;public: CUglyDuckling()&#123;&#125;; ~CUglyDuckling()&#123;&#125;; void mvCry() &#123; CWhiteSwan::mvCry(); &#125;; void mvDesAppearance() &#123; CWhiteSwan::mvDesAppaearance(); &#125;; void mvDesBehavior() &#123; cout &lt;&lt; &quot;会游泳！&quot; &lt;&lt; endl; CWhiteSwan::mvFly(); &#125;&#125;; 调用天鹅被看成了鸭子，有点暴殄天物的感觉。我们再来创建一个场景类来描述这一场景。 12345678910111213141516int main()&#123; //鸭妈妈有5个孩子， 其中4个都是一个模样 cout &lt;&lt; &quot;===妈妈有五个孩子， 其中四个模样是这样的： ===&quot; &lt;&lt; endl; CIDuck *op_duck = new CDuckling(); op_duck-&gt;mvCry(); op_duck-&gt;mvDesAppearance(); op_duck-&gt;mvDesBehavior(); cout &lt;&lt; &quot;===一只独特的小鸭子， 模样是这样的： ===&quot; &lt;&lt; endl; CIDuck *op_ugly_duck = new CUglyDuckling; op_ugly_duck-&gt;mvCry(); op_ugly_duck-&gt;mvDesAppearance(); op_ugly_duck-&gt;mvDesBehavior(); return 0;&#125; 执行结果 小天鹅被认为是一只丑陋的小鸭子…采用适配器模式讲述丑小鸭的故事，我们首先观察到的是鸭与天鹅的不同点，建立了不同的接口以实现不同的物种，然后在需要的时候（根据故事情节）把一个物种伪装成另外一个物种，实现不同物种的相同处理过程，这就是适配器模式的设计意图。 总结我们用两个模式实现了丑小鸭的美丽蜕变。我们发现：这两个模式有较多的不同点。 意图不同 装饰模式的意图是加强对象的功能，例子中就是把一个怯弱的小天鹅强化成了一个美丽、自信的白天鹅，它不改变类的行为和属性，只是增加（当然了，减弱类的功能也是可能存在的）功能，使美丽更加美丽，强壮更加强壮，安全更加安全；而适配器模式关注的则是转化，它的主要意图是两个不同对象之间的转化，它可以把一个天鹅转化为一个小鸭子看待，也可以把一只小鸭子看成是一只天鹅，它关注转换。 施与对象不同 装饰模式装饰的对象必须是自己的同宗，也就是相同的接口或父类，只要在具有相同的属性和行为的情况下，才能比较行为是增加还是减弱；适配器模式则必须是两个不同的对象，因为它着重于转换，只有两个不同的对象才有转换的必要，如果是相同对象还转换什么？！ 场景不同 装饰模式在任何时候都可以使用，只要是想增强类的功能，而适配器模式则是一个补救模式，一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用。 扩展性不同 装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编译器知识]]></title>
    <url>%2F2018%2F08%2F13%2FC-%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[LLVM、Clang介绍编译与链接在正式开始之前，插播一段编译器和链接器。编译器主要用于将源代码从高级语言翻译成低级语言（汇编语言、目标代码、机器码），输出目标文件。链接器主要用于将一个或多个目标文件（obj）与库文件（lib）合并成一个可执行文件（exe）或者库文件（lib、dll等）。 编译器可分为前端（front end）和后端（back end），两者以中间代码（IR，Intermediate Representation）为分界。 也可划分成前端、中端和后端，这里的中端主要完成对IR的优化工作，输出仍为IR。 LLVM与ClangLLVM全称为Low Level Virtual Machine，按wiki的说法，它是“a collection of modular and reusable compiler and toolchain technologies”，起初只支持C/C++，现已支持多种语言。提及LLVM可能指代的是LLVM project/infrastructure（框架，编译器各个环节对应项目的集合）、An LLVM-based compiler、LLVM libraries（库）、LLVM core（编译器的后端）、The LLVM IR，具体如下： The LLVM project/infrastructure: This is an umbrella for several projects that, together, form a complete compiler: frontends, backends, optimizers, assemblers, linkers, libc++, compiler-rt, and a JIT engine. The word “LLVM” has this meaning, for example, in the following sentence: “LLVM is comprised of several projects”. An LLVM-based compiler: This is a compiler built partially or completely with the LLVM infrastructure. For example, a compiler might use LLVM for the frontend and backend but use GCC and GNU system libraries to perform the final link. LLVM has this meaning in the following sentence, for example: “I used LLVM to compile C programs to a MIPS platform”. LLVM libraries: This is the reusable code portion of the LLVM infrastructure. For example, LLVM has this meaning in the sentence: “My project uses LLVM to generate code through its Just-in-Time compilation framework”. LLVM core: The optimizations that happen at the intermediate language level and the backend algorithms form the LLVM core where the project started. LLVM has this meaning in the following sentence: “LLVM and Clang are two different projects”. The LLVM IR: This is the LLVM compiler intermediate representation. LLVM has this meaning when used in sentences such as “I built a frontend that translates my own language to LLVM”.——What exactly is LLVM 而Clang呢？Clang是a C language family frontend for LLVM，是C-like语言的编译器前端，支持C, C++, Objective C/C++, OpenCL C等。后端使用LLVM，现已兼容GCC——Clang.LLVM。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译器</tag>
        <tag>LLVM</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的设计模式（C++实现）]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我所理解的设计模式（C++实现）###“一句话总结”和索引 “一句话总结”和索引 我所理解的设计模式系列已经全部完成，在写该系列的过程中收获很多。俗话说得好，好记性不如烂笔头，写出来不单单可以增加自己对知识的理解，也可以很好的分享给大家，大家共同学习。这里是最后一篇，来给所有的设计模式来个一句话总结，在让我们“过电影”般在过一遍。 按照目的来分，设计模式可以分为创建型模式、结构型模式和行为型模式。 创建型模式用来处理对象的创建过程；结构型模式用来处理类或者对象的组合；行为型模式用来对类或对象怎样交互和怎样分配职责进行描述。 创建型模式用来处理对象的创建过程，主要包含以下5种设计模式： 工厂方法模式（Factory Method Pattern）的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 抽象工厂模式（Abstract Factory Pattern）的意图是提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。 建造者模式（Builder Pattern）的意图是将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 单例模式（Singleton Pattern）是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 结构型模式用来处理类或者对象的组合，主要包含以下7种设计模式： 适配器模式（Adapter Pattern）是将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式（Bridge Pattern）是将抽象部分与实际部分分离，使它们都可以独立的变化。 组合模式（Composite Pattern）是将对象组合成树形结构以表示“部分–整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。 装饰者模式（Decorator Pattern）动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。 外观模式（Facade Pattern）是为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式（Flyweight Pattern）是以共享的方式高效的支持大量的细粒度的对象。 代理模式（Proxy Pattern）就是为其他对象提供一种代理以控制对这个对象的访问。 行为型模式用来对类或对象怎样交互和怎样分配职责进行描述，主要包含以下11种设计模式： 责任链模式（Chain of Responsibility Pattern），在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 命令模式（Command Pattern）是将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 解释器模式（Interpreter Pattern）就是描述了如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。 迭代器模式（Iterator Pattern）是提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 中介者模式（Mediator Pattern）就是定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。 备忘录模式（Memento Pattern）是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 观察者模式（Observer Pattern）定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 状态模式（State Pattern）就是允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。 策略模式（Strategy Pattern）就是准备一组算法，并将每一个算法封装起来，使得它们可以互换。 模板方法模式（Template Method Pattern）使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 访问者模式（Visitor Pattern）就是表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 工厂方法模式（Factory Method Pattern） 工厂方法模式（Factory Method Pattern） 工厂方法模式不同于简单工厂模式的地方在于工厂方法模式把对象的创建过程放到里子类里。这样工厂父对象和产品父对象一样，可以是抽象类或者接口，只定义相应的规范或操作，不涉及具体的创建或实现细节。 其类图如下： 实例代码为： 123456789101112131415161718192021222324252627#pragma once class IProduct &#123; public: IProduct(void); virtual ~IProduct(void); &#125;; #pragma once #include &quot;iproduct.h&quot; class IPad : public IProduct &#123; public: IPad(void); ~IPad(void); &#125;; #pragma once #include &quot;iproduct.h&quot; class IPhone : public IProduct &#123; public: IPhone(void); ~IPhone(void); &#125;; 12345678910111213141516171819202122232425262728293031323334353637#pragma once #include&quot;IProduct.h&quot; class IFactory &#123; public: IFactory(void); virtual ~IFactory(void); virtual IProduct* getProduct(); &#125;; #pragma once #include &quot;ifactory.h&quot; class IPadFactory : public IFactory &#123; public: IPadFactory(void); ~IPadFactory(void); virtual IProduct* getProduct(); &#125;; #pragma once #include &quot;ifactory.h&quot; class IPhoneFactory : public IFactory &#123; public: IPhoneFactory(void); ~IPhoneFactory(void); virtual IProduct* getProduct(); &#125;; 关键的实现： 123456789101112131415161718192021222324252627282930313233#include &quot;StdAfx.h&quot; #include &quot;IPadFactory.h&quot; #include&quot;IPad.h&quot; IPadFactory::IPadFactory(void) &#123; &#125; IPadFactory::~IPadFactory(void) &#123; &#125; IProduct* IPadFactory::getProduct() &#123; return new IPad(); &#125; #include &quot;StdAfx.h&quot; #include &quot;IPhoneFactory.h&quot; #include&quot;IPhone.h&quot; IPhoneFactory::IPhoneFactory(void) &#123; &#125; IPhoneFactory::~IPhoneFactory(void) &#123; &#125; IProduct* IPhoneFactory::getProduct() &#123; return new IPhone(); &#125; 调用方式： 12345678910111213141516#include &quot;stdafx.h&quot; #include&quot;IFactory.h&quot; #include&quot;IPadFactory.h&quot; #include&quot;IPhoneFactory.h&quot; #include&quot;IProduct.h&quot; int _tmain(int argc, _TCHAR* argv[]) &#123; IFactory *fac = new IPadFactory(); IProduct *pro = fac-&gt;getProduct(); fac = new IPhoneFactory(); pro = fac-&gt;getProduct(); return 0; &#125; 抽象工厂模式（Abstract Factory Pattern）解决的问题：在系统里a,b,c三个组件必须同时使用，但是a的同类 a1和a2这三种方法有共同特点但是是互斥的，b,b1,b2和c,c1,c2和a/a1/a2是一样的。就比如说创建在不同操作系统的视窗环境下都能够运行的系统时，Unix下面有unixButton和 unixText，Win下面也有winButton和winText，unixButton和unixText必须在一个系统unix里面用，而winButton和winText只能在Win下面用。但是winButton和unixButton这两种东西都是有相同的特点的，比如说按下去之后会触发事件，比如说他上面有文字描述等等，但是winButton和unixButton却又是不可以混用的。 那么此问题就可以用抽象工厂很好的解决：在抽象工厂模式中如何选择使用 winButton ,winText，有具体的工厂类winFactory来负责，因为他们含有选择合适的产品对象的逻辑，所以是与应用系统的商业逻辑紧密相关的。而抽象工厂类来负责定义接口，他才是抽象工厂模式的核心。而winButton/macButton则是一种产品族，有共同的特点，他们具体特点有抽象产品类或者接口来定义和描述。但是他们具体的实现有具体的产品类负责，这些是客户端最终想要的东西，所以其内部一定充满了应用系统的商业逻辑（触发逻辑/样式逻辑等）。 类图结构： 样例实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// CplusplusAbstractFactory.cpp : Defines the entry point for the console application. // #include &quot;stdafx.h&quot; #include&lt;typeinfo&gt; // &quot;AbstractProductA&quot; 草食动物 class Herbivore &#123; &#125;; // &quot;AbstractProductB&quot; 食肉动物 class Carnivore &#123; public: // Methods virtual void Eat( Herbivore *h ) &#123;&#125;; &#125;; // &quot;ProductA1&quot; class Wildebeest : public Herbivore &#123; &#125;; // &quot;ProductA2&quot; class Bison : public Herbivore &#123; &#125;; // &quot;ProductB1&quot; class Lion : public Carnivore &#123; public: // Methods void Eat( Herbivore *h ) &#123; // eat wildebeest printf(&quot;Lion eats %s\n&quot;,typeid(h).name()); &#125; &#125;; // &quot;ProductB2&quot; class Wolf : public Carnivore &#123; public: // Methods void Eat( Herbivore *h ) &#123; // Eat bison printf(&quot;Wolf eats %s\n&quot;,typeid(h).name()); &#125; &#125;; // &quot;AbstractFactory&quot; class ContinentFactory &#123; public: // Methods virtual Herbivore* CreateHerbivore() &#123; return new Herbivore(); &#125; virtual Carnivore* CreateCarnivore() &#123; return new Carnivore(); &#125; &#125;; // &quot;ConcreteFactory1&quot; class AfricaFactory : public ContinentFactory &#123; public: // Methods Herbivore* CreateHerbivore() &#123; return new Wildebeest(); &#125; Carnivore* CreateCarnivore() &#123; return new Lion(); &#125; &#125;; // &quot;ConcreteFactory2&quot; class AmericaFactory : public ContinentFactory &#123; public: // Methods Herbivore* CreateHerbivore() &#123; return new Bison(); &#125; Carnivore* CreateCarnivore() &#123; return new Wolf(); &#125; &#125;; // &quot;Client&quot; class AnimalWorld &#123; private: // Fields Herbivore* herbivore; Carnivore* carnivore; public: // Constructors AnimalWorld( ContinentFactory *factory ) &#123; carnivore = factory-&gt;CreateCarnivore(); herbivore = factory-&gt;CreateHerbivore(); &#125; // Methods void RunFoodChain() &#123; carnivore-&gt;Eat(herbivore); &#125; &#125;; int _tmain(int argc, _TCHAR* argv[]) &#123; // Create and run the Africa animal world ContinentFactory *africa = new AfricaFactory(); AnimalWorld *world = new AnimalWorld( africa ); world-&gt;RunFoodChain(); // Create and run the America animal world ContinentFactory *america = new AmericaFactory(); world = new AnimalWorld( america ); world-&gt;RunFoodChain(); return 0; &#125; “开放-封闭”原则：抽象工厂可以很好的应对增加新产品族的问题（即a4/b4/c4），且符合“开放-封闭”原则，但是若是增加新的产品结构的话（即d/d1/d2），就是说a/b/c/d这4中方法必须同时使用了，那就必须修改工厂角色。不符合“开放-封闭”原则。综合来讲，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，而不能为新的产品结构的增加提供这样的方便。 实现要点： 在抽象工厂模式中，选用哪种产品族的问题，需要采用工厂方法或简单工厂模式来配合解决。 抽象工厂模式和工厂方法模式一样，都把对象的创建延迟到了他的子类中。 具体的工厂类可以设计成单例类，他只向外界提供自己唯一的实例。 与其他工厂模式的联系和异同： 抽象工厂模式中的具体工厂负责生产一个产品族的产品。而产品族的增加只需要增加与其对应的具体工厂。 3种工厂模式都是创建型模式，都是创建对象的，但都把产品具体创建的过程给隐藏了。 工厂方法模式是针对一种产品结构，而抽象工厂模式是针对多种产品结构。 适用性：在以下情况下应当考虑使用抽象工厂模式： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。 这个系统有多于一个的产品族，而系统只消费其中某一产品族。 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。 应用场景： 支持多种观感标准的用户界面工具箱（Kit）。 游戏开发中的多风格系列场景，比如道路，房屋，管道等。 建造者模式（Builder Pattern）解决的问题：我创建的这个对象比较复杂，且该对象里面的成员函数用不同的实现来表示不同的实例，换句话说就是同样的对象构建过程可以有不同的表示。比如我那天去吃过桥米线，他们有不同的套餐，套餐里包含的种类是一样的，都有一碗米线，一份凉菜，一杯饮料。但是不同的套餐里这3样又都不是全部一样的。此时我们就可以用建造者模式。 1．建造者（Builder）角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者（Concrete Builder）角色。具体建造者类必须实现这个接口所要求的方法：一个是建造方法，另一个是结果返还方法。此时就是米线店的员工，按照收银员的要求的去准备具体的套餐，放入适当的米线，凉菜和饮料。 2．具体建造者（Concrete Builder）角色：担任这个角色的是于应用程序紧密相关的类，它们在应用程序调用下创建产品实例。这个角色主要完成的任务包括：实现Builder角色提供的接口，一步一步完成创建产品实例的过程。在建造过程完成后，提供产品的实例。是具体的做某个套餐的员工。 3．指导者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者对象。是收银员，他知道我想要什么套餐，他会告诉里面的米线店员工去准备什么套餐。 4．产品（Product）角色：产品便是建造中的复杂对象。指导者角色是于客户端打交道的角色。导演者角色将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但却不为客户端所知。就是最后的套餐，所有东西放到一起端过来。 样例实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// CplusplusBuild.cpp : Defines the entry point for the console application. // #include &quot;stdafx.h&quot; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; //product class Food &#123; private: vector&lt;string&gt; mFoodName; vector&lt;int&gt; mFoodPrice; public: void add(string foodName,int price) &#123; mFoodName.push_back(foodName); mFoodPrice.push_back(price); &#125; void show() &#123; cout&lt;&lt;&quot;Food List&quot; &lt;&lt;endl; cout&lt;&lt;&quot;-------------------&quot;&lt;&lt;endl; for(int i=0;i&lt;mFoodName.size();i++) &#123; cout&lt;&lt;mFoodName[i]&lt;&lt;&quot; &quot;&lt;&lt;mFoodPrice[i]&lt;&lt;endl; &#125; &#125; &#125;; //builder class Builder &#123; public: virtual void BuildRiceNoodles() &#123;&#125;; virtual void BuildCoolDish()&#123;&#125;; virtual void BuildDrink()&#123;&#125;; virtual Food * getFood()&#123;return NULL;&#125; &#125;; //builderA class BuilderA:public Builder &#123; private: Food *food; public: BuilderA()&#123;food = new Food();&#125; void BuildRiceNoodles() &#123; food-&gt;add(&quot;RiceNoodlesA&quot;,20); &#125; void BuildCoolDish() &#123; food-&gt;add(&quot;CoolDishA&quot;,20); &#125; void BuildDrink() &#123; food-&gt;add(&quot;DrinkA&quot;,20); &#125; Food * getFood() &#123; return food; &#125; &#125;; //builderB class BuilderB:public Builder &#123; private: Food *food; public: BuilderB()&#123;food = new Food();&#125; void BuildRiceNoodles() &#123; food-&gt;add(&quot;RiceNoodlesB&quot;,10); &#125; void BuildCoolDish() &#123; food-&gt;add(&quot;CoolDishB&quot;,10); &#125; void BuildDrink() &#123; food-&gt;add(&quot;DrinkB&quot;,10); &#125; Food * getFood() &#123; return food; &#125; &#125;; //director class FoodManager &#123; public: void Construct(Builder * builder) &#123; builder-&gt;BuildRiceNoodles(); builder-&gt;BuildDrink(); builder-&gt;BuildCoolDish(); &#125; &#125;; //clent int _tmain(int argc, _TCHAR* argv[]) &#123; FoodManager *foodManager= new FoodManager(); Builder * builder = new Builder(); // the following code can use simple factory; char ch; cout&lt;&lt;&quot;input your food Type (A or B):&quot;; cin&gt;&gt;ch; if(ch==&apos;A&apos;) &#123; builder = new BuilderA(); &#125;else if(ch==&apos;B&apos;) &#123; builder = new BuilderB(); &#125; foodManager-&gt;Construct(builder); Food * food = builder-&gt;getFood(); food-&gt;show(); return 0; &#125; 建造者模式的扩展：建造者模式在使用过程中可以演化出多种形式： 省略抽象建造者角色如果系统中只需要一个具体的建造者的话，可以省略掉抽象建造者。这是代码可能如下： 1234567891011121314//director class FoodManager &#123; private: BuilderA * builder; public: FoodManager() &#123;builder = new BuilderA();&#125;; void Construct() &#123; builder-&gt;BuildRiceNoodles(); builder-&gt;BuildDrink(); builder-&gt;BuildCoolDish(); &#125; &#125;; 省略指导者角色在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略掉指导者角色，让Builder自己扮演指导者和建造者双重角色。这是代码可能如下： 123456789101112131415161718//builder class Builder &#123; private: Food * food; public: Builder()&#123;food = new Food();&#125; void BuildRiceNoodles() &#123;//..&#125;; void BuildCoolDish()&#123;//..&#125;; void BuildDrink()&#123;//..&#125;; Food * getFood()&#123;return food;&#125; void Construct() &#123; BuildRiceNoodles(); BuildCoolDish(); BuildDrink(); &#125; &#125;; 同时，客户端也需要进行相应的调整，如下： 123456789//client int _tmain(int argc, _TCHAR* argv[]) &#123; Builder * builder = new Builder(); builder-&gt;Construct(); Food *food = builder-&gt;getFood(); food-&gt;show(); return 0; &#125; C#中的StringBuilder就是这样一个例子。 实现要点：1．建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“每个步骤”是一个稳定的算法，而复杂对象的各个步骤之间则经常变化。 2．上一篇所说的抽象工厂模式解决“系列对象”的需求变化，而建造者模式解决单个对象里“对象部分”的需求变化。 产品不需要抽象类，特别是由于创建对象的算法复杂而导致使用此模式的情况下或者此模式应用于产品的生成过程，其最终结果可能差异很大，不大可能提炼出一个抽象产品类。 3．创建者中的创建子部件的接口方法不是抽象方法而是空方法，不进行任何操作，具体的创建者只需要覆盖需要的方法就可以，但是这也不是绝对的，特别是类似文本转换这种情况下，缺省的方法将输入原封不动的输出是合理的缺省操作。 适用性：以下情况应当使用建造者模式：1、需要生成的产品对象有复杂的内部结构。2、需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。3、 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。 效果1、建造者模式的使用使得产品的内部表象可以独立的变化。使用建造者模式可以使客户端不必知道产品内部组成的细节。2、每一个Builder都相对独立，而与其它的Builder无关。3、可使对构造过程更加精细控制。4、将构建代码和实现代码分开。5、建造者模式的缺点在于难于应付“分步骤构建算法”的需求变动。 原型模式（Prototype Pattern）解决的问题：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这个其实和C++的拷贝构造函数的作用是一致的，实际上就是动态抽取当前对象运行时的状态。 类图结构： 客户（Client）角色：客户类提出创建对象的请求。抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象原型角色所要求的接口。 样例实现：例子参照wuzhekai1985的简历的例子，代码拷贝如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// CplusplusPrototype.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;assert.h&gt;using namespace std;//父类 class Resume &#123; protected: char *name; public: Resume() &#123;&#125; virtual ~Resume() &#123;&#125; virtual Resume* Clone() &#123; return NULL; &#125; virtual void Set(char *n) &#123;&#125; virtual void Show() &#123;&#125; &#125;;class ResumeA : public Resume &#123; public: ResumeA(const char *str); //构造函数 ResumeA(const ResumeA &amp;r); //拷贝构造函数 ~ResumeA(); //析构函数 ResumeA* Clone(); //克隆，关键所在 void Show(); //显示内容 &#125;; ResumeA::ResumeA(const char *str) &#123; if(str == NULL) &#123; name = new char[1]; name[0] = &apos;\0&apos;; &#125; else &#123; name = new char[strlen(str)+1]; strcpy(name, str); &#125; &#125; ResumeA::~ResumeA() &#123; delete [] name;&#125; ResumeA::ResumeA(const ResumeA &amp;r) &#123; name = new char[strlen(r.name)+1]; strcpy(name, r.name); &#125; ResumeA* ResumeA::Clone() &#123; return new ResumeA(*this); &#125; void ResumeA::Show() &#123; cout&lt;&lt;&quot;ResumeA name : &quot;&lt;&lt;name&lt;&lt;endl; &#125;class ResumeB : public Resume &#123; public: ResumeB(const char *str); //构造函数 ResumeB(const ResumeB &amp;r); //拷贝构造函数 ~ResumeB(); //析构函数 ResumeB* Clone(); //克隆，关键所在 void Show(); //显示内容 &#125;; ResumeB::ResumeB(const char *str) &#123; if(str == NULL) &#123; name = new char[1]; name[0] = &apos;\0&apos;; &#125; else &#123; name = new char[strlen(str)+1]; strcpy(name, str); &#125; &#125; ResumeB::~ResumeB() &#123; delete [] name;&#125; ResumeB::ResumeB(const ResumeB &amp;r) &#123; name = new char[strlen(r.name)+1]; strcpy(name, r.name); &#125; ResumeB* ResumeB::Clone() &#123; return new ResumeB(*this); &#125; void ResumeB::Show() &#123; cout&lt;&lt;&quot;ResumeB name : &quot;&lt;&lt;name&lt;&lt;endl; &#125;int _tmain(int argc, _TCHAR* argv[])&#123; Resume *r1 = new ResumeA(&quot;A&quot;); Resume *r2 = new ResumeB(&quot;B&quot;); Resume *r3 = r1-&gt;Clone(); Resume *r4 = r2-&gt;Clone(); r1-&gt;Show(); r2-&gt;Show(); //删除r1,r2 delete r1; delete r2; r1 = r2 = NULL; //深拷贝所以对r3,r4无影响 r3-&gt;Show(); r4-&gt;Show(); delete r3; delete r4; r3 = r4 = NULL; return 0;&#125; 带Prototype Manager的原型模式： 客户（Client）角色：客户端类向原型管理器提出创建对象的请求。抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。原型管理器（Prototype Manager）角色：创建具体原型类的对象，并记录每一个被创建的对象。代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// CplusplusPrototype.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;assert.h&gt;using namespace std;//父类 class Resume &#123; protected: char *name; public: Resume() &#123;&#125; virtual ~Resume() &#123;&#125; virtual Resume* Clone() &#123; return NULL; &#125; virtual void Set(char *n) &#123;&#125; virtual void Show() &#123;&#125; &#125;;class ResumeA : public Resume &#123; public: ResumeA(const char *str); //构造函数 ResumeA(const ResumeA &amp;r); //拷贝构造函数 ~ResumeA(); //析构函数 ResumeA* Clone(); //克隆，关键所在 void Show(); //显示内容 &#125;; ResumeA::ResumeA(const char *str) &#123; if(str == NULL) &#123; name = new char[1]; name[0] = &apos;\0&apos;; &#125; else &#123; name = new char[strlen(str)+1]; strcpy(name, str); &#125; &#125; ResumeA::~ResumeA() &#123; delete [] name;&#125; ResumeA::ResumeA(const ResumeA &amp;r) &#123; name = new char[strlen(r.name)+1]; strcpy(name, r.name); &#125; ResumeA* ResumeA::Clone() &#123; return new ResumeA(*this); &#125; void ResumeA::Show() &#123; cout&lt;&lt;&quot;ResumeA name : &quot;&lt;&lt;name&lt;&lt;endl; &#125;class ResumeB : public Resume &#123; public: ResumeB(const char *str); //构造函数 ResumeB(const ResumeB &amp;r); //拷贝构造函数 ~ResumeB(); //析构函数 ResumeB* Clone(); //克隆，关键所在 void Show(); //显示内容 &#125;; ResumeB::ResumeB(const char *str) &#123; if(str == NULL) &#123; name = new char[1]; name[0] = &apos;\0&apos;; &#125; else &#123; name = new char[strlen(str)+1]; strcpy(name, str); &#125; &#125; ResumeB::~ResumeB() &#123; delete [] name;&#125; ResumeB::ResumeB(const ResumeB &amp;r) &#123; name = new char[strlen(r.name)+1]; strcpy(name, r.name); &#125; ResumeB* ResumeB::Clone() &#123; return new ResumeB(*this); &#125; void ResumeB::Show() &#123; cout&lt;&lt;&quot;ResumeB name : &quot;&lt;&lt;name&lt;&lt;endl; &#125;class ResumeManager&#123;private: vector&lt;Resume *&gt; mResume;public: ResumeManager() &#123; &#125; void add(Resume * resume) &#123; mResume.push_back(resume); &#125; Resume * get(int index) const &#123; assert(index&gt;=0 &amp;&amp; index&lt;mResume.size()); return mResume[index]; &#125;&#125;;int _tmain(int argc, _TCHAR* argv[])&#123; ResumeManager *manager = new ResumeManager(); Resume *r1 = new ResumeA(&quot;A&quot;); Resume *r2 = new ResumeB(&quot;B&quot;); manager-&gt;add(r1); manager-&gt;add(r2); manager-&gt;get(0)-&gt;Show(); manager-&gt;get(1)-&gt;Show(); Resume *r3 = manager-&gt;get(0)-&gt;Clone(); Resume *r4 = manager-&gt;get(1)-&gt;Clone(); //删除r1,r2 delete r1; delete r2; r1 = r2 = NULL; //深拷贝所以对r3,r4无影响 r3-&gt;Show(); r4-&gt;Show(); delete r3; delete r4; r3 = r4 = NULL; return 0;&#125; 实现要点： 使用原型管理器，体现在一个系统中原型数目不固定时，可以动态的创建和销毁。 实现克隆操作，在.NET中可以使用Object类的MemberwiseClone()方法来实现对象的浅表拷贝或通过序列化的方式来实现深拷贝，在C++中就是拷贝构造函数的作用。 Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口。 效果： 它对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目。 Prototype模式允许客户只通过注册原型实例就可以将一个具体产品类并入到系统中，客户可以在运行时刻建立和删除原型。 减少了子类构造，Prototype模式是克隆一个原型而不是请求工厂方法创建一个，所以它不需要一个与具体产品类平行的Creater类层次。 Portotype模式具有给一个应用软件动态加载新功能的能力。由于Prototype的独立性较高，可以很容易动态加载新功能而不影响老系统。 产品类不需要非得有任何事先确定的等级结构，因为Prototype模式适用于任何的等级结构 Prototype模式的最主要缺点就是每一个类必须配备一个克隆方法。而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。 适用性： 当一个系统应该独立于他的产品创建、构成和表示时，需要使用原型模式 当要实例化的类是在运行时刻指定时，如通过动态装载 为了避免创建一个与产品类层次平行的工厂类层次时 当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆他们可能比每次用合适的状态手工实例化该类更方便一些。 单例模式（Singleton Pattern） 单例模式（Singleton Pattern） 单例模式，顾名思义，就是只能由一个实例，那么我们就必须保证 该类不能被复制。 该类不能被公开的创造。 那么对于C++来说，他的构造函数，拷贝构造函数和他的赋值函数都不能被公开调用。但对于该私有的构造函数的构造时机上来说也可以分两种情况来构造： 只有当需要该类的时候去构造（即为懒汉模式） 在程序开始之前我就先构造好，你到时候直接用就可（即为饿汉模式） 那么我分别来说说这两种模式： 懒汉模式，静态局部变量只会被初始化一次即第一次执行的时候，其生命周期与程序的生命周期是相同的。这个同样适用于多线程的情况。 123456789101112131415161718class single1 &#123; public: static single1&amp; getInstance() &#123; static single1 instance; return instance; &#125; int helloSingle() &#123;return 1;&#125; private: private: single1()&#123;&#125;; single1(const single1&amp;); single1&amp; operator=(const single1&amp;); &#125;; 饿汉模式，但是在main函数外面必须先调用其实例的构造，这个是静态实例的初始化，C/C++会保证其在进入main函数之前进行。 1234567891011121314151617181920class single2 &#123; public: static single2* getInstance() &#123; return mInstance; &#125; int helloSingle() &#123;return 1;&#125; private: static single2* mInstance; private: single2()&#123;&#125;; single2(const single2&amp;); single2&amp; operator=(const single2&amp;); &#125;; single2* single2::mInstance = new single2; 我们运用静态局部变量和静态实例的特性，使得我们的这两种模式都适用于多线程。 适配器模式（Adapter Pattern） 适配器模式（Adapter Pattern） 解决的问题：适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够在一起工作。比如说我的hp笔记本，美国产品，人家美国的电压是110V的，而我们中国的电压是220V，要在中国能使用，必须找个变压器转一下电压才可以。这个变压器就是个适配器。 适配器模式有类适配器和对象适配器两种模式，我们将分别讨论。 类适配器： 由图中可以看出，Adaptee类没有Request方法，而客户期待这个方法。为了使客户能够使用Adaptee类，提供一个中间环节，即类Adapter类，Adapter类实现了Target接口，并继承自Adaptee，Adapter类的Request方法重新封装了Adaptee的SpecificRequest方法，实现了适配的目的。 因为Adapter与Adaptee是继承的关系，所以这决定了这个适配器模式是类的。 该适配器模式所涉及的角色包括： 目标（Target）角色：这是客户所期待的接口。因为C#不支持多继承，所以Target必须是接口，不可以是类。源（Adaptee）角色：需要适配的类。适配器（Adapter）角色：把源接口转换成目标接口。这一角色必须是类 简单实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;// &quot;ITarget&quot;class Target&#123;public: // Methods virtual void Request()&#123;&#125;;&#125;;// &quot;Adaptee&quot;class Adaptee&#123;public: // Methods void SpecificRequest() &#123; cout&lt;&lt;&quot;Called SpecificRequest()&quot;&lt;&lt;endl; &#125;&#125;;// &quot;Adapter&quot;class Adapter : public Adaptee, public Target&#123;public: // Implements ITarget interface void Request() &#123; // Possibly do some data manipulation // and then call SpecificRequest this-&gt;SpecificRequest(); &#125;&#125;;int main()&#123; // Create adapter and place a request Target *t = new Adapter(); t-&gt;Request(); return 0;&#125; 对象适配器： 从图中可以看出：客户端需要调用Request方法，而Adaptee没有该方法，为了使客户端能够使用Adaptee类，需要提供一个包装（Wrapper）类Adapter。这个包装类包装了一个Adaptee的实例，从而将客户端与Adaptee衔接起来。由于Adapter与Adaptee是委派关系，这决定了这个适配器模式是对象的。 该适配器模式所涉及的角色包括： 目标（Target）角色：这是客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。源（Adaptee）角色：需要适配的类。适配器（Adapter）角色：通过在内部包装（Wrap）一个Adaptee对象，把源接口转换成目标接口。 简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;// &quot;ITarget&quot;class Target&#123;public: // Methods virtual void Request()&#123;&#125;;&#125;;// &quot;Adaptee&quot;class Adaptee&#123;public: // Methods void SpecificRequest() &#123; cout&lt;&lt;&quot;Called SpecificRequest()&quot;&lt;&lt;endl; &#125;&#125;;// &quot;Adapter&quot;class Adapter : public Target&#123;private: Adaptee *adaptee;public: Adapter() &#123; adaptee = new Adaptee(); &#125; // Implements ITarget interface void Request() &#123; // Possibly do some data manipulation // and then call SpecificRequest adaptee-&gt;SpecificRequest(); &#125;&#125;;int main()&#123; // Create adapter and place a request Target *t = new Adapter(); t-&gt;Request(); return 0;&#125; 缺省适配器：缺省适配器模式是一种特殊的适配器模式，但这个适配器是由一个抽象类实现的，并且在抽象类中要实现目标接口中所规定的所有方法，但很多方法的实现都是“平庸”的实现，也就是说，这些方法都是空方法。而具体的子类都要继承此抽象类。 简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;class Target &#123;public: virtual void f1()&#123;&#125;; virtual void f2()&#123;&#125;; virtual void f3()&#123;&#125;; &#125;;class DefaultAdapter : public Target&#123;public: void f1() &#123; &#125; void f2() &#123; &#125; void f3() &#123; &#125;&#125;;class MyInteresting :public DefaultAdapter&#123;public: void f3()&#123; cout&lt;&lt;&quot;呵呵，我就对f3()方法感兴趣，别的不管了！&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; // Create adapter and place a request Target *t = new MyInteresting(); t-&gt;f3(); return 0;&#125; 实现要点： Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。 Adapter模式有对象适配器和类适配器两种形式的实现结构，但是类适配器采用“多继承”的实现方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。 Adapter模式的实现可以非常的灵活，不必拘泥于GOF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。 Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便的适配。 使用场景：在以下各种情况下使用适配器模式： 系统需要使用现有的类，而此类的接口不符合系统的需要。 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。 （对对象适配器而言）在设计里，需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。 桥模式（Bridge Pattern） 桥模式（Bridge Pattern） 桥模式，其作用就是让抽象与实现相分离，让两者都能够各自变化。 举例来说吧，画图，我可以画矩形，圆，三角形等等，在哪里画呢？我可以在pdf上画，也可以在doc上面画。画什么图和在哪里画都是可以独立变化的，此种情况就比较适合用桥模式。就是说设计中有超过一维的变化我们就可以用桥模式。如果只有一维在变化，那么我们用继承就可以圆满的解决问题。 我的图形定义：12345678910111213141516171819#pragma once#include&lt;vector&gt;#include&quot;ImpShape.h&quot;class IShape&#123;public: IShape(void); virtual ~IShape(void); virtual std::vector&lt;Point&gt; getDrawPoints(); void paint();public: ImpShape *implementor;&#125;; 其他图形都继承之： 1234567891011121314151617181920#pragma once#include &quot;ishape.h&quot;class CRectangle : public IShape&#123;public: CRectangle(void); ~CRectangle(void);&#125;;#pragma once#include &quot;ishape.h&quot;class CCircle : public IShape&#123;public: CCircle(void); ~CCircle(void);&#125;; 那么在怎么画这个问题上，该怎么实现呢？我先定义一个shape的实现类： 1234567891011#pragma once#include&lt;vector&gt;class ImpShape&#123;public: ImpShape(void); virtual ~ImpShape(void);public: virtual void draw(std::vector&lt;Point&gt;&amp;);&#125;; 那么让pdf和doc的实现类都继承自ImpShape: 12345678910111213141516171819#pragma once#include &quot;impshape.h&quot;class ImpPdf : public ImpShape&#123;public: ImpPdf(void); ~ImpPdf(void);&#125;;#pragma once#include &quot;impshape.h&quot;class ImpDoc : public ImpShape&#123;public: ImpDoc(void); ~ImpDoc(void);&#125;; 那ImpPdf和ImpDoc必须继承且重写ImpShape的draw函数。 我们的抽象和实现都分别实现好了，那两者如何联系，如何使用的？ 关于联系，细心的你也许已经发现，IShape里面包含一个ImpShape的指针，包含!对。因为ImpShape是实现IShape的，这里用包含，我们可以在IShape的其他函数里方便的调用。 123456789101112131415161718#include &quot;StdAfx.h&quot;#include &quot;IShape.h&quot;IShape::IShape(void)&#123;&#125;IShape::~IShape(void)&#123;&#125;void IShape::paint()&#123; std::vector&lt;Point&gt; vpoints = getDrawPoints(); this-&gt;implementor-&gt;draw(vpoints);&#125; 关于使用，很简单： 1234567IShape *item = new CCircle(); item-&gt;implementor = new ImpPdf(); item-&gt;paint(); item = new CRectangle(); item-&gt;implementor = new ImpDoc(); item-&gt;paint(); 这样既满足了画什么图形的变化，也满足了在什么上画的问题，他们之间的类图如下： 组合模式（Composite Pattern） 组合模式（Composite Pattern） 解决的问题：我们PC用到的文件系统，其实就是我们数据结构里的树形结构，我们处理树中的每个节点时，其实不用考虑他是叶子节点还是根节点，因为他们的成员函数都是一样的，这个就是组合模式的精髓。他模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 注明：树形结构里的叶子节点也有左右孩子，只不过他的孩子都是空。 概述组合模式的实现根据所实现接口的区别分为两种形式，分别称为安全模式和透明模式。组合模式可以不提供父对象的管理方法，但组合模式必须在合适的地方提供子对象的管理方法（诸如：add、remove、getChild等）。 透明方式作为第一种选择，在Component里面声明所有的用来管理子类对象的方法，包括add（）、remove（），以及getChild（）方法。这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端可以同等同的对待所有的对象。这就是透明形式的组合模式。 这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此add（）、remove（）以及getChild（）方法没有意义，是在编译时期不会出错，而只会在运行时期才会出错或者说识别出来。 安全方式第二种选择是在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，因为树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。 这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。 这两个形式各有优缺点，需要根据软件的具体情况做出取舍决定。 类图结构及样例实现：这里给出安全方式的组合模式的类图结构和样例实现，透明方式就是在叶子节点的add()/remove()/GetChild()均有实现，不过是无意义的实现。大部分应用都是基于透明模式的，因为这样代码可以重用。 安全方式的组合模式： 这种形式涉及到三个角色： 抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。在安全式的合成模式里，构件角色并不是定义出管理子对象的方法，这一定义由树枝构件对象给出。 树叶构件（Leaf）角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。 树枝构件（Composite）角色：代表参加组合的有下级子对象的对象。树枝对象给出所有的管理子对象的方法，如add（）、remove（）、getChild（）等。 样例实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173//Menu.h #include &lt;string&gt; class Menu &#123; public: virtual ~Menu(); virtual void Add(Menu*); virtual void Remove(Menu*); virtual Menu* GetChild(int); virtual void Display() = 0; protected: Menu(); Menu(std::string); std::string m_strName; &#125;; //Menu.cpp #include &quot;stdafx.h&quot; #include &quot;Menu.h&quot; Menu::Menu() &#123; &#125; Menu::Menu(std::string strName) : m_strName(strName) &#123; &#125; Menu::~Menu() &#123; &#125; void Menu::Add(Menu* pMenu) &#123;&#125; void Menu::Remove(Menu* pMenu) &#123;&#125; Menu* Menu::GetChild(int index) &#123; return NULL; &#125; //SubMenu.h #include &quot;Menu.h&quot; class SubMenu : public Menu &#123; public: SubMenu(); SubMenu(std::string); virtual ~SubMenu(); void Display(); &#125;; //SubMenu.cpp #include &quot;stdafx.h&quot; #include &quot;SubMenu.h&quot; #include &lt;iostream&gt; using namespace std; SubMenu::SubMenu() &#123; &#125; SubMenu::SubMenu(string strName) : Menu(strName) &#123; &#125; SubMenu::~SubMenu() &#123; &#125; void SubMenu::Display() &#123; cout &lt;&lt; m_strName &lt;&lt; endl; &#125; //CompositMenu.h #include &quot;Menu.h&quot; #include &lt;vector&gt; class CompositMenu : public Menu &#123; public: CompositMenu(); CompositMenu(std::string); virtual ~CompositMenu(); void Add(Menu*); void Remove(Menu*); Menu* GetChild(int); void Display(); private: std::vector&lt;Menu*&gt; m_vMenu; &#125;; //CompositMenu.cpp #include &quot;stdafx.h&quot; #include &quot;CompositMenu.h&quot; #include &lt;iostream&gt; using namespace std; CompositMenu::CompositMenu() &#123; &#125; CompositMenu::CompositMenu(string strName) : Menu(strName) &#123; &#125; CompositMenu::~CompositMenu() &#123; &#125; void CompositMenu::Add(Menu* pMenu) &#123; m_vMenu.push_back(pMenu); &#125; void CompositMenu::Remove(Menu* pMenu) &#123; m_vMenu.erase(&amp;pMenu); &#125; Menu* CompositMenu::GetChild(int index) &#123; return m_vMenu[index]; &#125; void CompositMenu::Display() &#123; cout &lt;&lt; &quot;+&quot; &lt;&lt; m_strName &lt;&lt; endl; vector&lt;Menu*&gt;::iterator it = m_vMenu.begin(); for (; it != m_vMenu.end(); ++it) &#123; cout &lt;&lt; &quot;|-&quot;; (*it)-&gt;Display(); &#125; &#125; #include &quot;stdafx.h&quot; #include &quot;Menu.h&quot; #include &quot;SubMenu.h&quot; #include &quot;CompositMenu.h&quot; int main(int argc, char* argv[]) &#123; Menu* pMenu = new CompositMenu(&quot;国内新闻&quot;); pMenu-&gt;Add(new SubMenu(&quot;时事新闻&quot;)); pMenu-&gt;Add(new SubMenu(&quot;社会新闻&quot;)); pMenu-&gt;Display(); pMenu = new CompositMenu(&quot;国际新闻&quot;); pMenu-&gt;Add(new SubMenu(&quot;国际要闻&quot;)); pMenu-&gt;Add(new SubMenu(&quot;环球视野&quot;)); pMenu-&gt;Display(); return 0; &#125; 实现要点： 组合模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。 将“客户代码与复杂的对象容器结构”解耦是组合模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复内部实现结构——发生依赖关系，从而更能“应对变化”。 组合模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。 组合模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。 客户端尽量不要直接调用树叶类的方法，而是借助其父类（Component）的多态性完成调用，这样可以增加代码的复用性。 使用场景：以下情况下适用组合模式： 你想表示对象的部分-整体层次结构。 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 装饰者模式（Decorator Pattern） 装饰者模式（Decorator Pattern） 解决的问题：我们在装饰新家的时候买了几幅抽象画，买回来之后发现有些加上色彩艳丽的边框更适合我们，而有的加上玻璃罩之后更能符合我们的使用。那我们来怎么解决这个问题呢？他需要动态的给别的对象增加额外的职责，这就是装饰者模式的目的。 我们可以通过继承的方式来给原对象增加新功能，但是装饰者模式采用组合的方式比生成子类更加灵活。 类图及样例实现： 在装饰模式中的各个角色有：抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。具体装饰（Concrete Decorator）角色：负责给构件对象”贴上”附加的责任。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;//抽象类Tankclass Tank&#123;public: virtual void shot()=0; virtual void run()=0;public: virtual ~Tank() &#123; cout&lt;&lt;&quot;in the destructor of Tank&quot;&lt;&lt;endl; &#125;&#125;;//具体类 T50class T50:public Tank&#123;public: void shot() &#123; cout&lt;&lt;&quot;Tank T50 shot()&quot;&lt;&lt;endl; &#125; void run() &#123; cout&lt;&lt;&quot;Tank T50 run()&quot;&lt;&lt;endl; &#125;public: virtual ~T50() &#123; cout&lt;&lt;&quot;In the destructor of T50&quot;&lt;&lt;endl; &#125;&#125;;//具体类T75class T75:public Tank&#123;public: void shot() &#123; cout&lt;&lt;&quot;Tank T75 shot()&quot;&lt;&lt;endl; &#125; void run() &#123; cout&lt;&lt;&quot;Tank T75 run()&quot;&lt;&lt;endl; &#125;public: virtual ~T75() &#123; cout&lt;&lt;&quot;In the destructor of T75&quot;&lt;&lt;endl; &#125;&#125;;//抽象类，Decoratorclass Decorator:public Tank&#123;protected: Tank* tank;public: Decorator(Tank* tank):tank(tank) &#123;&#125; //具体的坦克的装饰类 virtual ~Decorator() &#123; cout&lt;&lt;&quot;In the destructor of Decorator&quot;&lt;&lt;endl; &#125;public: void shot() &#123; tank-&gt;shot(); &#125; void run() &#123; tank-&gt;run(); &#125;&#125;;class InfraredDecorator: public Decorator&#123;private: string infrared;//这就是所谓的addAtrributepublic: InfraredDecorator(Tank* tank):Decorator(tank) &#123;&#125; virtual ~InfraredDecorator() &#123; cout&lt;&lt;&quot;in the destructor of InfraredDecorator&quot;&lt;&lt;endl; &#125;public: void set_Infrared(const string &amp;infrared) &#123; this-&gt;infrared=infrared; &#125; string get_infrared() const &#123; return infrared; &#125; void run() &#123; tank-&gt;run(); set_Infrared(&quot;+Infrared&quot;); cout&lt;&lt;get_infrared()&lt;&lt;endl; &#125; void shot() &#123; tank-&gt;shot(); &#125;&#125;;class AmphibianDecorator:public Decorator&#123;private: string amphibian;public: AmphibianDecorator(Tank* tank):Decorator(tank) &#123;&#125; ~AmphibianDecorator() &#123; cout&lt;&lt;&quot;in the destructor of AmphibianDecorator&quot;&lt;&lt;endl; &#125;public: void set_amphibian(const string &amp;hibian) &#123; this-&gt;amphibian=hibian; &#125; string get_amphibian() const &#123; return amphibian; &#125;public: void run() &#123; tank-&gt;run(); set_amphibian(&quot;+amphibian&quot;); cout&lt;&lt;get_amphibian()&lt;&lt;endl; &#125; void shot() &#123; tank-&gt;shot(); &#125;&#125;;int main(int argc, char **argv)&#123; //给T50增加红外功能 Tank* tank1(new T50); Tank* pid1(new InfraredDecorator(tank1)); pid1-&gt;shot(); cout&lt;&lt;endl; pid1-&gt;run(); cout&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;&quot;---------------&quot;&lt;&lt;endl; //给t75增加红外、两栖功能 Tank* tank2(new T75); tank2-&gt;run(); Tank* pid2(new InfraredDecorator(tank2)); Tank* pad2(new AmphibianDecorator(pid2)); pad2-&gt;shot(); cout&lt;&lt;endl; pad2-&gt;run(); cout&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;&quot;--------------&quot;&lt;&lt;endl; //动态撤销其他装饰 ? tank2-&gt;run(); Tank * tank3(tank2); tank3-&gt;run(); return 0;&#125; 装饰者与适配者模式的区别： 关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。 关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者） 关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。 要点： 装饰者和被装饰对象有相同的超类型。 可以用一个或多个装饰者包装一个对象。 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。 装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。 适用场景与优缺点：在以下情况下应当使用装饰模式： 需要扩展一个类的功能，或给一个类增加附加责任。 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。 优点： Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 缺点： 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。 外观模式（Facade Pattern） 外观模式（Facade Pattern） 概述想想我们小时候玩的四驱车，里面的构造很复杂，马达，舵机，电池组等等，而我们控制它却非常简单，只要打开电池开关，他就可以跑。我们其实不用知道它里面是如何工作，只要知道拨动开关它就可以工作就行了，这个开关其实就四驱车给我们的一个友好的组件，使得我们可以很方便的控制它。 外观模式其实定义了一个高层接口，该接口为子系统中的一组接口提供一个一致的界面，使得这一子系统更加容易使用。 类图和样例 在这个对象图中，出现了两个角色： 外观(Facade)角色：客户端可以调用这个角色的方法。此角色知晓相关的(一个或者多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 子系统(subsystem)角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被外观角色调用。子系统并不知道外观的存在，对于子系统而言，外观仅仅是另外一个客户端而已。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Scanner &#123; public: void Scan() &#123; cout&lt;&lt;&quot;词法分析&quot;&lt;&lt;endl; &#125; &#125;; class Parser &#123; public: void Parse() &#123; cout&lt;&lt;&quot;语法分析&quot;&lt;&lt;endl; &#125; &#125;; class GenMidCode &#123; public: void GenCode() &#123; cout&lt;&lt;&quot;产生中间代码&quot;&lt;&lt;endl; &#125; &#125;; class GenMachineCode &#123; public: void GenCode() &#123; cout&lt;&lt;&quot;产生机器码&quot;&lt;&lt;endl;&#125; &#125;; //高层接口 Fecadeclass Compiler &#123; public: void Run() &#123; Scanner scanner; Parser parser; GenMidCode genMidCode; GenMachineCode genMacCode; scanner.Scan(); parser.Parse(); genMidCode.GenCode(); genMacCode.GenCode(); &#125; &#125;; //clientint main() &#123; Compiler compiler; compiler.Run(); return 0; &#125; 要点 Facade模式对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。 Facade模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。 如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性与通用性之间选择。 在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只能有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统有一个外观类，整个系统可以有数个外观类。 外观模式的用意是为子系统提供一个集中化和简化的沟通管道，而不建议向子系统加入新的行为。 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。 适用性和优缺点适用性 为一个复杂子系统提供一个简单接口。 提高子系统的独立性。 在层次化结构中，可以使用Facade模式定义系统中每一层的入口。 优点 松散耦合 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。即要点2. 简单易用外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。 更好的划分访问层次通过合理使用Facade，可以帮助我们更好的划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好的隐藏了内部的细节。 缺点过多的或者是不太合理的Facade也容易让人迷惑，到底是调用Facade好呢，还是直接调用模块好。 享元模式（Flyweight Pattern） 享元模式（Flyweight Pattern） 概述想想我们编辑文档用的wps，文档里文字很多都是重复的，我们不可能为每一个出现的汉字都创建独立的空间，这样代价太大，最好的办法就是共享其中相同的部分，使得需要创建的对象降到最小，这个就是享元模式的核心，即运用共享技术有效地支持大量细粒度的对象。 享元对象能做到共享的关键是区分内蕴状态（Internal State）和外蕴状态（External State）。内蕴状态是存储在享元对象内部并且不会随环境改变而改变。因此内蕴状态并可以共享。 外蕴状态是随环境改变而改变的、不可以共享的状态。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态与内蕴状态是相互独立的。 类图与样例 抽象享元类（Flyweight）它是所有具体享元类的超类。为这些类规定出需要实现的公共接口,那些需要外蕴状态(Exte的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。 具体享元类(ConcreteFlyweight)具体享元类实现了抽象享元类所规定的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元类又称为单纯具体享元类，因为复合享元类是由单纯具体享元角色通过复合而成的。 不能共享的具体享元类(UnsharableFlyweight)不能共享的享元类，又叫做复合享元类。一个复合享元对象是由多个单享元对象组成，这些组成的对象是可以共享的，但是复合享元类本身并不能共享。 享元工厂类(FlyweightFactoiy)享元工厂类负责创建和管理享元对象。当一个客户端对象请求一个享元对象的时候，享元工厂需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。 客户类(Client)客户类需要自行存储所有享元对象的外蕴状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;class Character &#123;public: virtual ~Character()&#123;&#125;; virtual void SetSize(int, int) = 0; virtual void Display() = 0;protected: Character()&#123;&#125;; char m_chSymbol; int m_nWeight; int m_nHeight;&#125;;class CharacterA : public Character&#123;public: CharacterA(); virtual ~CharacterA(); void SetSize(int, int); void Display();&#125;;CharacterA::CharacterA()&#123; this-&gt;m_chSymbol = &apos;A&apos;; this-&gt;m_nWeight = 100; this-&gt;m_nHeight = 200;&#125;CharacterA::~CharacterA()&#123;&#125;void CharacterA::SetSize(int nWeight, int nHeight)&#123; this-&gt;m_nWeight = nWeight; this-&gt;m_nHeight = nHeight;&#125;void CharacterA::Display()&#123; cout &lt;&lt; &quot;CharacterA：&quot; &lt;&lt; m_chSymbol &lt;&lt; &quot;(&quot; &lt;&lt; m_nWeight &lt;&lt; &quot;,&quot; &lt;&lt; m_nHeight &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;class CharacterB : public Character&#123;public: CharacterB(); virtual ~CharacterB(); void SetSize(int, int); void Display();&#125;;CharacterB::CharacterB()&#123; this-&gt;m_chSymbol = &apos;B&apos;; this-&gt;m_nWeight = 100; this-&gt;m_nHeight = 200;&#125;CharacterB::~CharacterB()&#123;&#125;void CharacterB::SetSize(int nWeight, int nHeight)&#123; this-&gt;m_nWeight = nWeight; this-&gt;m_nHeight = nHeight;&#125;void CharacterB::Display()&#123; cout &lt;&lt; &quot;CharacterB：&quot; &lt;&lt; m_chSymbol &lt;&lt; &quot;(&quot; &lt;&lt; m_nWeight &lt;&lt; &quot;,&quot; &lt;&lt; m_nHeight &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;class CharacterFactory &#123;public: CharacterFactory(); virtual ~CharacterFactory(); Character* GetCharacter(char);private: std::map&lt;char, Character*&gt; m_mChar;&#125;;CharacterFactory::CharacterFactory()&#123; m_mChar.insert(make_pair&lt;char, Character*&gt;(&apos;A&apos;, new CharacterA)); m_mChar.insert(make_pair&lt;char, Character*&gt;(&apos;B&apos;, new CharacterB));&#125;CharacterFactory::~CharacterFactory()&#123;&#125;Character* CharacterFactory::GetCharacter(char chIn)&#123; map&lt;char, Character*&gt;::iterator it = m_mChar.find(chIn); if(it != m_mChar.end()) &#123; return (Character*)it-&gt;second; &#125; return NULL;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; CharacterFactory* pFactory = new CharacterFactory; //内蕴状态 存储在享元对象内部并且不会随环境改变而改变 Character* ch1 = pFactory-&gt;GetCharacter(&apos;A&apos;); ch1-&gt;Display(); //外蕴状态 客户端保存 Character* ch2 = pFactory-&gt;GetCharacter(&apos;B&apos;); ch2-&gt;SetSize(500, 800); ch2-&gt;Display(); return 0;&#125; 要点 面向对象很好的解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。 Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。 享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的：享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。另外它将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。 适用性当以下所有的条件都满足时，可以考虑使用享元模式： 一个系统有大量的对象。 这些对象耗费大量的内存。 这些对象的状态中的大部分都可以外部化。 这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。 软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。 满足以上的这些条件的系统可以使用享元对象。最后，使用享元模式需要维护一个记录了系统已有的所有享元的表，而这需要耗费资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。 优缺点享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的： 享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。 13.“一句话总结”和索引 代理模式（Proxy Pattern） 概述作为C++工程师，免不了要管理内存，内存管理也是C++中的难点，而智能指针采用引用计数的办法很方便的帮我们管理了内存的使用，极大方便了我们的工作效率。而智能指针的这种用法其实就是代理模式的一种，他帮我们控制了该对象的内存使用。 代理模式就是为其他对象提供一种代理来控制对这个对象的访问。 种类和用途Proxy模式根据种类不同，效果也不尽相同： 远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的对象是局域的而不是远程的，而代理对象承担了大部份的网络通讯工作。由于客户可能没有意识到会启动一个耗费时间的远程调用，因此客户没有必要的思想准备。 虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。 Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。 保护（Protector Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。保护代理的好处是它可以在运行时间对用户的有关权限进行检查，然后在核实后决定将调用传递给被代理的对象。 Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙（Firewall）代理：保护目标，不让恶意用户接近。 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。 智能引用（SmartReference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 在所有种类的代理模式中，虚拟（Virtual）代理、远程（Remote）代理、智能引用代理（SmartReference Proxy）和保护（Protector Access）代理是最为常见的代理模式。 类图和实例]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boost系列]]></title>
    <url>%2F2018%2F08%2F07%2Fboost%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[boost系列boost的link 和 runtime-link，搭配shared 和 static boost的link 和 runtime-link，搭配shared 和 static boost库在build时，./b2 install 后面可以跟一些参数，涉及到动态库、静态库的参数有以下四种搭配方式：link=static runtime-link=staticlink=static runtime-link=sharedlink=shared runtime-link=sharedlink=shared runtime-link=static （这种配置我试的结果是，报错，这样的搭配是非法的）究竟它们都是什么意思呢？ 我的粗浅理解： link=static runtime-link=staticbuild出来的就是.a (windows .lib) 文件，没有.so (windows .dll) 文件，link到可执行程序中以后，就成为后者的一部分，和后者融为一体了link=static runtime-link=shared build出来的同时有 .a (windows .lib) 文件和 .so (windows .dll) 文件，link时，是指定 .a (windows .lib) 文件，后者成为可执行程序的一部分，运行时，通过融入可执行程序的 .a (windows .lib) 的信息，去动态加载 .so (windows .dll) 文件，其实质仍然是动态链接link=shared runtime-link=sharedbuild出来的只有 .so (windows .dll) 文件，没有.a (windows .lib) 文件，但是，可执行程序在运行时，怎么找到动态库文件并加载它呢？ 网上看到的最多的介绍文章是下面这样的： link：生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用 static方式。runtime-link：动态/静态链接C/C++运行时库。同样有shared和static两种方 式，这样runtime-link和link一共可以产生4种组合方式。虽然它和link属性没有直接关系，但我们习惯上，一个工程如果用动态链接那么所 有库都用动态链接，如果用静态链接那么所有库都用静态链接。所以这样其实只需要编译2种组合即可，即link=shared runtime-link=shared和link=static runtime-link=static。 还有人总结windows下boost库的命名特点： link=static runtime-link=static 得到 libboostxxxxx.liblink=shared runtime-link=shared 得到 boostxxxx.lib 和 boostxxxx.dll由以上的文件夹层次结构基本就可以得出结论：１、以“lib”开头的是“link-static”版本的，而直接以“boost”开头的是“link-shared”版本的。２、有“d”的为debug版本，没有的则是release版本。３、有“s”的为“runtime-link-static”版本，没有的则是“runtime-link-shared”版本。４、有“mt”的为“threading-multi”版本，没有的则是“threading-single”版本。 一位在微软做过编译器开发的大牛是这样解释的：假设一个库A依赖于库B，我们自己的程序client依赖于库A，即：那么，link指的是client-&gt;A，runtime-link指的是A -&gt; B 配置 链接过程 运行时需要的文件 link=static、runtime-link=static client通过A.a (A.lib)静态包含A；A通过B.a (B.lib)静态包含B；不关 .so .dll的事 client link=static、runtime-link=shared client通过A.a (A.lib)静态包含A；在运行时，client要动态调用B.so (B.dll) client、B.so (B.dll) link=shared、runtime-link=shared client会包含A.a (A.lib)；A会包含 B.a (B.lib)；但都只保存动态库的真正实现的stub，运行时通过stub去动态加载 A.so (A.dll), B.so (B.dll) 中的实现 client、A.so (A.dll)、B.so (B.dll) link=shared、runtime-link=static client会包含A.a (A.lib)，但只包含真正实现的stub；A通过B.a (B.lib)静态包含B；运行时，client会动态调用A.so (A.dll)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++智能指针系列]]></title>
    <url>%2F2018%2F08%2F07%2FC-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[C++智能指针系列智能指针shared_ptr的用法 智能指针shared_ptr的用法 为了解决C++内存泄漏的问题，C++11引入了智能指针（Smart Pointer）。 智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。 C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件。 shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。 shared_ptr的基本用法初始化可以通过构造函数、std::make_shared辅助函数和reset方法来初始化shared_ptr： 123456789101112131415161718192021222324252627282930313233343536#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;using namespace std;class Person&#123;public: Person(int v) &#123; value = v; std::cout &lt;&lt; &quot;Cons&quot; &lt;&lt;value&lt;&lt; std::endl; &#125; ~Person() &#123; std::cout &lt;&lt; &quot;Des&quot; &lt;&lt;value&lt;&lt; std::endl; &#125; int value;&#125;;int main()&#123; std::shared_ptr&lt;Person&gt; p1(new Person(1));// Person(1)的引用计数为1 std::shared_ptr&lt;Person&gt; p2 = std::make_shared&lt;Person&gt;(2); p1.reset(new Person(3));// 首先生成新对象，然后引用计数减1，引用计数为0，故析构Person(1) // 最后将新对象的指针交给智能指针 std::shared_ptr&lt;Person&gt; p3 = p1;//现在p1和p3同时指向Person(3)，Person(3)的引用计数为2 p1.reset();//Person(3)的引用计数为1 p3.reset();//Person(3)的引用计数为0，析构Person(3) return 0;&#125; 注意，不能将一个原始指针直接赋值给一个智能指针，如下所示，原因是一个是类，一个是指针。 1std::shared_ptr&lt;int&gt; p4 = new int(1);// error reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx())重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管。 获取原始指针12std::shared_ptr&lt;int&gt; p4(new int(5));int *pInt = p4.get(); 指定删除器智能指针可以指定删除器，当智能指针的引用计数为0时，自动调用指定的删除器来释放内存。std::shared_ptr可以指定删除器的一个原因是其默认删除器不支持数组对象，这一点需要注意。 使用shared_ptr需要注意的问题但凡一些高级的用法，使用时都有不少陷阱。不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁，如下所示： 123int *p5 = new int;std::shared_ptr&lt;int&gt; p6(p5);std::shared_ptr&lt;int&gt; p7(p5);// logic error 不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入。 1function(shared_ptr&lt;int&gt;(new int), g()); 禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构。 避免循环引用。智能指针最大的一个陷阱是循环引用，循环引用会导致内存泄漏。解决方法是AStruct或BStruct改为weak_ptr。 1234567891011121314151617181920struct AStruct;struct BStruct;struct AStruct &#123; std::shared_ptr&lt;BStruct&gt; bPtr; ~AStruct() &#123; cout &lt;&lt; &quot;AStruct is deleted!&quot;&lt;&lt;endl; &#125;&#125;;struct BStruct &#123; std::shared_ptr&lt;AStruct&gt; APtr; ~BStruct() &#123; cout &lt;&lt; &quot;BStruct is deleted!&quot; &lt;&lt; endl; &#125;&#125;;void TestLoopReference()&#123; std::shared_ptr&lt;AStruct&gt; ap(new AStruct); std::shared_ptr&lt;BStruct&gt; bp(new BStruct); ap-&gt;bPtr = bp; bp-&gt;APtr = ap;&#125; shared_ptr 使用注意事项 c++ shared_ptr 使用注意事项 条款1：不要把一个原生指针给多个shared_ptr管理123int* ptr = new int;shared_ptr&lt;int&gt; p1(ptr);shared_ptr&lt;int&gt; p2(ptr); //logic error ptr对象被删除了2次这种问题比喻成“二龙治水”，在原生指针中也同样可能发生。 条款2：不要把this指针给shared_ptr12345678910class Test&#123;public: void Do()&#123; m_member_sp = shared_ptr&lt;Test&gt;(this); &#125;private: shared_ptr&lt;Test&gt; m_member_sp;&#125;;Test* t = new Test;shared_ptr&lt;Test&gt; local_sp(t);p-&gt;Do(); 发生什么事呢，t对象被删除了2次！t对象给了local_sp管理，然后在m_member_sp = shared_ptr(this)这句里又请了一尊神来管理t。这就发生了条款1里“二龙治水”错误。 条款3：不要让shared_ptr的循环引用1234567891011121314151617181920212223242526272829303132//---------------------------------------------class Dog;class Animal&#123;public: ~Animal()&#123; cout &lt;&lt; &quot;Animal Deconstructor&quot; &lt;&lt; endl; &#125; shared_ptr&lt;Dog&gt; _dog;&#125;;//---------------------------------------------class Dog&#123;public: ~Dog()&#123; cout &lt;&lt; &quot;Dog Deconstructor&quot; &lt;&lt; endl; &#125; shared_ptr&lt;Animal&gt; _animal;&#125;;//---------------------------------------------int main()&#123; shared_ptr&lt;Dog&gt; dog = make_shared&lt;Dog&gt;(); shared_ptr&lt;Animal&gt; animal = make_shared&lt;Animal&gt;(); dog-&gt;_animal = animal; animal-&gt;_dog = dog; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; return 0;&#125; 这样 Animal 和 Dog 都不会被回收.解决办法,将 shared_ptr _dog 或 shared_ptr&lt;Animal&gt; _animal 其中的一个换成 weak_ptr. 条款4：不要在函数实参里创建shared_ptrfunction ( shared_ptr(new int), g( ) ); //有缺陷可能的过程是先new int，然后调g( )，g( )发生异常，shared_ptr没有创建，int内存泄露 shared_ptr p(new int());f(p, g()); //Boost推荐写法 条款5：对象内部生成shared_ptr前面说过，不能把this指针直接扔给shared_ptr. 但是没有禁止在对象内部生成自己的shared_ptr //这是Boost的例子改的。 1234567class Y: public boost::enable_shared_from_this&lt;Y&gt;&#123; boost::shared_ptr&lt;Y&gt; GetSelf() &#123; return shared_from_this(); &#125;&#125;; 原理是这样的。普通的（没有继承enable_shared_from_this）类T的shared_ptr p(new T).p作为栈对象占8个字节，为了记录（new T）对象的引用计数，p会在堆上分配16个字节以保存引用计数等“智能信息”。share_ptr没有“嵌入(intrusive)”到T对象，或者说T对象对share_ptr毫不知情。Y对象则不同，Y对象已经被“嵌入”了一些share_ptr相关的信息，目的是为了找到“全局性”的那16字节的本对象的“智能信息”。 原理说完了，就是陷阱Y y;boost::shared_ptr p= y.GetSelf(); //无知的代码，y根本就不是new出来的 Y* y = new Y;boost::shared_ptr p= y-&gt;GetSelf(); //似是而非，仍旧程序崩盘。Boost文档说，在调用shared_from_this()之前，必须存在一个正常途径创建的shared_ptr boost::shared_ptr spy(new Y)boost::shared_ptr p = spy-&gt;GetSelf(); //OK 条款6 ：处理不是new的对象要小心12int* pi = (int*)malloc(4)shared_ptr&lt;int&gt; sp( pi ) ; //delete马嘴不对malloc驴头。 条款7：多线程对引用计数的影响如果是轻量级的锁，比如InterLockIncrement等，对程序影响不大如果是重量级的锁，就要考虑因为share_ptr维护引用计数而造成的上下文切换开销。1.33版本以后的shared_ptr对引用计数的操作使用的是Lock-Free（类似InterLockIncrement函数族）的操作，应该效率不错，而且能保证线程安全（库必须保证其安全，程序员都没有干预这些隐藏事物的机会）。Boost文档说read，write同时对shared_ptr操作时，行为不确定。这是因为shared_ptr本身有两个成员px，pi。多线程同时对px读写是要出问题的。与一个int的全局变量多线程读写会出问题的原因一样。 条款8：对象数组用shared_array12int* pint = new int[100];shared_array&lt;int&gt; p (pint ); 既然shared_ptr对应着delete；显然需要一个delete[]对应物shared_array 条款9：学会用删除器123456struct Test_Deleter&#123; void operator ()( Test* p)&#123; ::free(p); &#125;&#125;;Test* t = (Test*)malloc(sizeof(Test));new (t) Test; shared_ptr sp( t , Test_Deleter() ); //删除器可以改变share_ptr销毁对象行为 有了删除器，shared_array无用武之地了。 1234567template&lt;class T&gt;struct Array_Deleter&#123; void operator ()( T*)&#123; delete[] p; &#125;&#125;;int* pint = new int[100];shared_ptr&lt;int&gt; p (pint, Array_Deleter&lt;int&gt;() ); 条款10：学会用分配器存放引用计数的地方是堆内存，需要16-20字节的开销。如果大量使用shared_ptr会造成大量内存碎片。shared_ptr构造函数的第3个参数是分配器，可以解决这个问题。 shared_ptr p( (new Test), Test_Deleter(), Mallocator() );注意删除器Test_Deleter是针对Test类的。分配器是针对shared_ptr内部数据的。 Mallocator()是个临时对象（无状态的），符合STL分配器规约。 1234567template &lt;typename T&gt;class Mallocator &#123; //略。。。。。。 T * allocate(const size_t n) const &#123; return singleton_pool&lt;T,sizeof(T)&gt;::malloc(); &#125; //略。。。。。。 Mallocator传入Test，实际分配的类型确是 123class boost::detail::sp_counted_impl_pda&lt;class Test *, struct Test_Deleter, class Mallocator&lt;class Test&gt; &gt; 这是用typeid(T).name()打印出来的。可能和rebind相关。 条款11 weak_ptr在使用前需要检查合法性1234567weak_ptr&lt;K&gt; wp;&#123;shared_ptr&lt;K&gt; sp(new K); //sp.use_count()==1wp = sp; //wp不会改变引用计数，所以sp.use_count()==1shared_ptr&lt;K&gt; sp_ok = wp.lock(); //wp没有重载-&gt;操作符。只能这样取所指向的对象&#125;shared_ptr&lt;K&gt; sp_null = wp.lock(); //sp_null .use_count()==0; 因为上述代码中sp和sp_ok离开了作用域，其容纳的K对象已经被释放了。得到了一个容纳NULL指针的sp_null对象。在使用wp前需要调用wp.expired()函数判断一下。因为wp还仍旧存在，虽然引用计数等于0，仍有某处“全局”性的存储块保存着这个计数信息。直到最后一个weak_ptr对象被析构，这块“堆”存储块才能被回收。否则weak_ptr无法知道自己所容纳的那个指针资源的当前状态。 条款12 不要new shared_ptr&lt;T&gt;本来shared_ptr就是为了管理指针资源的，不要又引入一个需要管理的指针资源shared_ptr* 条款13 尽量不要get123456class B&#123;...&#125;;class D : public B&#123; ...&#125;; //继承层次关系shared_ptr&lt;B&gt; sp (new D); //通过隐式转换，储存D的指针。B* b = sp.get(); //shared_ptr辛辛苦苦隐藏的原生指针就这么被刨出来了。D* d = dynamic_cast&lt;D*&gt;(b); //这是使用get的正当理由吗？ 正确的做法shared_ptr&lt;B&gt; spb (new D) ;shared_ptr&lt;D&gt; spd = shared_dynamic_cast&lt;D&gt;(spb); //变成子类的指针shared_ptr在竭尽全力表演的像一个原生指针，原生指针能干的事，它也基本上能干。 另一个同get相关的错误shared_ptr&lt;T&gt; sp(new T);shared_ptr&lt;T&gt; sp2( sp.get() ) ;//又一个“二龙治水”实例，指针会删2次而错误。 条款14 不要memcpy shared_ptr123shared_ptr&lt;B&gt; sp1 (new B) ;shared_ptr&lt;B&gt; sp2;memcpy(&amp;sp2,&amp;sp1,sizeof(shared_ptr&lt;B&gt;)); //sp2.use_count()==1 很显然，不是通过正常途径（拷贝构造，赋值运算），引用计数是不会正确增长的。 条款15 使用BOOST预定义的宏去改变shared_ptr行为。shared_ptr行为由类似BOOST_SP_DISABLE_THREADS这样的宏控制。需要去学习他们到底是干什么的。大师Andrei Alexandrescu设计了一种基于模板策略设计模式的智能指针，通过几个模板参数去定制化智能指针的行为。Boost却不以为然，官方解释是：需要统一的接口，这样利于大规模书写。smart_ptr&lt;T,OwnershipPolicy,ConversionPolicy,CheckingPolicy,StoragePolicy&gt; sp(new T);上述接口缺点是外形复杂，看上去像个大花脸。优点是客户程序员可以轻易的定制行为。 条款17 构造函数里调用shared_from_this抛例外1234567class Holder:public enable_shared_from_this&lt;Holder&gt;&#123;public: Holder() &#123; shared_ptr&lt;Holder&gt; sp = shared_from_this(); int x = sp.use_count(); &#125;&#125;; 同前面条款5，不符合enable_shared_from_this使用前提。 总结：学习了一天就总结出10多条条款，长期研究一下恐怕就出现条款100了。为什么还要使用shared_ptr呢？有很多开源库用shared_ptr，而且shared_ptr具有“传染性”（某网友语：像毒品沾上就甩不掉），抛开它就会有更严重的多龙治水现象。shared_ptr作为原生指针的替代品，能解决一定的内存泄露问题。实际上初学原生指针时，每个人都遇到过野指针，删两次，忘记删除等问题。学习shared_ptr也会遇到。shared_ptr的确能改善上述问题，并不能完全解决问题。shared_ptr可能在将来占主流，它最可能号令江湖，否则一大堆auto_ptr,weak_ptr,原生指针，scoped_ptr共存就把人搞糊涂了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[针对范围对的高效查找算法设计]]></title>
    <url>%2F2018%2F08%2F07%2F%E9%92%88%E5%AF%B9%E8%8C%83%E5%9B%B4%E5%AF%B9%E7%9A%84%E9%AB%98%E6%95%88%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[针对范围对的高效查找算法设计 针对范围对的高效查找算法设计（不准用数组） 描述如下： 假如有一群范围对，格式为：&lt;范围表示，该范围对应的结果值&gt;，设计一个最快查找算法，使得给定一个值，输出该值所在范围对的结果值。注意1：范围对之间没有交集，即不可能存在&lt;1, 10&gt;和&lt;2, 11&gt;这样的两个范围对。 注意2：各个区间不一定严格相邻，也就是可能只有&lt;1, 3&gt;和&lt;99, 201&gt;这样两个区间，所以STL中的lower_bound不适用。例如有以下几个范围对：&lt;&lt;1, 2&gt;, 20&gt;&lt;&lt;3, 37&gt;, 27&gt;&lt;&lt;48, 57&gt;, 28&gt;&lt;&lt;58, 63&gt;, 27&gt;&lt;&lt;97, 128&gt;, 122&gt;&lt;&lt;129, 149&gt;, 12&gt;&lt;&lt;150, 189&gt;, 13&gt;&lt;&lt;200, 245&gt;, 14&gt;&lt;&lt;246, 256&gt;, 129&gt;&lt;&lt;479, 560&gt;, 12&gt; 假如给定一个数100，则根据题意应输出122，因为100属于范围对&lt;97, 128&gt; 要求：不要用范围对作为下标用数组来存储，因为范围对可能非常大。 对于这个问题，思考许久，有了下面几个思路： 用STL map来存储这些范围对（key）及对应的结果集（value），用map进行查找范围对定义如下： 123456789class range &#123;public: int from; int to;public: range(): from(-1), to(-1) &#123;&#125; range(int f, int t): from(f), to(t) &#123;&#125;&#125;; map定义为： 1typedef map&lt;range*, int&gt; range_map; 但这里有个问题，map的key是自定义类型，一般需要自定义比较函数才能进行查找，一般的自定义比较函数如下： 12345struct cmp_func &#123; bool operator()(const range* lc,const range* rc) const &#123; return (lc-&gt;from &lt; rc-&gt;from) || (lc-&gt;from == rc-&gt;from &amp;&amp; lc-&gt;to &lt; rc-&gt;to); &#125;&#125;; 但这样的比较函数并不适用于我们的需求，因为我们要求查询的并不是一个范围对，即并不是查询map中有没有&lt;3, 37&gt;这样的范围对，而是要求给定一个值，查询这个值属于哪个范围对，那么能不能自定义一个这样的比较函数呢？以上面那个例子为例，如果我们查找35这个数，我们将35包装成一个范围对&lt;35, 35&gt;，然后查找它包含在map中的哪个范围对，上面的例子是包含在&lt;3, 37&gt;这样的范围对，这样就找到了，也就是两个key相等，只要它们包含在同一个范围对即可。这似乎有点奇怪，违背了通常意义上的比较含义（也就是两个key相等，两个key的组成部分都应该相同才是）。不管如何，这样的比较函数还是比较简单的，如下： 12345struct cmp_func &#123; bool operator()(const range* lc,const range* rc) const &#123; return lc-&gt;to &lt; rc-&gt;from; &#125;&#125;; 这样就实现了我们用map的find函数来查找给定的一个数属于哪个范围对了。当然，这时我们的map定义就变成了： 1typedef map&lt;range*, int, cmp_func&gt; range_map; 用map查找表面上看上去应该挺高效的，至少比一个个顺序查找要快吧，但事实却并非如此。我用未自定义比较函数的map顺序查找和自定义上面比较函数的map find查找，结果却发现用自定义比较函数后的效果并不好，竟然比顺序查找还要慢，下面的粗糙的测试程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;map&gt;#include&lt;sys/time.h&gt;using namespace std;class range &#123;public: int from; int to;public: range(): from(-1), to(-1) &#123;&#125; range(int f, int t): from(f), to(t) &#123;&#125;&#125;;struct cmp_func &#123; bool operator()(const range* lc,const range* rc) const &#123; return lc-&gt;to &lt; rc-&gt;from; &#125;&#125;;typedef map&lt;range*, int, cmp_func&gt; range_map;int get_next1(range_map *rm, int c) &#123; for(range_map::iterator it = rm-&gt;begin(); it != rm-&gt;end(); ++it) &#123; if(c &gt;= it-&gt;first-&gt;from &amp;&amp; c &lt;= it-&gt;first-&gt;to) return it-&gt;second; &#125; return -1; // not found.&#125;int get_next2(range_map *rm, int c) &#123; range_map::iterator iter = rm-&gt;find(new range(c, c)); if(iter != rm-&gt;end()) return iter-&gt;second; return -1; // not found.&#125;int main()&#123; struct timeval t_begin, t_end; range_map *rm = new range_map(); rm-&gt;insert(pair&lt;range*, int&gt;(new range(1, 2), 20)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(3, 37), 27)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(48, 57), 28)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(58, 63), 27)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(97, 128), 122)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(129, 149), 12)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(150, 189), 12)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(200, 245), 14)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(246, 256), 129)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(479, 560), 12)); gettimeofday(&amp;t_begin,NULL); int result[256]; for(int c = 0; c &lt; 256; c++) result[c] = get_next1(rm, c); gettimeofday(&amp;t_end,NULL); double timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec); timeuse/=1000000; printf(&quot;\nget_next1 time use: %.12f\n&quot;, timeuse); for(int c = 0; c &lt; 256; c++) cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; gettimeofday(&amp;t_begin,NULL); for(int c = 0; c &lt; 256; c++) result[c] = get_next2(rm, c); gettimeofday(&amp;t_end,NULL); timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec); timeuse/=1000000; printf(&quot;\nget_next2 time use: %.12f\n&quot;, timeuse); for(int c = 0; c &lt; 256; c++) cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; 运行结果为： 12get_next1 time use: 0.000124000000get_next2 time use: 0.000144000000 当然这个例子并不能代表所有情况，且每次运行结果也不一样，但从每次的运行结果来看，几乎没有一次是用自定义比较函数比顺序查找情况好的。这至少说明了一点：我们的自定义比较函数让map在查找时做了一些额外的工作，减慢了速度。比如我们为了使用map的find函数，不得不封装我们的一个数为一个range对象，在查找的时候还得调用我们自定义的比较函数进行处理。 难道就只能顺序查找吗？在这个不靠谱的思路过后又萌生了另一个不靠谱的思路。 使用二分查找的思想来查找范围对我们使用ranges和results这两个数组来保存范围对及对应的结果，按序保存，每两个ranges数对应一个results里的数。 例如上面的例子保存为： int ranges[] = {1, 2, 3, 37, 48, 57, 58, 63, 97, 128, 129, 149, 150, 189, 200, 245, 246, 256, 479, 560};int results[] = {20, 27, 28, 27, 122, 12, 13, 14, 129, 12}; 使用二分查找来查找某个数属于哪个范围对。那么如何查找呢？比如查找35属于哪个范围对，首先与最中间的128进行比较，35&lt;128，这时候有两种可能： （1）100在128前半部分的数组里，即1, 2, 3, 37, 48, 57, 58, 63, 97； （2）由于128是范围对&lt;97, 128&gt;的第二部分，那么也有可能这个数属于这个范围对。 由于35不属于这个范围对，那么只有在97之前的部分找（不包括97），继续二分即与37进行比较，35 &lt; 37，与上类似，此时35属于范围对&lt;3, 37&gt;，也就是找到了。 再举个例子，找130属于哪个范围对，同样的先与128比较，130 &gt; 128，这时候130只可能在128的后半部分而不需要判断是否属于范围对&lt;128, 129&gt;，因为&lt;128, 129&gt;不是范围对。怎么判断是不是范围对呢？很简单，根据当前位置的奇偶性判断即可。 下面是我写的二分查找算法，及与map顺序查找、数组顺序查找的简单对比试验： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;map&gt;#include&lt;sys/time.h&gt;using namespace std;class range &#123;public: int from; int to;public: range(): from(-1), to(-1) &#123;&#125; range(int f, int t): from(f), to(t) &#123;&#125;&#125;;typedef map&lt;range*, int&gt; range_map;int get_next1(range_map *rm, int c) &#123; for(range_map::iterator it = rm-&gt;begin(); it != rm-&gt;end(); ++it) &#123; if(c &gt;= it-&gt;first-&gt;from &amp;&amp; c &lt;= it-&gt;first-&gt;to) return it-&gt;second; &#125; return -1; // not found.&#125;// binary searchint get_next2(int *ranges, int *results, int size, int c) &#123; if(size &lt;= 1) return -1; int start, end, mid; start = 0; end = size - 1; while(start &lt;= end) &#123; if(c &lt; ranges[start] || c &gt; ranges[end]) return -1; mid = start + (end - start) / 2; if(c == ranges[mid]) return results[mid / 2]; if(c &lt; ranges[mid]) &#123; if(mid % 2 == 1) &#123; if(c &gt;= ranges[mid - 1]) return results[mid / 2]; else end = mid - 2; &#125; else end = mid - 1; &#125; else &#123; if(mid % 2 == 0) &#123; if(c &lt;= ranges[mid + 1]) return results[mid / 2]; else start = mid + 2; &#125; else start = mid + 1; &#125; &#125; return -1; // not found.&#125;int get_next3(int *ranges, int *results, int size, int c) &#123; for(int i = 0; i &lt; size;) &#123; if(i % 2 == 0) &#123; if(c &gt;= ranges[i] &amp;&amp; c &lt;= ranges[i + 1]) return results[i / 2]; else if(c &lt; ranges[i]) return -1; else i += 2; &#125; &#125;&#125;int main()&#123; struct timeval t_begin, t_end; range_map *rm = new range_map(); rm-&gt;insert(pair&lt;range*, int&gt;(new range(1, 2), 20)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(3, 37), 27)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(48, 57), 28)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(58, 63), 27)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(97, 128), 122)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(129, 149), 12)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(150, 189), 13)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(200, 245), 14)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(246, 256), 129)); rm-&gt;insert(pair&lt;range*, int&gt;(new range(479, 560), 12)); int ranges[] = &#123;1, 2, 3, 37, 48, 57, 58, 63, 97, 128, 129, 149, 150, 189, 200, 245, 246, 256, 479, 560&#125;; int results[] = &#123;20, 27, 28, 27, 122, 12, 13, 14, 129, 12&#125;; // int r = get_next2(ranges, results, 20, 65); // cout &lt;&lt; r &lt;&lt; endl; gettimeofday(&amp;t_begin,NULL); int result[256]; for(int c = 0; c &lt; 256; c++) result[c] = get_next1(rm, c); gettimeofday(&amp;t_end,NULL); double timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec); timeuse/=1000000; printf(&quot;\nget_next1 time use: %.12f\n&quot;, timeuse); // for(int c = 0; c &lt; 256; c++) // cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; gettimeofday(&amp;t_begin,NULL); for(int c = 0; c &lt; 256; c++) result[c] = get_next2(ranges, results, 20, c); gettimeofday(&amp;t_end,NULL); timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec); timeuse/=1000000; printf(&quot;\nget_next2 time use: %.12f\n&quot;, timeuse); // for(int c = 0; c &lt; 256; c++) // cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; gettimeofday(&amp;t_begin,NULL); for(int c = 0; c &lt; 256; c++) result[c] = get_next3(ranges, results, 20, c); gettimeofday(&amp;t_end,NULL); timeuse=1000000*(t_end.tv_sec-t_begin.tv_sec)+(t_end.tv_usec-t_begin.tv_usec); timeuse/=1000000; printf(&quot;\nget_next3 time use: %.12f\n&quot;, timeuse); // for(int c = 0; c &lt; 256; c++) // cout &lt;&lt; result[c] &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; return 0;&#125; 运行结果为： 123get_next1 time use: 0.000302000000get_next2 time use: 0.000043000000get_next3 time use: 0.000165000000 说明二分查找算法还是挺高效的，顺序查找也不错，有时候表现的与二分查找差不多，这里的数据比较少，体现不出准确的对比，但至少可能说明二分查找算法比简单的顺序查找（map顺序和数组顺序查找）要快不少。 上面是自己的一点拙见，相信二分查找算法肯定不是最高效的算法，但目前实在想不出更好的办法了。大家有想法的尽管提，不试试不知道算法好不好！]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现]]></title>
    <url>%2F2018%2F08%2F07%2FUML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%85%AD%E5%A4%A7%E5%85%B3%E7%B3%BB%EF%BC%9A%E5%85%B3%E8%81%94%E3%80%81%E8%81%9A%E5%90%88%E3%80%81%E7%BB%84%E5%90%88%E3%80%81%E4%BE%9D%E8%B5%96%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现简介在UML类图中，类之间的关系可以分成：关联(association)、聚合(aggregation)、组合(composition)、依赖(dependency)、泛化(generalization)/继承(inheritance)和实现(realization)。这六种关系如下图所描绘： 上面的关系可以解读如下: (关联)Association：A类有B类有逻辑上的连接 (聚合)Aggregation : A类有一个B类 (组合)Composition : A类拥有一个B类 (依赖)Dependency : A类使用了B类 (继承)Inheritance : B类是一个A类 (或者B类扩展A类) (实现)Realization : B类实现了接口A 本篇文章主要是展示在Java中如何表示这些关系 ,以便我们可以更好地理解这些关系并且知道如何以及何时使用每一种关系。 关联(association)关联描述两个类之间行为的一般二元关系。例如，一个学生选修一门特定的课程是学生类Student和课程类Course之间的一个关联，而一个教师教授一门课程是师资类Faculty和课程类Course之间的一个关联。Java代码中，关联可以用属性和方法来实现。 12345678910111213141516171819202122232425262728public class Student &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125;&#125;public class Course &#123; private Strudent[] students; private Faculty faculty; public void addStudent(Student s) &#123; . . . . . . &#125; public void setFaculty(Faculty faculty) &#123; this.faculty = faculty; &#125;&#125;public class Faculty &#123; private Course[] courses; public void addCourse(Course s) &#123; . . . . . . &#125;&#125; 聚合(Aggregation)聚合是一种特殊的关联(Association)形式，表示两个对象之间的所属(has-a)关系。所有者对象称为聚合对象，它的类称为聚合类；从属对象称为被聚合对象，它的类称为被聚合类。例如，一个公司有很多员工就是公司类Company和员工类Employee之间的一种聚合关系。被聚合对象和聚合对象有着各自的生命周期，即如果公司倒闭并不影响员工的存在。 1234567 public class Company &#123; private List&lt;Employee&gt; employees;&#125;public class Employee &#123; private String name; &#125; 组合(Composition)聚合是一种较弱形式的对象包含(一个对象包含另一个对象)关系。较强形式是组合(Composition). 在组合关系中包含对象负责被包含对象的创建以及生命周期，即当包含对象被销毁时被包含对象也会不复存在。例如一辆汽车拥有一个引擎是汽车类Car与引擎类Engine的组合关系。下面是组合的一些例子。 (1)通过成员变量初始化1234567public class Car &#123; private final Engine engine = new Engine(); &#125;class Engine &#123; private String type;&#125; (2)通过构造函数初始化1234567891011public class Car &#123; private final Engine engine; public Car()&#123; engine = new Engine(); &#125;&#125;public class Engine &#123; private String type;&#125; (3)通过延迟初始化12345678910111213public class Car &#123; private final Engine engine; public Engine getEngine() &#123; if (null == engine) &#123; engine = new Engine(); &#125; return engine; &#125; &#125;public class Engine &#123; private String type;&#125; 依赖(Dependency)依赖(Dependency)描述的是一个类的引用用作另一个类的方法的参数。例如，可以使用Calendar类中的setTime(Date date)方法设置日历，所以Calendar和Date之间的关系可以用依赖描述。12345678public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; &#123; public final void setTime(Date date) &#123; setTimeInMillis(date.getTime()); &#125; . . . . . .&#125; 在依赖关系中，类之间是松耦合的。 继承(Inheritance)继承(Inheritance)模拟两个类之间的is-a关系。强是(strong is-a)关系描述两个类之间的直接继承关系。弱是(weak is-a)关系描述一个类具有某个属性。强是关系可以用类的继承表示。例如，Spring的ApplicationEvent是一个EventObject，ApplicationEvent和EventObject间就是一种强是关系，可以用继承描述。123public abstract class ApplicationEvent extends EventObject &#123; . . . . . .&#125; 实现(Realization)实现(Realization)描述的是一个类实现了接口（可以是多个）。上面描述的弱是(weak is-a)关系就可以用接口表示。例如字符串是可以被序列化的，这就可以用实现来描述。123public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; . . . . . .&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个可注销的通用多路回调列表]]></title>
    <url>%2F2018%2F08%2F06%2F%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%B3%A8%E9%94%80%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%9A%E8%B7%AF%E5%9B%9E%E8%B0%83%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一个可注销的通用多路回调列表 文章出处：(C++) 一个可注销的通用多路回调列表 背景回调列表是个很常见的东东，经常被用在 Observer 这样的订阅/发布模式里。当系统触发一个事件时，会遍历所有已经注册的回调列表，挨个调用，通知到相关的对象。 我们知道，为了保持对 C 尽可能的兼容，一直以来，C++ 中的函数并非是所谓的“一级对象” (first-class objects)。而在函数指针的帮助下，我们可以在 C/C++ 中模拟一些 First-class function 才有的特性，比如把函数像值一样以参数传递和保存。到了 C++11 的出现，有了语言和标准库级别的 lambda / closure / std::function 之后，对函数的操作才变得真正灵活和丰富起来。 常见的 C/C++ 回调列表有以下这几种实现方式： 基类指针 （形如 std::vector&lt;IListener*&gt;），当回调发生时，以虚函数的形式通知到不同的派生类的对象。这个方案的问题在于，凡是想加入这个列表，必须从 IListener 派生，而且所有的虚函数要求签名严格一致，耦合太高，灵活性较差。 函数指针 （形如 std::vector），当回调发生时，挨个调用容器中的函数指针。这个方案避免了继承的强耦合，但仍需要保证所有的响应函数签名一致，而且每一种类型的响应函数都要定义不同的回调列表，多了之后非常啰嗦，再一个函数指针本身可读性也欠佳。 函数对象 （形如std::vector&lt;std::function&lt; … &gt;&gt;），这种回调列表相对于上面两个更加灵活一些，不仅不需要继承，在 std::bind 的帮助下，连函数签名也不需要一致。但问题是，由于 std::function 无法使用 == 和 != 来比较（见参考一(第1条)和参考二），注销比较麻烦，不像上面两个可以直接指针比较。 好处那么这里介绍的所谓通用回调列表有何好处呢？ （以所谓“完美转发”的形式）支持任意个数和类型的参数调用 在上面第三点 std::function&lt;&gt; 的基础上，可以使用 std::string 作为 tag， 标记那些后面需要被注销的函数，也同时支持不打 tag 的函数 在需要时，支持批量地收集这些回调函数的返回值 接口说完了好处，接下来看一下 BtMulticast 这个类的对外接口和基本的使用吧：123456789101112131415161718template &lt;typename TRet, class... TArgs&gt;class BtMulticast&#123;public: using TFunc = std::function &lt; TRet(TArgs...) &gt; ; using TElem = std::pair &lt; TFunc, std::string &gt; ; using TRetVect = std::vector &lt; std::pair &lt; TRet, std::string &gt; &gt;; bool AddFunc(TFunc func); bool AddFunc(const std::string&amp; tag, TFunc func); void RemoveFunc(const std::string&amp; tag); template&lt;class... U&gt; void Invoke(U&amp;&amp;... u); template&lt;class... U&gt; TRetVect InvokeR(U&amp;&amp;... u);private: std::vector &lt; TElem &gt; m_funcList;&#125;; 这个类很简短， AddFunc / RemoveFunc 是添加和删除回调函数 Invoke / InvokeR 分别触发无返回值和普通返回值的回调。 需要注意的是， AddFunc() 可以选择指明 tag， 在这种情况下可通过指明 tag 来 RemoveFunc InvokeR() 实际上返回的是一个返回值列表，采集了每一个回调的结果 TFunc 这个类型定义了最终存储在 BtMulticast 类中的回调函数对象，利用了 C++11 的所谓“完美转发”来把任意类型和个数的参数转发给回调函数 考虑到 add/remove 通常只发生一次，而每次触发事件都会遍历，内部的存储选择 std::vector，牺牲了一点 add/remove 时的查找速度，换得更快更紧凑的遍历。而看一下实现代码就可以知道，牺牲的那点 add/remove 速度也只有在有 tag 的情况下会发生。 用法使用方面，基本用法如下：12345678// testing multicast: simplest&#123; BtMulticast&lt;void&gt; test; test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 1 called. &quot;); &#125;); test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 2 called. &quot;); &#125;); test.AddFunc([]() &#123; BT_LOG(&quot;Multicast (simplest): func 3 called. &quot;); &#125;); test.Invoke();&#125; 三个匿名函数被添加进 test 对象，然后在 test.Invoke() 的时候被依次调用。123456789// testing multicast: tagged &amp; single parameter&#123; BtMulticast&lt;void, int&gt; test; test.AddFunc(&quot;a&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func a called (param: %d). &quot;, p); &#125;); test.AddFunc(&quot;b&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func b called (param: %d). &quot;, p); &#125;); test.AddFunc(&quot;c&quot;, [](int p) &#123; BT_LOG(&quot;Multicast (tagged): func c called (param: %d). &quot;, p); &#125;); test.RemoveFunc(&quot;b&quot;); test.Invoke(15);&#125; 三个 tag 分别为 “a”, “b”, “c” 的匿名函数 (参数为 int，注意实例化 BtMulticast 时的类型参数列表变化) 被注册进来，然后 tag 为 “b” 的匿名函数被移除，最后以 15 作为参数依次调用剩下的回调函数 (“a” 和 “c”)。1234567891011// testing multicast with multiple parameters and return value list&#123; BtMulticast&lt;int, int, int&gt; testRet; testRet.AddFunc(&quot;a&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func a called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 1 * p2; &#125;); testRet.AddFunc(&quot;b&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func b called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 2 * p2; &#125;); testRet.AddFunc(&quot;c&quot;, [](int p1, int p2) -&gt; int &#123; BT_LOG(&quot;Multicast (with RetVal): func c called (p1: %d, p2: %d). &quot;, p1, p2); return p1 + 3 * p2; &#125;); testRet.RemoveFunc(&quot;b&quot;); for (auto&amp; p : testRet.InvokeR(20, 2)) BT_LOG(&quot;Multicast (with RetVal): func %s returned %d. &quot;, p.second, p.first);&#125; 最后这个用例测试了多个参数和返回值的情况，可以看到 “a”, “b”, “c” 做了不同的操作后，返回的值被采集到了一个返回值列表里面，这个列表被就地 (即所谓的 move 语意) 遍历，内部的值可以根据需要再进行处理。这个用例的运行结果如下： 1234Multicast (with RetVal): func a called (p1: 20, p2: 2).Multicast (with RetVal): func c called (p1: 20, p2: 2).Multicast (with RetVal): func a returned 22.Multicast (with RetVal): func c returned 26. 可以看到 BtMulticast 能够适配任意个数和类型的参数，因此可认为具有一定的通用性。 实现最后我们简单看一下实现。先看看 BtMulticast::AddFunc()，123456789101112131415template &lt;typename TRet, class... TArgs&gt;bool BtMulticast&lt;TRet, TArgs...&gt;::AddFunc(const std::string&amp; tag, TFunc func)&#123; // check if this tag has been used if (tag.size()) &#123; auto it = std::find_if(m_funcList.begin(), m_funcList.end(), [&amp;tag](const TElem&amp; elem) &#123; return elem.second == tag; &#125;); if (it != m_funcList.end()) return false; &#125; m_funcList.emplace_back(func, tag); return true;&#125; 当 tag 有效时，先判定是否有 tag 冲突，然后注册一下回调，过程很直白就不多说了。 再看一下具体的调用过程 BtMulticast::InvokeR()，12345678910111213141516171819/* ----- Note ----- `BtMulticastRetVect` is an extra alias especially for the returning type for the signature of InvokeR() below, since `TRetVect` defined inside `BtMulticast` cannot be used in the signature (outside the function body) although `BtMulticastRetVect` is defined separately, it literally equals to `typename BtMulticast::TRetVect`*/template &lt;typename TRet&gt;using BtMulticastRetVect = std::vector &lt; std::pair &lt; TRet, std::string &gt; &gt; ;template &lt;typename TRet, class... TArgs&gt;template &lt;class... U&gt;BtMulticastRetVect&lt;TRet&gt; BtMulticast&lt;TRet, TArgs...&gt;::InvokeR(U&amp;&amp;... u)&#123; BtMulticastRetVect&lt;TRet&gt; ret; for (auto&amp; p : m_funcList) &#123; ret.emplace_back(p.first(std::forward&lt;U&gt;(u)...), p.second); &#125; return ret;&#125; 这里可以看到我单独定义了一下返回值的类型，具体原因见注释，大体上是说类内定义的类型 TRetVect 只能在类内使用 (包括类定义及相关的成员函数体的定义，成员函数的签名不算在内)。另外这函数前面的两个 template 声明分别是类的模板和函数的模板。 俺一直觉得 C++ 的模板声明挺啰嗦，很有孔乙己范儿，看了上面这个函数声明，你也一定深有同感罢。应该跟 D 学一下，简化一下。 C++ 的 typedef 和 class template，123456typedef double A;template&lt;class T&gt; struct B&#123; typedef int A;&#125;; D 的对应语法 alias 和模板的 (T) 语法，简洁到没朋友。123456alias A = double;class B(T)&#123; alias A = int;&#125; 不过 C++ 已经把 D 的 alias 关键字的用法学来了，翻到前面可以看到 class BtMulticast 的定义中的那一组 using，把 alias 抄了个十足十，啧啧，借鉴得不错。 BtMulticast 类的实现和测试用例代码见这里。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础系列]]></title>
    <url>%2F2018%2F08%2F03%2FC-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[C++基础系列C/C++中各种类型int、long、double、char表示范围（最大最小值）源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt; #include&lt;string&gt; #include &lt;limits&gt; using namespace std; int main() &#123; cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl; cout &lt;&lt; &quot;bool: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(bool); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;bool&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;char: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(char); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;char&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;signed char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(signed char); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;signed char&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;unsigned char: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned char); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned char&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;wchar_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(wchar_t); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;wchar_t&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;short: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(short); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::max)(); cout &lt;&lt; &quot;\t\t最小值：&quot; &lt;&lt; (numeric_limits&lt;short&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;int: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(int); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;int&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;unsigned: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;long: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;unsigned long: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(unsigned long); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;unsigned long&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(double); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;double&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;long double: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(long double); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;long double&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;float: \t\t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(float); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;float&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;size_t: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(size_t); cout &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::max)(); cout &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;size_t&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;string: \t&quot; &lt;&lt; &quot;所占字节数：&quot; &lt;&lt; sizeof(string) &lt;&lt; endl; // &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl; cout &lt;&lt; &quot;type: \t\t&quot; &lt;&lt; &quot;************size**************&quot;&lt;&lt; endl; return 0; &#125; /*运行结果分析：以上结果已经很明白了，一下补充说明几点：概念、整型：表示整数、字符和布尔值的算术类型合称为整型（integral type）。关于带符号与无符号类型：整型 int、stort 和 long 都默认为带符号型。要获得无符号型则必须制定该类型为unsigned，比如unsigned long。unsigned int类型可以简写为unsigned，也就是说，unsigned后不加其他类型说明符就意味着是unsigned int。一字节表示八位，即：1byte = 8 bit;int: 4byte = 32 bit 有符号signed范围：2^31-1 ~ -2^31即：2147483647 ~ -2147483648无符号unsigned范围：2^32-1 ~ 0即：4294967295 ~ 0long: 4 byte = 32 bit 同int型double: 8 byte = 64 bit 范围：1.79769e+308 ~ 2.22507e-308long double: 12 byte = 96 bit 范围： 1.18973e+4932 ~ 3.3621e-4932float: 4 byte = 32 bit 范围： 3.40282e+038 ~ 1.17549e-038int、unsigned、long、unsigned long 、double的数量级最大都只能表示为10亿，即它们表示十进制的位数不超过10个，即可以保存所有9位整数。而short只是能表示5位； 另外对于浮点说而言：使用double类型基本上不会有错。在float类型中隐式的精度损失是不能忽视的，二双精度计算的代价相对于单精度可以忽略。事实上，在有些机器上，double类型比float类型的计算要快得多。float型只能保证6位有效数字，而double型至少可以保证15位有效数字（小数点后的数位），long double型提供的精度通常没有必要，而且还要承担额外的运行代价。double是8字节共64位，其中小数位占52位，2-^52=2.2204460492503130808472633361816e-16，量级为10^-16，故能够保证2^-15的所有精度。在有些机器上，用long类型进行计算所付出的运行时代价远远高于用int类型进行同样计算的代价，所以算则类型前要先了解程序的细节并且比较long类型与int类型的实际运行时性能代价。 浅析Windows中的句柄Handle的本质 参考文章：浅析Windows中的句柄Handle的本质[摘要] 本文讨论Windows中的句柄Handle的本质，使程序员能够真正熟悉经常使用的句柄的含义。相信通过本文会对句柄有一个确切的认识，能够更好的指导编程开发。 在Windows中，句柄是非常有用的东西。什么是句柄。有很多资料，包括MSDN也讲述了句柄是一个32位或者64位的整数值，是一种数据类型，标志了一个对象，可以通过这个句柄访问对象。看了这样的解释，我不相信你就真的明白了句柄是什么。 在C和C++中，指针是无所不能的，因此也是很危险的。系统的很多东西，如果知道确切地址，通过指针就可以直接修改，从而破坏系统。有了指针，指针中的值就存放了内存地址，就可以直接对内存的数据进行修改。系统的内核的东西，是不允许直接访问的，所有操作都必须通过API函数进行，这样就可以保证系统不会被破坏。但是要访问内核的东西，总得要有一个可以定位的东西，比如说地址，这样才能真正知道要操作内核的哪些东西，因为东西很多，总要区分一下。如果说直接给地址，用指针形式进行定位操作，那就会危及系统，所以微软就不提供这种方法来操作。很自然，就采用了一个代号，给内存的所有东西取个名字，就产生一个代号，通过这个代号，你并不知道它的确切的位置，你就无从直接操作它，就不会带来破坏。这个代号要让访问者知道，就必须存储起来，而访问者在系统中是以进程的形式存在的，所以，这些代号就跟进程相关了。一个进程创建了一个东西，这个东西就会返回一个代号，这个代号就记录到进程的一个表了，这样就可以通过这个代号找到这个东西了。而在这个表中，肯定是有一个映射关系的，也就是，这个代号一定会与这个东西的位置进行关联，以后通过这个代号，在表里就能够找到这个东西的地址，然后再操作这个东西。 说了这么多很不专业的描述，相信你对这个过程大致有印象了。这个代号就是句柄，这个表就是句柄表，这个句柄表就是与进程相关的，而这些东西就是系统中被创建的内存中的内存块。现在相信你对于微软为什么搞出一个句柄有所体会了吧。 句柄的存在，保证了系统的安全，程序员不用通过指针直接操作内存中的东西，将句柄传入API函数，函数在内部会在当前的进程的句柄表中去找这个句柄对应的内存块的地址，以及判断该内存块的访问权限和标志，然后再执行之后的操作。这样一来，如果是非法访问，你对于那块内存面都见不到，更不用说去破坏了。而如果是指针，只要指针指向了那个内存块，你就可以对它任意操作了。 所以说，理解句柄，理解到这个地步，你脑子的很多疑问都会自然的没了，看句柄也会顺眼多了。线程句柄、文件句柄、GDI句柄等等，本质都是一样的。如果你不理解的话，还要以为是好多种数据类型，其实就是一个类型。知道了本质，一切都很自然了。 当然，本文只是大致讨论了一下，要想更加深入的理解，本文是远远不够。但是对于初学者来说，了解到这个，已经很够用了。 类内const static(static const)成员变量初始化问题 参考文章：类内const static(static const)成员变量初始化问题 在查找const相关资料的过程中，又遇到了另外一个问题，就是C++类中const static（或者static const）成员变量应当如何初始化的问题。 查阅了许多资料，发现VC环境下，只允许const static成员变量在类外初始化，这个应该是编译器遗留下的bug（你也可以说是要求严格）。 在其他编译器下，整型以及枚举类型的const static成员变量是允许在声明的同时进行初始的，其中整型包括int、short、long、char等，非整型是指浮点型 包括float、double等。尽管可以在类内进行初始化，但是我在网上看到两种解释： 解释一虽然可以进行初始化，但是这种初始化时不够严格地，倘若对变量取地址 （这里并不是指 &amp;操作符，而是指所有需要用到这个变量的存储空间的操作 比如 ++ 之类，其实这儿我也没看懂到底什么是取地址），就会出现错误，这是因为这种在类内的初始化是不会分配内存的，应当再次在类外进行定义来获取内存分配（无需再赋值）。 12345class people&#123;public: const static int age = 18;&#125;;const int people::age; 解释二之所以整型有这种特权，是为了设计一个更明确（类型）的常量定义语法来取代用enum定义常量的旧方式。因为出发点是这个，所以才仅仅只是对静态整形常量特殊处理，因为enum也只能是整型值。现在的最新标准完全允许在类内进行定义，并且当你用到取地址操作时，它就会分配内存，类似于常量折叠（const folding），所以无需在外再次定义，这是完全没有问题的。 12345class people&#123;public: const static int age = 18;&#125;;//不需要const int people::age; 对于上述解释，作为一个初学者，也没法从绝对的知识点上判断到底哪个是对的，根据我在VS2013中敲代码实际测试来看，解释一、二是代码都是对的，都不会报错，但是我在codeblock中运行时，如果对age进行const int *p=&amp;people::age操作时，一不会报错而二报错，所以我支持解释一的说法。如果有哪位大神有幸看到这篇文章，还望指点一二，感激不尽！ “阻塞（pend）”与“挂起（suspend）”的区别？ 理解一：挂起是一种主动行为，因此恢复也应该要主动完成，而阻塞则是一种被动行为，是在等待事件或资源时任务的表现，你不知道他什么时候被阻塞(pend)，也就不能确切的知道他什么时候恢复阻塞。而且挂起队列在操作系统里可以看成一个，而阻塞队列则是不同的事件或资源（如信号量）就有自己的队列。 理解二：阻塞（pend）就是任务释放CPU，其他任务可以运行，一般在等待某种资源或信号量的时候出现。挂起（suspend）不释放CPU，如果任务优先级高就永远轮不到其他任务运行，一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试。 理解三：pend是task主动去等一个事件,或消息.suspend是直接悬挂task,以后这个task和你没任何关系,任何task间的通信或者同步都和这个suspended task没任何关系了,除非你resume task; 理解四：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。可以这样理解，只要是挂起状态，操作系统就不在管理这个任务了。 理解五：挂起是主动的，一般需要用挂起函数进行操作，若没有resume的动作，则此任务一直不会ready。而阻塞是因为资源被其他任务抢占而处于休眠态。两者的表现方式都是从就绪态里“清掉”，即对应标志位清零，只不过实现方式不一样。 操作系统中睡眠、阻塞、挂起的区别形象解释首先这些术语都是对于线程来说的。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的。挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”。使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。 函数传递的参数是原参数的副本函数的传递的参数是原参数的副本 使用C语言编程，不可能不用到函数，但是函数的参数传递，我们是否真的清楚了呢。本文主要介绍C语言中函数传递的参数。。 函数的参数通常分为两种，普通变量，指针变量。这些参数，将会被函数体调用，当让，也可以传入一些永远不被函数调用的参数，就像你声明了一些变量，却永远不用一样，在语法上是没有问题的。 那么，函数体内调用的传递过来的参数，与原来的参数有什么关系呢？ 函数体内接收到的参数，是原参数的副本。 1. 普通变量在函数中的传递 首先我们来看普通变量，函数体内的参数为该普通变量的拷贝副本。下面是一个例子的源程序： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;include &lt;stdlib.h&gt;int test(int t1, int t2);int main(int argc, char *argv[])&#123; int t1 = 10; int t2 = 0; printf(&quot;[main]t1: %d\tt1:%x\n&quot;, t1, &amp;t1); printf(&quot;[main]t2: %d\tt2:%x\n&quot;, t2, &amp;t2); test(t1, t2); printf(&quot;[main]t1: %d\tt1:%x\n&quot;, t1, &amp;t1); printf(&quot;[main]t2: %d\tt2:%x\n&quot;, t2, &amp;t2); system(&quot;PAUSE&quot;); return 0; nt test(int t1, int t2) printf(&quot;in func....\n&quot;); printf(&quot;[test]t1: %d\tt1:%x\n&quot;, t1, &amp;t1); printf(&quot;[test]t2: %d\tt2:%x\n&quot;, t2, &amp;t2); t2 = t1; printf(&quot;[test]after t2 = t1\n&quot;); printf(&quot;[test]t1: %d\tt1:%x\n&quot;, t1, &amp;t1); printf(&quot;[test]t2: %d\tt2:%x\n&quot;, t2, &amp;t2); printf(&quot;in func over....\n&quot;); return 1;&#125; 执行结果为：1234567891011 [main]t1: 10 t1:22ff7c [main]t2: 0 t2:22ff78 in func.... [test]t1: 10 t1:22ff60 [test]t2: 0 t2:22ff64 [test]after t2 = t1 [test]t1: 10 t1:22ff60 [test]t2: 10 t2:22ff64 in func over.... [main]t1: 10 t1:22ff7c [main]t2: 0 t2:22ff78 （打印的地址值可能与我获得的结果不同。） 可以看到，t1和t2，在被test函数调用前后，其值和地址都未变化。而在test函数中，t1和t2的地址与main函数中并不相同，其只是原来的t1和t2的拷贝副本。对副本作的一切操作，都不会影响到test函数外的原来的参数。 2. 指针变量在函数中的传递 指针作为变量在函数传递中，有些特殊，对于普通变量，函数传递的是对其的一份拷贝的副本，而对于指针，函数传递的是对其存放地址的一份拷贝，该拷贝存放的地址与原来的指针所存的地址一致。 我们来看看例子程序： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int test(char *t1, char *t2);int main(int argc, char *argv[])&#123; char t1[] = &quot;kdsfkasdfkdsf&quot;; char *t2 = NULL; printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[main]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); test(t1, t2); printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[main]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); system(&quot;PAUSE&quot;); return 0; &#125; int test(char *t1, char *t2) &#123; printf(&quot;in func....\n&quot;); printf(&quot;[test]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[test]t2: %s\tt2:%x\t\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); t2 = t1; printf(&quot;[test]after t2 = t1\n&quot;); printf(&quot;[test]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[test]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); printf(&quot;in func over....\n&quot;); return 1;&#125; 输出结果为： 1234567891011[main]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff68[main]t2: (null) t2:0 &amp;t2:22ff64in func....[test]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff40[test]t2: (null) t2:0 &amp;t2:22ff44[test]after t2 = t1[test]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff40[test]t2: kdsfkasdfkdsf t2:22ff68 &amp;t2:22ff44in func over....[main]t1: kdsfkasdfkdsf t1:22ff68 &amp;t1:22ff68[main]t2: (null) t2:0 &amp;t2:22ff64 （打印的地址值可能与我获得的结果不同。） 可以看到，在main函数中，t1、t2所存放的地址，以及该地址对应的字符串的值，与test函数中传递的t1、t2完全一样，但t1、t2的地址却完全不同， l 故指针在函数中传递的是其地址的一份拷贝，可以在函数体内，修改指针存放的地址对应的值，其修改在函数体外对原参数同样有效，因为原参数也指向该地址。 l 指针在函数体内可修改其所存放的地址，但其修改对函数体外原指针参数无效，因为其只是原指针参数的地址副本，原指针依然指向原来的地址。 3. 使用指针的指针在函数体内修改指针所指对象 如果一定要修改指针参数所指的地址，应该怎么作呢？这时，我们需要用到指针的指针了。请看例子程序： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int test(char **t1, char **t2);int main(int argc, char *argv[])&#123; char *t1 = &quot;tttt&quot;; char *t2 = NULL; printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[main]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); test(&amp;t1, &amp;t2); printf(&quot;[main]t1: %s\tt1:%x\t&amp;t1:%x\n&quot;, t1, t1, &amp;t1); printf(&quot;[main]t2: %s\tt2:%x\t&amp;t2:%x\n&quot;, t2, t2, &amp;t2); //printf(&quot;[main]t2: %s\n&quot;, t2); system(&quot;PAUSE&quot;); return 0; &#125; int test(char **t1, char **t2) &#123; printf(&quot;[test]in func....\n&quot;); printf(&quot;[test]*t1: %s\tt1:%x\n&quot;, *t1, t1); printf(&quot;[test]*t2: %s\tt2:%x\n&quot;, *t2, t2); *t2 = *t1; printf(&quot;[test]after *t2 = *t1\n&quot;); printf(&quot;[test]*t1: %s\tt1:%x\n&quot;, *t1, t1); printf(&quot;[test]*t2: %s\tt2:%x\n&quot;, *t2, t2); printf(&quot;[test]in func over....\n&quot;); return 1;&#125; 深入理解指针函数指针函数的定义顾名思义，指针函数即返回指针的函数。其一般定义形式如下： 类型名 *函数名(函数参数表列);其中，后缀运算符括号“()”表示这是一个函数，其前缀运算符星号“*”表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。 “(函数参数表列)”中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下： 1int *pfun(int, int); 由于“*”的优先级低于“()”的优先级，因而pfun首先和后面的“()”结合，也就意味着，pfun是一个函数。即： 1int *(pfun(int, int)); 接着再和前面的“*”结合，说明这个函数的返回值是一个指针。由于前面还有一个int，也就是说，pfun是一个返回值为整型指针的函数。 我们不妨来再看一看，指针函数与函数指针有什么区别？1int (*pfun)(int, int); 通过括号强行将pfun首先与“*”结合，也就意味着，pfun是一个指针，接着与后面的“()”结合，说明该指针指向的是一个函数，然后再与前面的int结合，也就是说，该函数的返回值是int。由此可见，pfun是一个指向返回值为int的函数的指针。虽然它们只有一个括号的差别，但是表示的意义却截然不同。函数指针的本身是一个指针，指针指向的是一个函数。指针函数的本身是一个函数，其函数的返回值是一个指针。 用函数指针作为函数的返回值在上面提到的指针函数里面，有这样一类函数，它们也返回指针型数据（地址），但是这个指针不是指向int、char之类的基本类型，而是指向函数。对于初学者，别说写出这样的函数声明，就是看到这样的写法也是一头雾水。比如,下面的语句：1int (*ff(int))(int *, int); 我们用上面介绍的方法分析一下，ff首先与后面的“()”结合，即：1int (*(ff(int)))(int *, int); // 用括号将ff(int)再括起来 也就意味着，ff是一个函数。 接着与前面的“*”结合，说明ff函数的返回值是一个指针。然后再与后面的“()”结合，也就是说，该指针指向的是一个函数。这种写法确实让人非常难懂，以至于一些初学者产生误解，认为写出别人看不懂的代码才能显示自己水平高。而事实上恰好相反，能否写出通俗易懂的代码是衡量程序员是否优秀的标准。一般来说，用typedef关键字会使该声明更简单易懂。在前面我们已经见过：1int (*PF)(int *, int); 也就是说，PF是一个函数指针“变量”。当使用typedef声明后，则PF就成为了一个函数指针“类型”，即：1typedef int (*PF)(int *, int); 这样就定义了返回值的类型。然后，再用PF作为返回值来声明函数:1PF ff(int); 下面将以程序清单1为例，说明用函数指针作为函数的返回值的用法。当程序接收用户输入时，如果用户输入d，则求数组的最大值，如果输入x，则求数组的最小值，如果输入p，则求数组的平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;assert.h&gt;double GetMin( double *dbData, int iSize ) /* 求最小值 */&#123; double dbMin; int i; assert( iSize &gt; 0 ); dbMin = dbData[0]; for ( i = 1; i &lt; iSize; i++ ) &#123; if ( dbMin &gt; dbData[i] ) &#123; dbMin = dbData[i]; &#125; &#125; return(dbMin);&#125;double GetMax( double *dbData, int iSize ) /* 求最大值 */&#123; double dbMax; int i; assert( iSize &gt; 0 ); dbMax = dbData[0]; for ( i = 1; i &lt; iSize; i++ ) &#123; if ( dbMax &lt; dbData[i] ) &#123; dbMax = dbData[i]; &#125; &#125; return(dbMax);&#125;double GetAverage( double *dbData, int iSize ) /* 求平均值 */&#123; double dbSum = 0; int i; assert( iSize &gt; 0 ); for ( i = 0; i &lt; iSize; i++ ) &#123; dbSum += dbData[i]; &#125; return(dbSum / iSize);&#125;double UnKnown( double *dbData, int iSize ) /* 未知算法 */&#123; return(0);&#125;typedef double (*PF)( double *dbData, int iSize ); /* 定义函数指针类型 */PF GetOperation( char c ) /* 根据字符得到操作类型，返回函数指针 */&#123; switch ( c ) &#123; case &apos;d&apos;: return(GetMax); case &apos;x&apos;: return(GetMin); case &apos;p&apos;: return(GetAverage); default: return(UnKnown); &#125;&#125;int main( void )&#123; double dbData[] = &#123; 3.1415926, 1.4142, -0.5, 999, -313, 365 &#125;; int iSize = sizeof(dbData) / sizeof(dbData[0]); char c; printf( &quot;Please input the Operation :\n&quot; ); c = getchar(); printf( &quot;result is %lf\n&quot;, GetOperation( c ) ( dbData, iSize ) ); /* 通过函数指针调用函数 */&#125; 上述程序中前面4个函数分别实现求最大值、最小值、平均值和未知算法，然后实现了GetOperation函数。这个函数根据字符的返回值实现上面4个函数。它是以函数指针的形式返回的，从后面的main函数的GetOperation(c)(dbData, iSize)可以看出，通过这个指针可以调用函数。 C++容器groupby 参考文章：C++ algorithm like python’s ‘groupby’ The one-liner I have provided is not well-optimized for the case when your vector is already sorted. A number of map lookups can be reduced if we remember the iterator of previously inserted object, so it the “key” of the next object and do a lookup only when the key is changing. For example: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;struct foo &#123; int x; std::string y; float z;&#125;;class optimized_inserter &#123; public: typedef std::map&lt;int, std::vector&lt;foo&gt; &gt; map_type; optimized_inserter(map_type &amp; map) : map(&amp;map), it(map.end()) &#123;&#125; void operator()(const foo &amp; obj) &#123; typedef map_type::value_type value_type; if (it != map-&gt;end() &amp;&amp; last_x == obj.x) &#123; it-&gt;second.push_back(obj); return; &#125; last_x = obj.x; it = map-&gt;insert(value_type(obj.x, std::vector&lt;foo&gt;(&#123; obj &#125;))).first; &#125; private: map_type *map; map_type::iterator it; int last_x;&#125;;int main()&#123; std::vector&lt;foo&gt; foos; std::map&lt;int, std::vector&lt;foo&gt;&gt; foos_by_x; foos.push_back(&#123; 1, &quot;one&quot;, 1.0 &#125;); foos.push_back(&#123; 3, &quot;third&quot;, 2.5 &#125;); foos.push_back(&#123; 1, &quot;one.. but third&quot;, 1.5 &#125;); foos.push_back(&#123; 2, &quot;second&quot;, 1.8 &#125;); foos.push_back(&#123; 1, &quot;one.. but second&quot;, 1.5 &#125;); std::sort(foos.begin(), foos.end(), [](const foo &amp; lhs, const foo &amp; rhs) &#123; return lhs.x &lt; rhs.x; &#125;); std::for_each(foos.begin(), foos.end(), optimized_inserter(foos_by_x)); for (const auto &amp; p : foos_by_x) &#123; std::cout &lt;&lt; &quot;--- &quot; &lt;&lt; p.first &lt;&lt; &quot;---\n&quot;; for (auto &amp; f : p.second) &#123; std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; f.x &lt;&lt; &quot; &apos;&quot; &lt;&lt; f.y &lt;&lt; &quot;&apos; / &quot; &lt;&lt; f.z &lt;&lt; &apos;\n&apos;; &#125; &#125;&#125; 二维数组指针理解一维数组123#define k 100int b[k], *q=0;//用指针要初始化！q = b; //指针q指向数组b的首地址 以后使用数组b的元素，比如b[?]，均可用q[?]代替！（注：?表示某整数索引值) 1q = b+i;//此时指针q不再指向数组首地址，而是指向b[i]元素的地址 若要给b[i]元素更新值，可以： 12b[i] = ?; //或者q[i] = ?; //都是等价的。 而这时的q[i]可以写作：*(q+i)，注意加括号！也就是说，q[i]与*(q+i)等价！代表“值”&amp;q[i]与 q+i 等价！代表“地址” 二维数组1int a[3][5]; 对于这句，你先把[5]挡住，别看：int a[3]什么意思？声明一个数组a，有三个元素，分别是a[0],a[1],a[2]物理位置：口口口a[0],a[1],a[2]再接上[5]：int a[3][5];什么意思？对于数组a的三个元素，每个元素又都有5个元素，分别是：a[0]——a[0][0],a[0][1],a[0][2],a[0][3],a[0][4]a[1]——a[1][0],a[1][1],a[1][2],a[1][3],a[1][4]a[2]——a[2][0],a[2][1],a[2][2],a[2][3],a[2][4]物理位置：口口口口口 口口口口口 口口口口口前五个“口”对应与上一个图的第一个“口”；中间五个对应第二个“口”，最后五个对应第三个“口”。这相当于又把上一个图里的三个“口”每一个都细分了5份！你该看出来：a[0],a[1],a[2]相当于三个一维数组！每个都有5个元素。 二维数组名“a”，标识a[0][0]的地址。注意，它是一个地址常量，不能被更新，比如：a++，a–，a=？……都是错的！但可以用在赋值号“=”的右边。稍后举例 概括的说，指针其实就是可变数组的首地址，说是可变数组，是指其包含内容的数量的可变的，并且是可动态申请和释放的，从而充分节约宝贵的内存资源。我一向喜欢一维数组，除非万不得已，我一般是不用二维数组的，多维的则更是很少涉足了。因为一维简单，容易理解，而用指针指向的多维数组就具有相当的复杂性了，也因此更具有讨论的必要。 闲话少说，这里我就以三个二维数组的比较来展开讨论：123(1)、int **Ptr;(2)、int *Ptr[ 5 ];(3)、int ( *Ptr )[ 5 ]; 以上三例都是整数的二维数组，都可以用形如 Ptr[ 1 ][ 1 ] 的方式访问其内容；但它们的差别却是很大的。下面我从四个方面对它们进行讨论： 一、内容：它们本身都是指针，它们的最终内容都是整数。注意我这里说的是最终内容，而不是中间内容，比如你写 Ptr[ 0 ]，对于三者来说，其内容都是一个整数指针，即 int \*；Ptr[ 1 ][ 1 ] 这样的形式才是其最终内容。 二、意义：(1)、int \*\*Ptr 表示指向&quot;一群&quot;指向整数的指针的指针。 (2)、int \*Ptr[ 5 ] 表示指向 5 个指向整数的指针的指针。 (3)、int ( \*Ptr )[ 5 ] 表示指向&quot;一群&quot;指向 5 个整数数组的指针的指针。 三、所占空间：(1)、int \*\*Ptr 和 (3)、int ( \*Ptr )[ 5 ] 一样，在32位平台里，都是4字节，即一个指针。但 (2)、int \*Ptr[ 5 ] 不同，它是 5 个指针，它占5 * 4 = 20个字节的内存空间。 四、用法：(1)、int **Ptr因为是指针的指针，需要两次内存分配才能使用其最终内容。首先，1Ptr = ( int ** )new int *[ 5 ]； 这样分配好了以后，它和(2)的意义相同了；然后要分别对 5 个指针进行内存分配，例如：1Ptr[ 0 ] = new int[ 20 ]; 它表示为第 0 个指针分配 20 个整数，分配好以后， Ptr[ 0 ] 为指向 20 个整数的数组。这时可以使用下标用法 Ptr[ 0 ][ 0 ] 到Ptr[ 0 ][ 19 ] 了。如果没有第一次内存分配，该 Ptr 是个”野”指针，是不能使用的，如果没有第二次内存分配，则 Ptr[ 0 ] 等也是个”野”指针，也是不能用的。当然，用它指向某个已经定义的地址则是允许的，那是另外的用法（类似于”借鸡生蛋”的做法），这里不作讨论（下同）。 (2)、int *Ptr[ 5 ]这样定义的话，编译器已经为它分配了 5 个指针的空间，这相当于(1)中的第一次内存分配。根据对(1)的讨论可知，显然要对其进行一次内存分配的。否则就是”野”指针。 (3)、int ( *Ptr )[ 5 ]这种定义我觉得很费解，不是不懂，而是觉得理解起来特别吃力，也许是我不太习惯这样的定义吧。怎么描述它呢？它的意义是”一群”指针，每个指针都是指向一个 5 个整数的数组。如果想分配 k 个指针，这样写： Ptr = ( int ( )[ 5 ] ) new int[ sizeof( int ) 5 * k ]。这是一次性的内存分配。分配好以后，Ptr 指向一片连续的地址空间，其中 Ptr[ 0 ] 指向第 0 个 5 个整数数组的首地址，Ptr[ 1 ] 指向第1 个 5 个整数数组的首地址。 综上所述，我觉得可以这样理解它们：123int ** Ptr &lt;==&gt; int Ptr[ x ][ y ];int *Ptr[ 5 ] &lt;==&gt; int Ptr[ 5 ][ x ];int ( *Ptr )[ 5 ] &lt;==&gt; int Ptr[ x ][ 5 ]; 这里 x 和 y 是表示若干的意思。 使用“指向指针的指针”来构造一个二维数组12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#define ROW 3#define COLUMN 5int main(void) &#123; int **pp=0, i,j;pp = (int **)malloc(sizeof(int)*ROW);for (i=0; i&lt;ROW; i++)pp[i] = (int *)malloc(sizeof(int)*COLUMN);for (i=0; i&lt;ROW; i++)for (j=0; j&lt;COLUMN; j++)pp[i][j] = rand()%2;for (i=0; i&lt;ROW; i++)for (j=0; j&lt;COLUMN; j++)printf(&quot;pp[%d][%d]= %d\n&quot;, i,j,pp[i][j]);return 0; &#125; 通式&amp;a+n所得的新地址实际是按&amp;a+n*sizeof(a)来计算的&amp;a[i]+n所得的新地址实际是按&amp;a[i]+sizeof(a[i])来计算的&amp;a[i][j]+n所得的新地址实际是岸&amp;a[i][j]+sizeof(a[i][j])来计算的 有了它几乎不会在被这样的问题难住了a[N][M]首先要区分&amp;a,a,a[0]，&amp;a[0],&amp;a[0][0]的区别，才能更好的理解公式，他们的值相同，但意义相差很大&amp;a是二维数组的首地址，类型为int（*)[N][M]a和&amp;a[0]是数组元素a[0](二维数组本来就是数组的数组，既可以看作是一个一位数组，只不过它的元素是数组）的首地址，类型为int（*）[M]a[0]和&amp;a[0][0]是一维数组a[0]中第一个元素a[0][0]的首地址，类型为int（*） 也就是说a=&amp;a[0],a[N]=&amp;a[N][0]先把a,a[N]转化为标准的元素取地址（既&amp; ）这种表示，方便看清，以及与元素建立联系也就是说一个首地址加了n,这个n是会根据这个首地址的类型而与此类型同化 9.C++中const、volatile、mutable的用法 文章：C++中const、volatile、mutable的用法 const修饰普通变量和指针const修饰变量，一般有两种写法： 12const TYPE value;TYPE const value; 这两种写法在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value值不可变。 例如： 12const int nValue； //nValue是constint const nValue； //nValue是const 但是对于指针类型的TYPE，不同的写法会有不同情况：指针本身是常量不可变 1(char*) const pContent; 指针所指向的内容是常量不可变 12const (char) *pContent;(char) const *pContent; 两者都不可变 1const char* const pContent; 识别const到底是修饰指针还是指针所指的对象，还有一个较为简便的方法，也就是沿着号划一条线：如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 const修饰函数参数const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)： void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用) void function(const char* Var); //参数指针所指内容为常量不可变 void function(char* const Var); //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的) void function(const Class&amp; Var); //引用参数在函数内不可以改变，同第二点 参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。 const修饰类对象/对象指针/对象引用const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。例如： 123456789101112class AAA&#123; void func1(); void func2() const;&#125;const AAA aObj;aObj.func1(); 错误aObj.func2(); 正确const AAA* aObj = new AAA();aObj-&gt;func1(); 错误aObj-&gt;func2(); 正确 const修饰数据成员const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么，例如： 12345class A&#123; const int size = 100; //错误 int array[size]; //错误，未知的size&#125; const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，可以用类中的枚举常量来实现，例如： 12345678class A&#123;… enum &#123;size1=100, size2 = 200 &#125;; int array1[size1]; int array2[size2];…&#125; 枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。 const修饰成员函数const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。一般把const写在成员函数的最后： 12345class A&#123; … void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。&#125; const修饰成员函数的返回值１.一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回const对象，或返回const对象的引用，则返回值具有const属性，返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。 2.如果给采用“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针所指的内容）不能被修改，该返回值只能被赋给加const 修饰的同类型指针： 1const char * GetString(void); 如下语句将出现编译错误： 1char *str=GetString(); 正确的用法是： 1const char *str=GetString(); 3.函数返回值采用“引用传递”的场合不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。如： 12345678class A&#123;… A &amp;operate= (const A &amp;other); //赋值函数&#125;A a,b,c; //a,b,c为A的对象…a=b=c; //正常(a=B)=c; //不正常，但是合法 若赋值函数的返回值加const修饰，那么该返回值的内容不允许修改，上例中a=b=c依然正确。(a=b)=c就不正确了。const常量与define宏定义的区别编译器处理方式不同define宏是在预处理阶段展开。const常量是编译运行阶段使用。类型和安全检查不同define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。存储方式不同define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)。 volatile关键字volatile的本意是“易变的”,volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被寄存。例如： 1234volatile int i=10;int a = i;。。。//其他代码，并未明确告诉编译器，对i进行过操作int b = i; volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。注意，在vc6中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无volatile关键字，对程序最终代码的影响。首先用classwizard建一个win32 console工程，插入一个voltest.cpp文件，输入下面的代码： 12345678910111213#include &lt;stdio.h&gt;void main()&#123;int i=10;int a = i;printf(&quot;i= %d/n&quot;,a);//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道__asm &#123; mov dword ptr [ebp-4], 20h&#125;int b = i;printf(&quot;i= %d/n&quot;,b);&#125; 然后，在调试版本模式运行程序，输出结果如下：i = 10i = 32然后，在release版本模式运行程序，输出结果如下：i = 10i = 10输出的结果明显表明，release模式下，编译器对代码进行了优化，第二次没有输出正确的i值。下面，我们把 i的声明加上volatile关键字，看看有什么变化： 123456789101112#include &lt;stdio.h&gt;void main()&#123;volatile int i=10;int a = i;printf(&quot;i= %d/n&quot;,a);__asm &#123; mov dword ptr [ebp-4], 20h&#125;int b = i;printf(&quot;i= %d/n&quot;,b);&#125; 分别在调试版本和release版本运行程序，输出都是：i = 10i = 32这说明这个关键字发挥了它的作用！关于volatile的补充信息：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile的重要性： 一个参数既可以是const还可以是volatile吗？解释为什么。 一个指针可以是volatile 吗？解释为什么。 下面的函数有什么错误： 1234int square(volatile int *ptr)&#123; return *ptr * *ptr;&#125; 下面是答案： 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 一个值可以同时是vonst和volatile。例如，硬件时钟一般设定为不能由程序改变，这一点使他成为const； 但它被程序以外的代理改变，这使它成为volatile的 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。 这段代码的有个恶作剧。这段代码的目的是用来返指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码： 1234567int square(volatile int *ptr)&#123; int a,b; a = *ptr; b = *ptr; return a * b;&#125; 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： 123456long square(volatile int *ptr)&#123; int a; a = *ptr; return a * a;&#125; mutable关键字mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。 我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。下面是一个小例子： 123456789101112131415class ClxTest&#123; public: void Output() const;&#125;;void ClxTest::Output() const&#123; cout &lt;&lt; &quot;Output for test!&quot; &lt;&lt; endl;&#125;void OutputTest(const ClxTest&amp; lx)&#123; lx.Output();&#125; 类ClxTest的成员函数Output是用来输出的，不会修改类的状态，所以被声明为const。 函数OutputTest也是用来输出的，里面调用了对象lx的Output输出方法，为了防止在函数中调用成员函数修改任何成员变量，所以参数也被const修饰。 假如现在，我们要增添一个功能：计算每个对象的输出次数。假如用来计数的变量是普通的变量的话，那么在const成员函数Output里面是不能修改该变量的值的；而该变量跟对象的状态无关，所以应该为了修改该变量而去掉Output的const属性。这个时候，就该我们的mutable出场了，只要用mutalbe来修饰这个变量，所有问题就迎刃而解了。下面是修改过的代码： 12345678910111213141516171819202122232425ClxTest::ClxTest()&#123; m_iTimes = 0;&#125;ClxTest::~ClxTest()&#123;&#125;void ClxTest::Output() const&#123; cout &lt;&lt; &quot;Output for test!&quot; &lt;&lt; endl; m_iTimes++;&#125;int ClxTest::GetOutputTimes() const&#123; return m_iTimes;&#125;void OutputTest(const ClxTest&amp; lx)&#123; cout &lt;&lt; lx.GetOutputTimes() &lt;&lt; endl; lx.Output(); cout &lt;&lt; lx.GetOutputTimes() &lt;&lt; endl;&#125; 计数器m_iTimes被mutable修饰，那么它就可以突破const的限制，在被const修饰的函数里面也能被修改。 关于Windows动态链接库基础知识 文章：关于Windows动态链接库基础知识 如我们所知，Windows程序都是一些可执行文件，它们可以创建并显示一个或多个窗体，使用消息循环来接收用户的输入。但是动态链接库并不能直接被执行，它们一般也不会接收消息。它们只是一些包含着函数的独立文件，这些函数可以被Windows程序或者其它DLL调用以完成某项任务。 “动态链接”是指Windows程序在运行时才把自己需要存在于某个库中的函数链接进来。“静态链接”是指Windows程序在编译阶段就把各种对象模块（.OBJ）、运行时库（.LIB）和资源文件（.RES）链接到一起以创建一个可执行文件（.EXE）。 DERNAL32.DLL，USER32.DLL，GDI32.DLL，各种驱动程序如KEYBOARD.DRV，SYSTEM.DRV和MOUSE.DRV，显卡和打印机驱动程序等都是动态链接库。这些库可以被所有的Windows程序共同使用。有某些动态链接库（如字体文件）称为“resource-only”。它们只包括数据，而不包括代码。因此，动态链接库的目的之一就是为许多不同的程序提供函数和资源。在传统的操作系统里，用户程序在运行时只能调用操作系统自身的某些函数。而在Windows操作系统下，模块或程序调用另一个模块中的函数来执行是一种非常普遍的操作。因此，从某种角度看，对DLL进行编程，其实是在对Windows操作系统作扩展，也可以看作是在对用户程序作扩展。 动态链接库模块可以有其它的扩展名，但是标准的扩展名是.DLL。只有具有标准扩展句的动态链接库模块才可以被Windows自动加载。而如果是其它扩展名的动态链接库模块，程序必须使用LoadLibrary或者LoadLibraryEx函数来显示加载。 我们可以发现，在大型的应用软件中，会常常使用到动态链接库技术。举个例子，假如我们要写一个大型的应用软件，其中包括了多个程序。我们可以发现很多程序可能都会使用到一些同样的通用的函数。我们可以把这些通用的函数放到某个目标库文件中（.LIB），然后在链接是把它加到每个程序中进行静态链接。但是这是一种非常浪费的方法，因为每个程序模块中都会包括这些通用函数的独立拷贝。另外，如果我们要改变库文件中的某个函数，就必须把所有使用到这个函数的程序都重新编译一遍。但是，如果我们使用动态链接库的技术，把所有这些通用函数都放到一个动态链接库文件当中，我们就可以解决以上提到的各种问题。首先，动态链接库在硬盘上只保留一个拷贝，程序只是在运行时才会调用其中使用到的函数，这样我们就可以节省大量的程序存储和运行空间。其次，如果要修改某个通用函数时，只要调用接口没有改变，只是改变它的实现方法，那么我们就不必对每个用到它的程序都进行重新编译，而只要把动态链接库模块重新编译一遍就可以了。 动态链接库模块也可以作为一个单独的产品来发布。这样程序开发人员就可以使用第三方的模块来开发自己的应用程序，提高了程序的复用程序，也节省了大量的时间和精力。 在很多时候时候，我们都会用到“库”（Library）这个词，除了动态链接库（Dynamic-Link Libraries）之外，还有目标库（Object Libraries）和导入库（Import Libraries）。下面，我们分别了解一下这三种库的异同点。 目标库是扩展名为.LIB的文件，包括了用户程序要用到的各种函数。它在用户程序进行链接时，“静态链接”到可执行程序文件当中。例如，在VC++中最常使用到的C运行时目标库文件就是LIBC.LIB。 导入库是一种特殊形式的目标库文件形式。和目标库文件一样，导入库文件的扩展名也是.LIB，也是在用户程序被链接时，被“静态链接”到可执行文件当中。但是不同的是，导入库文件中并不包含有程序代码。相应的，它包含了相关的链接信息，帮助应用程序在可执行文件中建立起正确的对应于动态链接库的重定向表。比如KERNEL32.LIB、USER32.LIB和GDI32.LIB就是我们常用到的导入库，通过它们，我们就可以调用Windows提供的函数了。如果我们在程序中使用到了Rectangle这个函数，GDI32.LIB就可以告诉链接器，这个函数在GDI32.DLL动态链接库文件中。这样，当用户程序运行时，它就知道“动态链接”到GDI32.DLL模块中以使用这个函数。 目标库和导入库都是在程序开发过程中才使用到的，而动态链接库是在程序运行时才使用的。在程序运行时，相应的动态链接库文件必须已经保存在硬盘上了。另外，如果要使用动态链接库文件，该文件必须要保存在同.EXE文件同一个目录下，或者保存在当前目录、Windows系统目录、Windows目录或环境变量中PATH参数指定的目录下。程序也是按照这个顺序来搜寻它需要的动态链接库文件的。 va_start、va_arg、va_end在参数可变函数中的使用 文章：va_start、va_arg、va_end在参数可变函数中的使用 当无法列出传递函数的所有实参的类型和数目时，可用省略号指定参数表，在函数体中声明一个va_list，然后用va_start函数来获取参数列表中的参数，使用完毕后调用va_end()结束。 C语言可变参数函数及三个宏va_start、va_arg和va_end的使用一、可变参数函数的实例 大家熟知的printf()函数声明如下： 1int printf(const char * format, …); 它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的,例如我们可以有以下不同的调用方法: 123printf(&quot;%d&quot;,i);printf(&quot;%s&quot;,s);printf(&quot;the number is %d ,string is:%s&quot;, i, s); 二、如何编写一个自已的可变参数函数 查了一下，在&lt;stdarg.h&gt;中定义了三个宏va_start()、va_arg()和va_end()用于实现可变参数。 123void va_start( va_list arg_ptr, prev_param );type va_arg( va_list arg_ptr, type );void va_end( va_list arg_ptr ); 试编一个示例: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; #define ENDING_INT 0 int SumAll(int number1,…) //把参数加总 &#123; va_list arg_pointer; //首先定义一个va_list型的变量,这个变量是指向参数的指针. int current_number; //当前的数字 int total; //数字之和 //用va_start初始化变量arg_pointer,这个宏的第二个参数是第一个可变参数(一个固定的参数) va_start(arg_pointer,number1); total=number1; do &#123; //用va_arg返回后续的可变参数, 类型是 int current_number=va_arg(arg_pointer,int); total += current_number; &#125; while (current_number!=ENDING_INT); //如果参数是结束标识(这里是ENDING_INT)，则结束 va_end(arg_pointer); //结束参数列表 return total; &#125; int main(int argc, char* argv[]) &#123; int n; n=SumAll(100,200,ENDING_INT); //返回结果是300 printf(&quot;%d /n&quot;,n); n=SumAll(100,200); //由于没有结束标识，返回结果不确定 printf(&quot;%d /n&quot;,n); &#125; 因为va_start, va_arg, va_end等定义成宏,所以可变参数的类型和个数需要由程序代码控制。一般来说，设一个结束标识，这里是 ENDING_INT。用它来识别不同参数的个数。 SumAll(100,200,ENDING_INT); //调用方式正确，返回结果是300 SumAll(100,200); //调用方式不正确，由于没有结束标识，返回结果不确定。 三、理解va_start、va_arg和va_end 看一下&lt;stdarg.h&gt;中宏的定义： 定义：typedef char * va_list;理解：va_list 就是一个指针，指向参数列表。 定义：#define _INTSIZEOF(n) ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) – 1) )定义：#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )理解：va_start 宏, 就是把ap赋值为参数v起始的参数列表的下一个参数 定义：#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )理解：va_arg宏，就是把ap赋值为下一个参数 定义：#define va_end(ap) ( ap = (va_list)0 )理解：va_end宏，就是把ap赋值为空(0) 从va_的实现可以看出，充分运用指针，把C语言的灵活特性表现得淋漓尽致。当然，用不好也容易出错。va_中，为了得到所有传递给函数的参数，需要用va_arg依次遍历。但是有两个要求: (1)要确定参数的类型。 一般来说，各个参数的类型是一样的。 (2)要有结束标志。如果没有结束标志，va将按默认类型依次返回内存中的内容，直到访问到非法内存而出错退出。 所以上述的调用 SumAll(100,200); 返回的结果是不确定的。 四、再写一个参数类型是 char * 的 可变参数函数. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;alloc.h&gt; #include &lt;stdarg.h&gt; #define ENDING_STRING NULL //把多个字符串连接起来 char *StrCat(char *src,…) &#123; va_list va; const char *src_pointer; char *dest; /* 结果字符串 */ size_t dest_size; /* 结果字符串的大小*/ /* 计算字符串的大小 */ va_start (va, src); /* 开始变长参数处理 */ src_pointer = src; dest_size = 1; while (src_pointer!=ENDING_STRING) /* ENDING_STRING == NULL */ &#123; dest_size += strlen (src_pointer); src_pointer = va_arg (va, char *); /* 取下一个参数 */ &#125; va_end (va); /* 结束变长参数处理 */ /* 申请内存 */ dest = malloc( dest_size ); if (dest == NULL) return (NULL); /* 逐个复制字串到结果字符串 */ va_start (va, src); /* 开始变长参数处理 */ src_pointer = src; dest [0] = &apos;/0&apos;; /* 先设置为空串 */ while (src_pointer!=ENDING_STRING) /* ENDING_STRING == NULL */ &#123; strcat (dest, src_pointer); /* 复制字串到结果字符串 */ src_pointer = va_arg (va, char *); &#125; va_end (va); /* 结束变长参数处理 */ return (dest); &#125; int main(int argc, char* argv[]) &#123; int n; char *s; s=StrCat(&quot;hello&quot;,&quot; &quot;,&quot;world&quot;,NULL); printf(&quot;%s /n&quot;,s); //返回结果是 hello world &#125; 嗯，还是比较好用的，千万不要忘记: 调用时要加上结束标识符哦。 可能要问，为什么 printf() 函数调用时没有结束标识符呢？ 了解了一下 printf()的源码，我是这样理解的： printf(char *format,…) 中，在format参数中，就可以判断出后续参数的个数和类型，因此不需要结束标识符就可以知道参数的个数了。比如： printf( “%s %d”, “hello”, 1); “%s %d”表明后续参数个数为2个，第一个是 string类型，第二个是 int 类型。 试一下，如果写成这样 printf( “%s %d %d”, “hello”, 1); “%s %d %d”表明后续参数个数为3个，实际上是两个，由于缺了一个，返回结果是不可确定的 C/C++ 函数参数 省略号（变参技术，va_start,va_arg,va_end用法） 先看如下的一个函数： 12345678910111213141516171819#include &lt;stdarg.h&gt; // 必须包含的头文件 int Add(int start,…) // …是作为占位符 &#123; va_list arg_ptr; // 定义变参起始指针 int sum=0; // 定义变参的和 int nArgValue =start; // va_start(arg_ptr,start); // arg_ptr指向第一个变参 do &#123; sum+=nArgValue; // 求和 nArgValue = va_arg(arg_ptr,int); // arg_ptr指向下一个变参 &#125; while(nArgValue != 0); // 判断结束条件；结束条件是自定义为=0时结束 va_end(arg_ptr); // 复位指针 return sum; &#125; 函数的调用方法为Add(1,2,3,0);这样，必须以0结尾，因为变参函数结束的判断条件就是读到0停止。 解释： 所使用到的宏： void va_start( va_list arg_ptr, prev_param );type va_arg( va_list arg_ptr, type );void va_end( va_list arg_ptr ); typedef char va_list;#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) – 1) &amp; ~(sizeof(int) – 1) )#define va_start(ap,v) ( ap = (va_list)&amp;v + _INTSIZEOF(v) )#define va_arg(ap,t) ( \(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )#define va_end(ap) ( ap = (va_list)0 ) 1、首先把va_list被定义成char，这是因为在我们目前所用的PC机上，字符指针类型可以用来存储内存单元地址。而在有的机器上va_list是被定义成void的 2、定义_INTSIZEOF(n)主要是为了某些需要内存的对齐的系统.这个宏的目的是为了得到最后一个固定参数的实际内存大小。在我的机器上直接用sizeof运算符来代替，对程序的运行结构也没有影响。（后文将看到我自己的实现）。 3、va_start的定义为 &amp;v+_INTSIZEOF(v) ,这里&amp;v是最后一个固定参数的起始地址，再加上其实际占用大小后，就得到了第一个可变参数的起始内存地址。所以我们运行va_start(ap, v)以后,ap指向第一个可变参数在的内存地址,有了这个地址，以后的事情就简单了。 这里要知道两个事情： ⑴在intel+windows的机器上，函数栈的方向是向下的，栈顶指针的内存地址低于栈底指针，所以先进栈的数据是存放在内存的高地址处。 (2)在VC等绝大多数C编译器中，默认情况下，参数进栈的顺序是由右向左的，因此，参数进栈以后的内存模型如下图所示：最后一个固定参数的地址位于第一个可变参数之下，并且是连续存储的。 |————————–|| 最后一个可变参数 | -&gt;高内存地址处|————————–||————————–|| 第N个可变参数 | -&gt;va_arg(arg_ptr,int)后arg_ptr所指的地方,| | 即第N个可变参数的地址。|————— ||————————–|| 第一个可变参数 | -&gt;va_start(arg_ptr,start)后arg_ptr所指的地方| | 即第一个可变参数的地址|————— ||———————— –|| || 最后一个固定参数 | -&gt; start的起始地址|————– -| ……………..|————————– || ||————— | -&gt; 低内存地址处 (3) va_arg():有了va_start的良好基础，我们取得了第一个可变参数的地址，在va_arg()里的任务就是根据指定的参数类型取得本参数的值，并且把指针调到下一个参数的起始地址。因此，现在再来看va_arg()的实现就应该心中有数了：#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) – _INTSIZEOF(t)) )这个宏做了两个事情，①用用户输入的类型名对参数地址进行强制类型转换，得到用户所需要的值②计算出本参数的实际大小，将指针调到本参数的结尾，也就是下一个参数的首地址，以便后续处理。 (4)va_end宏的解释：x86平台定义为ap=(char)0;使ap不再 指向堆栈,而是跟NULL一样.有些直接定义为((void)0),这样编译器不会为va_end产生代码,例如gcc在linux的x86平台就是这样定义的. 在这里大家要注意一个问题:由于参数的地址用于va_start宏,所以参数不能声明为寄存器变量或作为函数或数组类型. 关于va_start, va_arg, va_end的描述就是这些了,我们要注意的 是不同的操作系统和硬件平台的定义有些不同,但原理却是相似的. 全局变量的理解 使用全局变量会占用更多的内存（因为其生命期长），不过在计算机配置很高的今天，这个不成为什么问题，除非使用的是巨大对象的全局变量，能避免就一定要避免。 使用全局变量程序运行时速度更快一些（因为内存不需要再分配），同样现在也快不了多少。 对于局部变量的名字空间污染，这个在不使用太多变量时是可以避免的。 总之，全局变量可以使用，但是全局变量使用时应注意的是尽可能使期名字易于理解，而且不能太短，避免名字空间的污染；避免使用巨大对象的全局变量。局部变量：在程序中，只在特定的过程或函数中可以访问的变量，是相对与全局变量而言的。全局变量也称为外部变量，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。全局变量全部存放在静态存储区，在程序开始执行时给全局变量分配存储区，程序行完毕就释放。局部变量可以和全局变量重名，但是局部变量会屏蔽全局变量。在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。 #pragma once与 #ifndef的区别 文章：#pragma once与 #ifndef的区别 为了避免同一个文件被include多次 #ifndef方式 #pragma once方式 在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。方式一： 1234#ifndef __SOMEFILE_H__#define __SOMEFILE_H__... ... // 一些声明语句#endif 方式二： 12#pragma once... ... // 一些声明语句 #ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况 #pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。 方式一由语言支持所以移植性好，方式二 可以避免名字冲突 C++中参数传递方式讨论 文章：C++中参数传递方式讨论 众所周知，在C＋＋中调用函数时有三种参数传递方式：（1）传值调用；（2）传址调用（传指针）；（3）引用传递； 实际上，还有一种参数传递方式，就是全局变量传递方式。这里的“全局”变量并不见得就是真正的全局的，所有代码都可以直接访问的，只要这个变量的作用域足够这两个函数访问就可以了，比如一个类中的两个成员函数可以使用一个成员变量实现参数传递，或者使用static关键字定义，或者使用namespace进行限制等，而这里的成员变量在这种意义上就可以称作是“全局”变量（暂时还没有其它比“全局”更好的词来描述）。当然，可以使用一个类外的真正的全局变量来实现参数传递，但有时并没有必要，从工程上讲，作用域越小越好。这种方式有什么优点呢？效率高！ 的确，这种效率是所有参数传递方式中效率最高的，比前面三种方式都要高，无论在什么情况下。但这种方式有一个致命的弱点，那就是对多线程的支持不好，如果两个进程同时调用同一个函数，而通过全局变量进行传递参数，该函数就不能够总是得到想要的结果。下面再分别讨论上面三种函数传递方式。 1.从功能上。按值传递在传递的时候，实参被复制了一份，然后在函数体内使用，函数体内修改参数变量时修改的是实参的一份拷贝，而实参本身是没有改变的，所以如果想在调用的函数中修改实参的值，使用值传递是不能达到目的的，这时只能使用引用或指针传递。例如，要实现两个数值交换。12345void swap(int a, int b);void main()&#123; int a=1, b=2; swap(a,b);&#125; 这样，在main()函数中的a,b值实际上并没有交换，如果想要交换只能使用指针传递或引用传递，如： 1void swap(int* pa, int* pb); 或 1void swap(int&amp; ra, int&amp; rb); 2.从传递效率上。这里所说传递效率，是说调用被调函数的代码将实参传递到被调函数体内的过程，正如上面代码中，这个过程就是函数main()中的a,b传递到函数swap()中的过程。这个效率不能一概而论。对于内建的int, char, short,long,float等4字节或以下的数据类型而言，实际上传递时也只需要传递1－4个字节，而使用指针传递时在32位CPU中传递的是32位的指针，4个字节，都是一条指令，这种情况下值传递和指针传递的效率是一样的，而传递double, long long等8字节的数据时，在32位CPU中，其传值效率比传递指针要慢，因为8个字节需要2次取完。而在64位的CPU上，传值和传址的效率是一样的。再说引用传递，这个要看编译器具体实现，引用传递最显然的实现方式是使用指针，这种情况下与指针的效率是一样的，而有些情况下编译器是可以优化的，采用直接寻址的方式，这种情况下，效率比传值调用和传址调用都要快，与上面说的采用全局变量方式传递的效率相当。再说自定义的数据类型，class, struct定义的数据类型。这些数据类型在进行传值调用时生成临时对象会执行构造函数，而且当临时对象销毁时会执行析构函数，如果构造函数和析构函数执行的任务比较多，或者传递的对象尺寸比较大，那么传值调用的消耗就比较大。这种情况下，采用传址调用和采用传引用调用的效率大多数下相当，正如上面所说，某些情况下引用传递可能被优化，总体效率稍高于传址调用。 3.从执行效率上讲。这里所说的执行效率，是指在被调用的函数体内执行时的效率。因为传值调用时，当值被传到函数体内，临时对象生成以后，所有的执行任务都是通过直接寻址的方式执行的，而指针和大多数情况下的引用则是以间接寻址的方式执行的，所以实际的执行效率会比传值调用要低。如果函数体内对参数传过来的变量进行操作比较频繁，执行总次数又多的情况下，传址调用和大多数情况下的引用参数传递会造成比较明显的执行效率损失。综合2、3两种情况，具体的执行效率要结合实际情况，通过比较传递过程的资源消耗和执行函数体消耗之和来选择哪种情况比较合适。而就引用传递和指针传递的效率上比，引用传递的效率始终不低于指针传递，所以从这种意义上讲，在C＋＋中进行参数传递时优先使用引用传递而不是指针。 4.从类型安全上讲。值传递与引用传递在参数传递过程中都执行强类型检查，而指针传递的类型检查较弱，特别地，如果参数被声明为 void* ，那么它基本上没有类型检查，只要是指针，编译器就认为是合法的，所以这给BUG的产生制造了机会，使程序的健壮性稍差，如果没有必要，就使用值传递和引用传递，最好不用指针传递，更好地利用编译器的类型检查，使得我们有更少的出错机会，以增加代码的健壮性。这里有个特殊情况，就是对于多态的情况，如果形参是父类，而实参是子类，在进行值传递的时候，临时对象构造时只会构造父类的部分，是一个纯粹的父类对象，而不会构造子类的任何特有的部分，因为办有虚的析构函数，而没有虚的构造函数，这一点是要注意的。如果想在被调函数中通过调用虚函数获得一些子类特有的行为，这是不能实现的。 5.从参数检查上讲。一个健壮的函数，总会对传递来的参数进行参数检查，保证输入数据的合法性，以防止对数据的破坏并且更好地控制程序按期望的方向运行，在这种情况下使用值传递比使用指针传递要安全得多，因为你不可能传一个不存在的值给值参数或引用参数，而使用指针就可能，很可能传来的是一个非法的地址（没有初始化，指向已经delete掉的对象的指针等）。所以使用值传递和引用传递会使你的代码更健壮，具体是使用引用还是使用，最简单的一个原则就是看传递的是不是内建的数据类型，对内建的数据类型优先使用值传递，而对于自定义的数据类型，特别是传递较大的对象，那么请使用引用传递。 6.从灵活性上。无疑，指针是最灵活的，因为指针除了可以像值传递和引用传递那样传递一个特定类型的对象外，还可以传递空指针，不传递任何对象。指针的这种优点使它大有用武之地，比如标准库里的time( )函数，你可以传递一个指针给它，把时间值填到指定的地址，你也可以传递一个空指针而只要返回值。综合以上几种传递方式，列表如下，方便不同情况下选择合适的传递方式。我们将各种指标分高、中、低三个级，别处于同一级别的两种方式，表示这两种方式是等效的。 传递方式 功能 传递效率(内嵌/自定义) 执行效率 类型安全 参数检查 灵活性 多线程 全局变量 高 高 / 高 高 高 高 低 低 值 低 高 / 低 高 中 高 中 高 指针 高 低 / 中 低 低 低 高 中 引用 高 中 / 高 中 高 高 中 中 以上讨论了四种参数传递方式的优缺点，下面再讨论一下在参数传递过程中一些共同的有用的技术。1.const关键字。当你的参数是作为输入参数时，你总不希望你的输入参数被修改，否则有可能产生逻辑错误，这时可以在声明函数时在参数前加上const关键字，防止在实现时意外修改函数输入，对于使用你的代码的程序员也可以告诉他们这个参数是输入，而不加const关键字的参数也可能是输出。例如strlen，你可以这样声明 1int strlen(char* str); 功能上肯定没有什么问题，但是你想告诉使用该函数的人，参数str是一个输入参数，它指向的数据是不能被修改的，这也是他们期望的，总不会有人希望在请人给他数钱的时候，里面有张100的变成10块的了，或者真钞变成假钞了，他们希望有一个保证，说该函数不会破坏你的任何数据，声明按如下方式便可让他们放心： 1int strlen(const char* str); 可不可以给str本身也加一个限制呢，如果把地址改了数得的结果不就错了吗？总得给人点儿自由吧，只要它帮你数钱就行了，何必介意他怎么数呢？只要不破坏你的钱就OK了，如果给str一个限制，就会出现问题了，按照上面的声明，可以这样实现： 12345678910int strlen(const char* str)&#123; int cnt; if (!str) return 0; cnt = 0; while (*(str++)) &#123; ++cnt; &#125; return cnt;&#125; 可是，如果你硬要把声明改成 1int strlen(const char* const str); 上面的函数肯定就运行不了了，只能改用其它的实现方式，但这个不是太有必要。只要我们保护好我们的钱就行了，如果它数不对，下次我次不让它数，再换个人就是了。对于成员函数，如果我们要显示给客户代码说某个成员函数不会修改该对象的值，只会读取某些内容，也可以在该函数声明中加一个const. 1234567clas Person&#123; public: unsigned char Age( void ) const; // 看到const就放心了，这个函数肯定不会修改m_age private: unsigned char m_age; // 我认为这个类型已经足够长了，如果觉得不改可以改为unsigned long&#125; 2.默认值。个人认为给参数添加一个默认值是一个很方便的特性，非常好用，这样你就可以定义一个具有好几个参数的函数，然后给那些不常用的参数一些默认值，客户代码如果认为那些默认值正是他们想要的，调用函数时只需要填一些必要的实参就行了，非常方便，这样就省去了重载好几个函数的麻烦。可是我不明白c#为什么把这个特性给去掉了，可能是为了安全，这样就要求每次调用函数时都要显示地给函数赋实参。所以要注意，这可是个双刃剑，如果想用使刀的招跟对手武斗，很可能伤到自己。 3.参数顺序。当同个函数名有不同参数时，如果有相同的参数尽量要把参数放在同一位置上，以方便客户端代码。 C/C++中各种类型int、long、double、char表示范围（最大最小值） 文章：C/C++ 计算时间差的五种方法 / Qt 计算时间差的两种方法 Qt计算时间的两种方法： QTime elapsed() : ms QTime currentTime() : ms C++计算时间的五种方法： clock() : ms GetTickCount() : ms gettimeofday(time_val*, NULL) : us QueryPerformanceFrequency(LARGE_INTEGER) &amp; QueryPerformanceCounter(LARGE_INTEGER) : us time(NULL) : s 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;QThread&gt;#include &lt;QTime&gt;#include &lt;sys/time.h&gt; //clock, gettimeofday, time#include &lt;windows.h&gt; //Sleep, GetTickCount, timeGetTime, QueryPerformanceCounter#include &lt;QDebug&gt;//#pragma comment(lib, &quot;winmm.lib&quot;) //timeGetTime, 但是这个库Windows或Qt或VS2015都没有自带const unsigned long SLEEP_TIME_MILL = 1000;/** * QTime的精度为ms级 */void calcByQtimeElapsed() &#123; QTime time; time.start(); QThread::msleep(SLEEP_TIME_MILL); int timeElapsed = time.elapsed(); qDebug()&lt;&lt;&quot;QTime.start &amp; QTime.elspsed =&quot;&lt;&lt;timeElapsed&lt;&lt;&quot;ms&quot;;&#125;/** * QTime的精度为ms级 */void calcByQtimeCurrentTime() &#123; QTime startTime = QTime::currentTime(); QThread::msleep(SLEEP_TIME_MILL); QTime stopTime = QTime::currentTime(); int elapsed = startTime.msecsTo(stopTime); qDebug()&lt;&lt;&quot;QTime.currentTime =&quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;&#125;/** * clock的精度为ms级 */void calcByClock() &#123; clock_t startTime = clock(); Sleep(SLEEP_TIME_MILL); clock_t endTime = clock(); clock_t elapsed = endTime - startTime; qDebug()&lt;&lt;&quot;clock =&quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;&#125;/** * GetTickCount的精度为ms级 */void calcByTickCount() &#123; //返回自开机以来经历的毫秒数 DWORD startTime = GetTickCount(); Sleep(SLEEP_TIME_MILL); DWORD stopTime = GetTickCount(); DWORD elapsed = stopTime - startTime; qDebug()&lt;&lt;&quot;GetTickCount = &quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;&#125;///**// * timeGetTime的精度为ms级// * 必须添加Winmm.lib, 否则编译报错undefined reference// *///void calcByTimeGetTime() &#123;// //返回自开机以来经历的毫秒数// DWORD startTime = timeGetTime();// Sleep(SLEEP_TIME_MILL);// DWORD stopTime = timeGetTime();// DWORD elapsed = stopTime - startTime;// qDebug()&lt;&lt;&quot;timeGetTime = &quot;&lt;&lt;elapsed&lt;&lt;&quot;ms&quot;;//&#125;/** * gettimeofday的精度为us级 */void calcByGetTimeOfDay() &#123; struct timeval startTime, stopTime; gettimeofday(&amp;startTime, NULL); Sleep(SLEEP_TIME_MILL); gettimeofday(&amp;stopTime, NULL); long elapsed = (stopTime.tv_sec-startTime.tv_sec) * 1000000 + (stopTime.tv_usec - startTime.tv_usec); qDebug()&lt;&lt;&quot;gettimeofday =&quot;&lt;&lt;elapsed&lt;&lt;&quot;us&quot;;&#125;/** * QueryPerformanceCounter的精度为us级 */void calcByQueryPerformanceCounter() &#123; LARGE_INTEGER frequency, startCount, stopCount; WINBOOL ret; //返回性能计数器每秒滴答的个数 ret = QueryPerformanceFrequency(&amp;frequency); if(ret) &#123; ret = QueryPerformanceCounter(&amp;startCount); &#125; Sleep(SLEEP_TIME_MILL); if(ret) &#123; QueryPerformanceCounter(&amp;stopCount); &#125; if(ret) &#123; LONGLONG elapsed = (stopCount.QuadPart - startCount.QuadPart) * 1000000 / frequency.QuadPart; qDebug()&lt;&lt;&quot;QueryPerformanceFrequency &amp; QueryPerformanceCounter =&quot;&lt;&lt;elapsed&lt;&lt;&quot;us&quot;; &#125;&#125;/** * time(NULL)精确度为s级 */void calcByTime() &#123; time_t startTime = time(NULL); Sleep(SLEEP_TIME_MILL); time_t stopTime = time(NULL); long elapsed = stopTime - startTime; qDebug()&lt;&lt;&quot;time(NULL) =&quot;&lt;&lt;elapsed&lt;&lt;&quot;s&quot;;&#125;int main(int argc, char *argv[])&#123; calcByQtimeElapsed(); calcByQtimeCurrentTime(); calcByClock(); calcByTickCount();// calcByTimeGetTime(); calcByGetTimeOfDay(); calcByQueryPerformanceCounter(); calcByTime(); system(&quot;pause&quot;); return 0;&#125; C/C++中各种类型int、long、double、char表示范围（最大最小值） 文章：C++三种容器：list、vector和deque的区别 在写C++程序的时候会发现STL是一个不错的东西，减少了代码量，使代码的复用率大大提高，减轻了程序猿的负担。还有一个就是容器，你会发现要是自己写一个链表、队列，或者是数组的时候，既要花时间还要操心怎么去维护，里面的指针啊，内存够不够用啊，长度问题，有没有可能溢出啊等等一系列的问题等着我们去解决，还是比较头疼的。所以容器的出现解决了这一个问题，它将这些数据结构都封装成了一个类，只需要加上头文件，我们就可以轻松的应用，不用那么复杂，就连指针也被封装成了迭代器，用起来更方便，更人性化，方便了我们的编程，对于程序员来说还是一大福音！！ C++中的容器类包括“顺序存储结构”和“关联存储结构”，前者包括vector，list，deque等；后者包括set，map，multiset，multimap等。若需要存储的元素数在编译器间就可以确定，可以使用数组来存储，否则，就需要用到容器类了。 vector 连续存储结构，每个元素在内存上是连续的；支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；相当于一个数组，但是与数组的区别为：内存空间的扩展。vector支持不指定vector大小的存储，但是数组的扩展需要程序员自己写。 vector的内存分配实现原理： STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacity（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储（VS6.0是两倍，VS2005是1.5倍），所以这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。 扩充空间（不论多大）都应该这样做：（1）配置一块新空间（2）将旧元素一一搬往新址（3）把原来的空间释放还给系统 注：vector 的数据安排以及操作方式，与array 非常相似。两者的唯一差别在于空间的利用的灵活性。Array 的扩充空间要程序员自己来写。 vector类定义了好几种构造函数，用来定义和初始化vector对象: vector v1; vector保存类型为T的对象。默认构造函数v1为空。 vector v2(v1); v2是v1的一个副本。 vector v3(n, i); v3包含n个值为i的元素。 vector v4(n); v4含有值初始化的元素的n个副本。 deque 连续存储结构，即其每个元素在内存上也是连续的，类似于vector，不同之处在于，deque提供了两级数组结构， 第一级完全类似于vector，代表实际容器；另一级维护容器的首位地址。这样，deque除了具有vector的所有功能外，还支持高效的首/尾端插入/删除操作。 deque 双端队列 double-end queue deque是在功能上合并了vector和list。 优点：(1) 随机访问方便，即支持[ ]操作符和vector.at() (2) 在内部方便的进行插入和删除操作 (3) 可在两端进行push、pop 缺点：占用内存多使用区别： （1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector （2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list （3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque list 非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。优点：(1) 不使用连续内存完成动态操作。 (2) 在内部方便的进行插入和删除操作 (3) 可在两端进行push、pop 缺点：(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at() (2) 相对于verctor占用内存多 使用区别： （1）如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector （2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list （3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque vector VS. list VS. deque： a、若需要随机访问操作，则选择vector； b、若已经知道需要存储元素的数目，则选择vector； c、若需要随机插入/删除（不仅仅在两端），则选择list d、只有需要在首端进行插入/删除操作的时候，还要兼顾随机访问效率，才选择deque，否则都选择vector。 e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中-deque。 f、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。 问题一：list和vector的区别：（1）vector为存储的对象分配一块连续的地址空间，随机访问效率很高。但是插入和删除需要移动大量的数据，效率较低。尤其当vector中存储的对象较大，或者构造函数复杂，则在对现有的元素进行拷贝的时候会执行拷贝构造函数。（2）list中的对象是离散的，随机访问需要遍历整个链表，访问效率比vector低。但是在list中插入元素，尤其在首尾插入，效率很高，只需要改变元素的指针。（3）vector是单向的，而list是双向的； （4）向量中的iterator在使用后就释放了，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的； 使用原则：（1）如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector；（2）如果需要大量高效的删除插入，而不在乎存取时间，则使用list；（3）如果需要搞笑的随机存取，还要大量的首尾的插入删除则建议使用deque，它是list和vector的折中；问题二：常量容器const const vector vec(10);//这个容器里capacity和size和值都是不能改变的，const修饰的是vector； 迭代器：const vector::const_iterrator ite; //常量迭代器； 注：const vector vec(10) —— 与const int a[10]是一回事，意思是vec只有10个元素，不能增加了，里面的元素也是不能变化的 123456vector&lt;int&gt; a(10); const vector&lt;int&gt; b(10); a[1]=10;//正确 b[1]=10;//错误 a.resize(20);//正确 b.resize(20);//错误 123vector &lt;const int&gt; vec(10); //目前没有这种用法;这样写后也是当作vector &lt;int&gt;vec来用的； 关于vector&lt;const int&gt; ，在GCC下是没有这种用法的,编译不过 在VS2008是把它当作vector&lt;int&gt;这种类型来处理的； 问题三：capacity V.S size a、capacity是容器需要增长之前，能够盛的元素总数；只有连续存储的容器才有capacity的概念（例如vector，deque，string），list不需要capacity。 b、size是容器当前存储的元素的数目。 c、vector默认的容量初始值，以及增长规则是依赖于编译器的。问题四：用vector存储自定义类对象时，自定义类对象须满足： a、有可供调用的无参构造函数（默认的或自定义的）； b、有可用的拷贝赋值函数（默认的或自定义的） 问题五：迭代器iterator a、vector与deque的迭代器支持算术运算，list的迭代器只能进行++/–操作，不支持普通的算术运算。 b、向量中的iterator在使用后就释放了，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的； vector代码实例：123ite=find(vec.begin(),vec.end(),88); vec.insert(ite,2,77); //迭代器标记的位置前，插入数据； cout&lt;&lt;*ite&lt;&lt;endl; //会崩溃，因为迭代器在使用后就释放了，*ite的时候就找不到它的地址了； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt; using namespace std; #include &lt;vector&gt; //向量的头文件； #include &lt;algorithm&gt; //算法的头文件； int main() &#123; vector &lt;int&gt; vec(5,8); //--类型是vector&lt;int&gt;，该容器向量中含有5个int类型的数值8，变量名为vec。 //vector是一个类模板（class template）,所以必须要声明其类型，int，一个容器中所有的对象必须是同一种类型； // 定义一个容器对象；直接构造出一个数组；用法和数组一样； // for(int i=0;i&lt;vec.size();i++) //size()是指容器里当前有多少个使用的元素； &#123; cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; //得到容器里用的多少个空间，和总共的大小； vector&lt;int&gt;::iterator ite; //定义了一个向量的迭代器；相当于定义了一个指针； for(ite=vec.begin();ite!=vec.end();ite++) //得到开始、结束 &#123; cout&lt;&lt;*ite &lt;&lt;&quot; &quot;; //迭代器返回的是引用： &#125; cout&lt;&lt;endl; //在尾部插入； vec.push_back(9); //VS6.0扩充的空间是两倍；在VS2005扩充的空间是1.5倍； for(ite=vec.begin();ite!=vec.end();ite++) //得到开始、结束 &#123; cout&lt;&lt;*ite &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; //尾部删除;容量没变【capacitty】，但是使用空间减少一个；容量一旦增加就不会减小； vec.pop_back(); for(ite=vec.begin();ite!=vec.end();ite++) //得到开始、结束 &#123; cout&lt;&lt;*ite &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; vec.push_back(88); vec.push_back(99); //容量刚好够； for(ite=vec.begin();ite!=vec.end();ite++) //得到开始、结束 &#123; cout&lt;&lt;*ite &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; ite = find(vec.begin(),vec.end(),88); //查找这个元素； vec.erase(ite); //利用迭代器指针删除这个元素； for(int i=0;i&lt;vec.size();i++) //size()是指容器里当前有多少个使用的元素； &#123; cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; //得到容器里用的多少个空间，和总共的大小； vec.clear(); //只是清除了数据，没有回收空间，空间的等到对象的生命周期结束时回收； //使用空间为0，但是容量的空间还在，只有在调用析构函数的时候空间才会回收； for(int i=0;i&lt;vec.size();i++) //size()是指容器里当前有多少个使用的元素； &#123; cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; ite=find(vec.begin(),vec.end(),88); vec.insert(ite,2,77); //迭代器标记的位置前，插入数据； &lt;span style=&quot;color:#ff0000;&quot;&gt;//cout&lt;&lt;*ite&lt;&lt;endl; //会崩溃，因为迭代器在使用后就释放了，*ite的时候就找不到它的地址了； //和向量的用法一样，但是链表list不同，它的迭代器在使用后还可以继续用；链表特有的；&lt;/span&gt; for(int i=0;i&lt;vec.size();i++) &#123; cout&lt;&lt;vec[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl&lt;&lt;vec.size()&lt;&lt;&quot; &quot;&lt;&lt;vec.capacity()&lt;&lt;endl; system(&quot;pause&quot;); return 0; &#125; 运行结果： list代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt; #include &lt;list&gt; #include &lt;algorithm&gt; using namespace std; int main() &#123; list&lt;char&gt; lit; //用法和向量一样， //list是一个类模板，template，char是链表里对象的类型，lit是创建的一个对象； //链表可以再头尾两端插入,是双向的； lit.push_back(&apos;a&apos;); lit.push_back(&apos;b&apos;); lit.push_front(&apos;d&apos;); lit.push_front(&apos;e&apos;); lit.push_front(&apos;f&apos;); lit.push_front(&apos;b&apos;); lit.push_front(&apos;b&apos;); list&lt;char&gt;::iterator it; //定义一个list的迭代器，类似一个纸箱链表的指针，但是比一般的指针好用，里面用到了好多重载操作； list&lt;char&gt;::iterator it1; list&lt;char&gt;::iterator it2; for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; //-----------链表可以从两端删除------------------- lit.pop_back(); lit.pop_front(); for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; //-------------删除所有的a--------------------------------- //lit.remove(&apos;a&apos;); //删除所有的a; for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; //-------------移除连续且相同的a，只剩下一个;-------------------------------- lit.unique(); //移除连续且相同的a，只剩下一个; for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; list&lt;char&gt; lit1; lit1.push_back(&apos;g&apos;); lit1.push_back(&apos;h&apos;); lit1.push_back(&apos;i&apos;); lit1.push_back(&apos;k&apos;); for(it1=lit1.begin();it1!=lit1.end();it1++) &#123; cout&lt;&lt;*it1&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; //-------------将一个链表插入到另一个链表--------------------------------- it1=find(lit.begin(),lit.end(),&apos;f&apos;); //先的找到要插入的位置，在该位置的前一个插入； ////lit.splice(it1,lit1); //将第二个链表插入到第一个链表中；合并后的链表就没了，因为传的是&amp;； for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; //------在链表lit中的it前插入lit1中的一个元素it1；在f之前插入k----- //-----拿下来之后那个元素就没有了------------------- it=find(lit.begin(),lit.end(),&apos;f&apos;); it1=find(lit1.begin(),lit1.end(),&apos;k&apos;); lit.splice(it,lit1,it1); //-------------把链表中的一段插入到另一个链表中--------------------------------- //把链表lit1中的[it-----it1)段的字符插入到lit的it2指针前； it=find(lit1.begin(),lit1.end(),&apos;h&apos;); it1=find(lit1.begin(),lit1.end(),&apos;k&apos;); it2=find(lit.begin(),lit.end(),&apos;f&apos;); lit.splice(it2,lit1,it,it1); // ----void merge(list&amp; x); //将x合并到*this 身上。两个lists 的内容都必须先经过递增归并排序。 lit.sort(); //对两个排序进行归并排序； lit1.sort(); lit.merge(lit1); //-----------将list里的数据倒序排列--------------- lit.reverse(); for(it=lit.begin();it!=lit.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for(it1=lit1.begin();it1!=lit1.end();it1++) &#123; cout&lt;&lt;*it1&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; system(&quot;pause&quot;); return 0; &#125; 运行结果： 17.四舍六入五成双四舍六入五成双是一种比较精确比较科学的计数保留法，是一种数字修约规则。 对于位数很多的近似数，当有效位数确定后，其后面多余的数字应该舍去，只保留有效数字最末一位，这种修约（舍入）规则是“四舍六入五成双”，也即“4舍6入5凑偶”这里“四”是小于五的意思，”六”是大于五的意思，”五”是所精确的位的后一位，当5后有数，舍5入1，5后无数或为0时： ①5前为奇数，舍5入1； ②5前为偶数，舍5不进。 具体规则如下： 1. 小于5舍去，即舍去部分的数值小于保留部分的末位的半个单位，则末位不变； 2. 大于5进1，即舍去部分的数值大于保留部分的末位的半个单位，则末位加1； 3. 等于5时取偶数，即舍去部分的数值，等于保留部分的末位的半个单位，则 末位凑成偶数，即当末位为偶数时，末位不变；当末位为奇数时，末位加1。 举例，用上述规则对下列数据保留3位有效数字： 9.8249=9.82, 9.82671=9.83 9.8251=9.83, 9.8350 =9.84 9.8250=9.82, 9.82501=9.83 从统计学的角度，“四舍六入五成双”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“四舍六入五成双”使测量结果受到舍入误差的影响降到最低。 例如:1.15+1.25+1.35+1.45=5.2，若按四舍五入取一位小数计算： 1.2+1.3+1.4+1.5=5.4 按“四舍六入五成双”计算，1.2+1.2+1.4+1.4=5.2，舍入后的结果更能反映实际结果。 td::setprecision与showpoint和ios::fixed的配合使用 C++随笔 —— std::setprecision与showpoint和ios::fixed的配合使用 今天写代码的时候发现了个bug，而且是非常奇怪的bug。因为float类型的数据A在cout以后显示的值明明是等于B的，可计算机判断A&lt;B却为真。 为了弄明白这是怎么回事，问了同学以后大概知道问题出在cout的precision上。由于精度的限制，cout 跟 printf 类似，打印出来的值并不一定完全等于它的实际值。 事实表明的确是这样的。比如，A = 50.4999994，B = 50.5，显示A&lt;B，而打印A的语句如果是这样：cout &lt;&lt; A &lt;&lt; endl，那么你看到的就是50.5。这让人困惑，以为A=B。 通过在网上仔细查资料学习，明白了为什么。原文总结得已经很全面了，所以直接贴过来。原文转自这里 先写写自己的几点总结： 1、setprecision(n): 表示保留n位有效数字，其中最后一位是四舍五入之后的结果；默认情况下n=6 所以对于50.4999994，如果n&lt;9，cout 打印出来的数值都是50.5，后面的零会省去不打印。 2、如果加上showpoint，后面的零就不省略了。 3、ios::fixed 是用来控制小数点后面的打印数字个数的。 转载正文： 首先要加头文件：iomanip 一：setprecision 作用：控制输出流显示浮点数的数字个数，setprecision(n)就是输出的n个数，会有四舍五入。 比如:double s=20.7843000, cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;会输出2e+001，因为要输出一个数字，所以只有2. cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21。 cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.8。 cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.7843。 cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.7843。 cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.7843。 可见，小数部分末尾为0时，是输不出来的！ 要想输出来，就得用showpoint了。 特别提示： （如果再在这些语句后面加个两个语句： cout&lt;&lt;1&lt;&lt;endl; cout&lt;&lt;1.00800&lt;&lt;endl; 猜到会输出什么吗？ 第一条输出：1。不是浮点型。 第二条为：1.008。承接setprecision(8）的这条规则语句。 注： 如果直接有语句 int main() { cout&lt;&lt;1&lt;&lt;endl; cout&lt;&lt;1.00&lt;&lt;endl; } 第一条输出：1。 第二条也为：1。按整型输出） 二：setprecision与showpoint 语法：在输出语句前声明：cout.setf(ios::showpoint);就行了！ 还比如:double s=20.7843000, cout.setf(ios::showpoint); cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;就会输出2.e+001，注意，2和e之间多了一个“.”。 cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21.。多个点！ cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.8。 cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.7843。 cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.78430。 cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.784300。 可见，就会输出想要的数据数目！ 特别提示： （如果再在这些语句后面加个两个语句： cout&lt;&lt;1&lt;&lt;endl; cout&lt;&lt;1.0080&lt;&lt;endl; 猜到会输出什么吗？ 第一条输出：1。不是浮点型。 第二条也为：1.0080000。承接setprecision(8）的这条规则语句。 三：setprecision与fixed 如果想要保留几位小数，那setprecision就得与fixed合作了！！ 语法：在输出语句前声明：cout.setf(ios::fixed); 比如:double s=20.7843909 cout.setf(ios::fixed); cout&lt;&lt;setprecision(1)&lt;&lt;s&lt;&lt;endl;就会输出2.8 。 cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;会输出21.78。多个点！ cout&lt;&lt;setprecision(3)&lt;&lt;s&lt;&lt;endl;会输出20.784。 cout&lt;&lt;setprecision(6)&lt;&lt;s&lt;&lt;endl;会输出20.784391。 cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl;会输出20.7843909。 cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl;会输出20.78439090。 特别提示： （如果也再在这些语句后面加个两个语句： cout&lt;&lt;1&lt;&lt;endl; cout&lt;&lt;1.008&lt;&lt;endl; 猜到会输出什么吗？ 第一条输出：1。 第二条为：1.00800000。 就是承接了setprecision(8）的这条规则语句，是浮点型的都会保留8个小数。是整型的还是整型！） 语句也可以写成：cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl; 就算后面的语句没有写&lt;&lt;fixed，同样会按有&lt;&lt;fixed处理。 比如有语句： cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl; A：cout&lt;&lt;setprecision(7)&lt;&lt;s&lt;&lt;endl; B:cout&lt;&lt;setprecision(8)&lt;&lt;s&lt;&lt;endl; ＡＢ语句均会按保留７个，８个小数处理，不会再按有7或8个浮点数处理。 如果下面有语句c: cout&lt;&lt;1.008&lt;&lt;endl;也会保留8个小数。 四:setprecision、showpoint与fixed {cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;123.456&lt;&lt;endl;//输出的结果是123.46cout&lt;&lt;showpoint&lt;&lt;12345.0006666&lt;&lt;endl;//输出12345.0cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;123.456&lt;&lt;endl;} 比如:double s=20.7843909 1.有语句12cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78 2.有语句： 12cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出21.（有个点） 3.有语句： 12cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78391cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出20.78391 4.有语句： 123cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//输出20.78cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//输出20.78 5.有语句： 123cout&lt;&lt;setprecision(2)&lt;&lt;s&lt;&lt;endl;//输出21cout&lt;&lt;showpoint&lt;&lt;s&lt;&lt;endl;//21.（有个点）cout&lt;&lt;fixed&lt;&lt;s&lt;&lt;endl;//20.78 浮点数比较 参考：How to compare double values limiting the decimal places? The usual way to compare two floating point values is to subtract them from each other, get the absolute value of the result, and compare it to an epsilon value. In your case it could be something like1234bool compare(double value1, double value2, quint8 precision)&#123; return std::abs(value1 - value2) &lt; std::pow(10, -precision);&#125; For a precision of e.g. 6 then std::pow(10, -precision) should equal 0.000001 (this is the epsilon), and if the difference between the two values is smaller than that they are considered equal.]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt程序启动画面QSplashScreen]]></title>
    <url>%2F2018%2F08%2F02%2FQt%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%94%BB%E9%9D%A2QSplashScreen%2F</url>
    <content type="text"><![CDATA[Qt程序启动画面QSplashScreen关于Qt程序启动画面QSplashScreen类的使用，Qt官方文档给出的例子是用于显示静态图片的，帮助文档中有这样一段话： The user can hide the splash screen by clicking on it with the mouse. Since the splash screen is typically displayed before the event loop has started running, it is necessary to periodically call QApplication::processEvents() to receive the mouse clicks. 翻译成中文意思是：用户可以点击隐藏启动画面，但由于启动界面在系统事件循环开始之前已经显示，需要周期性的调用QApplication::processEvents()，强制事件循环投递事件，达到接受并处理鼠标事件的目的。意思是QSplashScreen启动时，系统事件循环还没有真正跑起来，用户需要手动强制事件循环，对于需要在启动界面中显示进度条、显示动画、或者显示QMovie的操作，这个处理就显得非常有必要，否则上述的几项操作，在缺少事件循环投递的情况下，只会显示成静态图片或者根本没效果。查询资料只有stackoverflow上有比较详细的例子，参考以下两文章 Showing a QMovie in QSplashScreenQt C++ - Aligning QProgressBar inside a QSplashScreen 第一篇文章作者通过代码调试，发现只显示了一帧画面，就是时间循环没启动导致的。往下有个给出了解决方案，摘录有用的部分如下： Problem is quite profound. To have animation working you have to allow process events in main thread. On other hand initialization process is also performed on main thread.First approach is add those app.processEvents() as often as possible but this will limit frame rate so badly that it is useless. 翻译如下：要使动画正常播放，必须令主线程的事件正常投递，另一方面初始化处理依然在主线程中执行，常用的方法是主动调用app.processEvents()，但这种方法极大的限制了帧率。 To fix it properly you have answer two important question: what are you doing during initialization? and can this initialization be moved to separate thread? 翻译如下：要正确地处理必须回答以下两个问题： 在初始化期间做了什么？ 这个初始化处理是否能够通过独立的线程处理？ Once I’ve had application where during initialization large index was build. This took about 40 seconds so quite a lot. I’ve moved building index to separate thread using QtConcurrent::run(this, &amp;MyClass::MyMethodToBuildIndex) and showing some progress by emitting signals periodically from MyClass::MyMethodToBuildIndex (default automatic connection did the whole trick).If you have similar log time initialization this solution will enable animation of your QMovie out of the box, problem will be just smart connection of signal and slots so windows will be shown and hidden with proper timings. 翻译如下：一旦需要做耗时操作，例如建立索引等耗时超过40s的初始化，应通过QtConcurrent::run(this, &amp;MyClass::MyMethodToBuildIndex)把处理转移到子线程中执行，并通过周期性的信号方式通知前台UI显示进度。 示例代码如下：123456789101112131415161718192021222324252627int main(int argc, char *argv[])&#123; QApplication app(argc, argv); SplashScreen splash(); splash.show(); app.processEvents(); // need to process events manually QMainWindow window; SomeLogicClass data; window.setData(&amp;data); connect(&amp;data, SIGNAL(initializationProgressChanged(int)), &amp;spash, SLOT(setProgress(int))); // show main window when initialization is finished connect(&amp;data, SIGNAL(initializationFinished()), &amp;window, SLOT(show())); // close splash when initialization is finished connect(&amp;data, SIGNAL(initializationFinished()), &amp;spash, SLOT(close())); // this line I usually hide behind some method like: startBackgroundInitialization QtCuncurent::run(&amp;data, &amp;SomeLogicClass::heavyInitialization); return app.exec();&#125; If you need to use QSplashScreen::finish instead close then QSignalMapper can help.Note that last argument of connect is default value Qt::AutoConnection which will enforce slots to be run in main thread. 文章二提供了一种在启动界面中绘制进度条，并提供一接口设置进度条数值的方法：sp.h:12345678910111213141516171819202122232425262728293031#ifndef SPLASHSCREEN_H#define SPLASHSCREEN_H#include &lt;QSplashScreen&gt;#include &lt;QApplication&gt;class SplashScreen : public QSplashScreen&#123; Q_OBJECTpublic: explicit SplashScreen(QApplication *app, QWidget *parent = 0); int m_progress; QApplication *app;public slots: void setProgress(int value) &#123; m_progress = value; if (m_progress &gt; 100) m_progress = 100; if (m_progress &lt; 0) m_progress = 0; update(); &#125;protected: void drawContents(QPainter *painter);&#125;;#endif // SPLASHSCREEN_H sp.cpp123456789101112131415161718192021222324252627282930#include &quot;sp.h&quot;SplashScreen::SplashScreen(QApplication *aApp, QWidget *parent) : QSplashScreen(parent), app(aApp), m_progress(0)&#123; this-&gt;setPixmap(QPixmap(&quot;:/images/splashscreen.png&quot;)); this-&gt;setCursor(Qt::BusyCursor); this-&gt;showMessage(&quot;Hello&quot;, Qt::AlignBottom);&#125;void SplashScreen::drawContents(QPainter *painter)&#123; QSplashScreen::drawContents(painter); // Set style for progressbar... QStyleOptionProgressBarV2 pbstyle; pbstyle.initFrom(this); pbstyle.state = QStyle::State_Enabled; pbstyle.textVisible = false; pbstyle.minimum = 0; pbstyle.maximum = 100; pbstyle.progress = m_progress; pbstyle.invertedAppearance = false; pbstyle.rect = QRect(0, 265, 380, 19); // Where is it. // Draw it... style()-&gt;drawControl(QStyle::CE_ProgressBar, &amp;pbstyle, painter, this);&#125;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QSplashScreen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++新特性学习]]></title>
    <url>%2F2018%2F08%2F01%2FC-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[C++新特性学习c++ Lambda表达式 c++ Lambda表达式待修改 C++11引入了lambda表达式，使得程序员可以定义匿名函数，该函数是一次性执行的，既方便了编程，又能防止别人的访问。Lambda表达式的语法通过下图来介绍： 这里假设我们定义了一个如上图的lambda表达式。现在来介绍途中标有编号的各个部分是什么意思。 Lambda表达式的引入标志，在‘[]’里面可以填入‘=’或‘&amp;’表示该lambda表达式“捕获”（lambda表达式在一定的scope可以访问的数据）的数据时以什么方式捕获的，‘&amp;’表示一引用的方式；‘=’表明以值传递的方式捕获，除非专门指出。 Lambda表达式的参数列表 Mutable 标识 异常标识 返回值 “函数”体，也就是lambda表达式需要进行的实际操作 将上图的代码片段补充完整： 123456int x = 10;int y = 3;int z ;z = [=]()mutable throw() -&gt; int &#123; int n = x + y; x = y ; y = n; return n;&#125;();cout&lt;&lt;z&lt;&lt;endl;cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot;\t&quot;&lt;&lt;&quot;y:&quot;&lt;&lt;y&lt;&lt;endl; std::function的用法 std::function的用法 类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。 通常std::function是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;memory&gt;using namespace std;//声明一个模板typedef std::function&lt;int(int)&gt; Functional;//normal functionint TestFunc(int a)&#123; return a;&#125;//lambda expressionauto lambda = [](int a)-&gt;int&#123;return a;&#125;;//functor仿函数class Functor&#123;public: int operator() (int a) &#123; return a; &#125;&#125;;//类的成员函数和类的静态成员函数class CTest&#123;public: int Func(int a) &#123; return a; &#125; static int SFunc(int a) &#123; return a; &#125;&#125;;int main(int argc, char* argv[])&#123; //封装普通函数 Functional obj = TestFunc; int res = obj(0); cout &lt;&lt; &quot;normal function : &quot; &lt;&lt; res &lt;&lt; endl; //封装lambda表达式 obj = lambda; res = obj(1); cout &lt;&lt; &quot;lambda expression : &quot; &lt;&lt; res &lt;&lt; endl; //封装仿函数 Functor functorObj; obj = functorObj; res = obj(2); cout &lt;&lt; &quot;functor : &quot; &lt;&lt; res &lt;&lt; endl; //封装类的成员函数和static成员函数 CTest t; obj = std::bind(&amp;CTest::Func, &amp;t, std::placeholders::_1); res = obj(3); cout &lt;&lt; &quot;member function : &quot; &lt;&lt; res &lt;&lt; endl; obj = CTest::SFunc; res = obj(4); cout &lt;&lt; &quot;static member function : &quot; &lt;&lt; res &lt;&lt; endl; return 0;&#125; 对于各个可调用实体转换成std::function类型的对象，上面的代码都有，运行一下代码，阅读一下上面那段简单的代码。总结了简单的用法以后，来看看一些需要注意的事项： 关于可调用实体转换为std::function对象需要遵守以下两条原则： 转换后的std::function对象的参数能转换为可调用实体的参数； 可调用实体的返回值能转换为std::function对象的返回值。 std::function对象最大的用处就是在实现函数回调，使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。 为什么要用std::function好用并实用的东西才会加入标准的。因为好用，实用，我们才在项目中使用它。std::function实现了一套类型消除机制，可以统一处理不同的函数对象类型。以前我们使用函数指针来完成这些；现在我们可以使用更安全的std::function来完成这些任务。 C++11新特性之 CALLBACKS 文章链接：C++11新特性之 CALLBACKS 使用回调12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;functional&gt;#include &lt;iostream&gt;namespace &#123;using cb1_t = std::function&lt;void()&gt;;using cb2_t = std::function&lt;void(int)&gt;;void foo1()&#123; std::cout &lt;&lt; &quot;foo1 is called\n&quot;;&#125;void foo2(int i)&#123; std::cout &lt;&lt; &quot;foo2 is called with: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;struct S &#123; void foo3() &#123; std::cout &lt;&lt; &quot;foo3 is called.\n&quot;; &#125;&#125;;&#125;int main()&#123; // Bind a free function. cb1_t f1 = std::bind(&amp;foo1); // Invoke the function foo1. f1(); // Bind a free function with an int argument. // Note that the argument can be specified with bind directly. cb1_t f2 = std::bind(&amp;foo2, 5); // Invoke the function foo2. f2(); // Bind a function with a placeholder. cb2_t f3 = std::bind(&amp;foo2, std::placeholders::_1); // Invoke the function with an argument. f3(42); // Bind a member function. S s; cb1_t f4 = std::bind(&amp;S::foo3, &amp;s); // Invoke the method foo3. f4(); // Bind a lambda. cb1_t f5 = std::bind([] &#123; std::cout &lt;&lt; &quot;lambda is called\n&quot;; &#125;); f5(); return 0;&#125; 存储回调使用回调是非常好的，但是更多的情况下，我们往往需要存储一些回调函数，并稍后使用。例如，注册一个客户端到某个事件上。（也许注册和事件是C Sharp的词汇） 我们经常使用std::vector来完成任务。缺点就是，我们不能再vector中存储不同的类型 。但是，大多数情况下，一种类型就可以满足我们了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;iostream&gt;namespace &#123;using cb1_t = std::function&lt;void()&gt;;using callbacks_t = std::vector&lt;cb1_t&gt;;callbacks_t callbacks;void foo1()&#123; std::cout &lt;&lt; &quot;foo1 is called\n&quot;;&#125;void foo2(int i)&#123; std::cout &lt;&lt; &quot;foo2 is called with: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;&#125; // end anonymous namespaceint main()&#123; // Bind a free function. cb1_t f1 = std::bind(&amp;foo1); callbacks.push_back(f1); // Bind a free function with an int argument. // Here the argument is statically known. cb1_t f2 = std::bind(&amp;foo2, 5); callbacks.push_back(f2); // Bind a free function with an int argument. // Here the argument is bound and can be changed at runtime. int n = 15; cb1_t f3 = std::bind(&amp;foo2, std::cref(n)); callbacks.push_back(f3); // Invoke the functions for(auto&amp; fun : callbacks) &#123; fun(); &#125; return 0;&#125; 包装函数上面提到都不是重点，个人觉得特别重要的就是std::function作为函数的参数使用。下面一个例子就将展示一个函数被copy不同的参数。 Note that we always produce an std::function, even though in some cases we could invoke the target directly. Whether this is required depends on the use case. If all the function does is invoking the target, then directly doing it is more efficient. The reason is that std::function does have some overhead, because it is a polymorphic class.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;functional&gt;#include &lt;iostream&gt;namespace &#123;using cb1_t = std::function&lt;void()&gt;;using cb2_t = std::function&lt;void(int)&gt;;// Wrapper function with std::function without arguments.template&lt;typename R&gt;void call(std::function&lt;R(void)&gt; f)&#123; f();&#125;// Wrapper function with std::function with arguments.template&lt;typename R, typename ...A&gt;void call(std::function&lt;R(A...)&gt; f, A... args)&#123; f(args...);&#125;// Wrapper function for generic callable object without arguments.// Delegates to the std::function call.template&lt;typename R&gt;void call(R f(void))&#123; call(std::function&lt;R(void)&gt;(f));&#125;// Wrapper function for generic callable object with arguments.// Delegates to the std::function call.template&lt;typename R, typename ...A&gt;void call(R f(A...), A... args)&#123; call(std::function&lt;R(A...)&gt;(f), args...);&#125;// Wrapper for a function pointer (e.g. a lambda without capture) without// arguments.using fp = void (*)(void);void call(fp f)&#123; call(std::function&lt;void()&gt;(f));&#125;void foo1()&#123; std::cout &lt;&lt; &quot;foo1 is called\n&quot;;&#125;void foo2(int i)&#123; std::cout &lt;&lt; &quot;foo2 is called with: &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;&#125; // end anonymous namespaceint main()&#123; // Call function 1. call(&amp;foo1); // Alternative to call function 1. cb1_t f1 = std::bind(&amp;foo1); call(f1); // Call function 2. call(&amp;foo2, 5); // Alternative to call function 2. cb2_t f2 = std::bind(&amp;foo2, std::placeholders::_1); call(f2, 5); // Here is an example with a lambda. It calls the function that takes a // function pointer. call([] &#123; std::cout &lt;&lt; &quot;lambda called\n&quot;; &#125;); return 0;&#125; C++ 11 STL | functional 标准库 文章链接：C++ 11 STL | functional 标准库 最近正好用到了这个，就顺便总结下吧。 C++ 11引入了函数对象标准库，里面包含各种内建的函数对象以及相关的操作函数，非常方便。这里总结一下std::function和std::bind的相关用法。 Callable typeCallable type指可以像调用函数一样被调用的对象或函数，包括： std::function std::bind std::result_of std::thread::thread std::call_once std::async std::packaged_task std::reference_wrapper 根据C++ 17 Standard，所有Callable type都可以通过std::invoke方法进行显式调用。 std::functionstd::function类模板是一种通用的函数包装器，它可以容纳所有可以调用的对象（Callable），包括 函数、函数指针、Lambda表达式、bind表达式、成员函数及成员变量或者其他函数对象。通过std::function可以储存、拷贝或调用Callable对象。它的模板参数如下：12template&lt; class R, class... Args &gt;class function&lt;R(Args...)&gt; 使用时，模板参数与要存储的函数参数一致即可，下面是一些例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;functional&gt;double f(int x, char y, double z) &#123; return x + y + z;&#125;void print_num(int num) &#123; std::cout &lt;&lt; num &lt;&lt; std::endl;&#125;struct Dog &#123; int id; explicit Dog(int id): id(id) &#123;&#125; void print_add(int i) const &#123; std::cout &lt;&lt; id + i &lt;&lt; std::endl; &#125;&#125;;class PrintString &#123;public: void operator()(std::string&amp;&amp; s) const &#123; std::cout &lt;&lt; s &lt;&lt; std::endl; &#125;&#125;;int main(int argc, char **argv) &#123; // common function std::function&lt;void(int)&gt; func_display_num = print_num; func_display_num(9); // common function std::function&lt;double(int, char, double)&gt; func_display = f; std::cout &lt;&lt; func_display(3, &apos;a&apos;, 1.7) &lt;&lt; &quot;\n&quot;; // lambda expression std::function&lt;void(const char*)&gt; lbd_dsp_str = [](const char *s) &#123;std::cout &lt;&lt; s &lt;&lt; std::endl;&#125;; lbd_dsp_str(&quot;Scala&quot;); // bind expression auto func_num_bind = std::bind(&amp;f, std::placeholders::_1, &apos;c&apos;, 2.4); std::cout &lt;&lt; func_num_bind(24) &lt;&lt; &quot;\n&quot;; // function object std::function&lt;void(std::string&amp;&amp;)&gt; func_obj_print = PrintString(); func_obj_print(&quot;C++ 17 Nice!&quot;); // member function const Dog dog(2424); std::function&lt;void(const Dog&amp;, int)&gt; func_mem_display_num = &amp;Dog::print_add; func_mem_display_num(dog, 24); return 0;&#125; 注意声明时可用 auto 进行自动类型推导，这样可以节约时间，不过这样会牺牲代码的可读性，因此需要根据情况合理使用 auto 。 std::bind顾名思义，std::bind 函数用来绑定函数的某些参数并生成一个新的 function 对象。 bind 用于实现偏函数（Partial Function），相当于实现了函数式编程中的 Currying（柯里化）。比如有一函数的定义为：123void func_muti(int a, std::string&amp;&amp; b, const char* c, double d, char e) &#123; std::cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; &quot;, &quot; &lt;&lt; e &lt;&lt; &quot;\n&quot;;&#125; 现在将此函数的一些参数绑定上值，其余部分用占位符对象（std::placeholders）表示。占位符是有序号的，代表调用此函数对象时参数在参数列表中的位置。比如：12auto f = std::bind(&amp;func_muti, 24, std::placeholders::_1, &quot;Haha&quot;, std::placeholders::_2, &apos;P&apos;); f(&quot;Hehe&quot;, 24.24); 调用这个函数对象相当于调用以下函数：123void f(std::string&amp;&amp; b, double d) &#123; std::cout &lt;&lt; &quot;24&quot; &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; &quot;Haha&quot; &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; &quot;, &quot; &lt;&lt; &apos;P&apos; &lt;&lt; &quot;\n&quot;; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLite中的自增关键字：AUTO_INCREMENT、INTEGER PRIMARY KEY与AUTOINCREMENT]]></title>
    <url>%2F2018%2F07%2F31%2FSQLite%E4%B8%AD%E7%9A%84%E8%87%AA%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9AAUTO-INCREMENT%E3%80%81INTEGER-PRIMARY-KEY%E4%B8%8EAUTOINCREMENT%2F</url>
    <content type="text"><![CDATA[SQLite中的自增关键字：AUTO_INCREMENT、INTEGER PRIMARY KEY与AUTOINCREMENT 参考文章：SQLite中的自增关键字：AUTO_INCREMENT、INTEGER PRIMARY KEY与AUTOINCREMENT SQLite不支持关键字AUTO_INCREMENTAUTO_INCREMENT不生效的问题SQL语句：123456CREATE TABLE todo( id INTEGER AUTO_INCREMENT, title TEXT, PRIMARY KEY (id)); 问题描述：按照上述SQL语句创建表todo，用INSERT INTO todo (title) VALUES (‘xxx’)插入记录，但查询该记录后得到的id为NULL（即Python中的None） 实验脚本：123456789101112131415161718192021#!/usr/bin/python# -*- encoding: utf-8 -*-import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)# 创建表con.execute(&quot;&quot;&quot;CREATE TABLE todo( id INTEGER AUTO_INCREMENT, title TEXT, PRIMARY KEY (id));&quot;&quot;&quot;)# 插入记录con.execute(&quot;INSERT INTO todo (title) VALUES (&apos;shopping&apos;);&quot;)# 查询记录for row in con.execute(&quot;SELECT * FROM todo&quot;): print row 运行结果：12$ python auto_increment_null.py(None, u&apos;shopping&apos;) AUTO_INCREMENT导致语法错误的问题SQL语句：12345CREATE TABLE todo( id INTEGER PRIMARY KEY AUTO_INCREMENT, title TEXT); 问题描述：根据SQL的语法，按理说上述SQL语句应该与1）中的SQL语句等效，但运行结果却是语法错误 实验脚本：1234567891011121314151617181920#!/usr/bin/python# -*- encoding: utf-8 -*-import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)# 创建表con.execute(&quot;&quot;&quot;CREATE TABLE todo( id INTEGER PRIMARY KEY AUTO_INCREMENT, title TEXT);&quot;&quot;&quot;)# 插入记录con.execute(&quot;INSERT INTO todo (title) VALUES (&apos;shopping&apos;);&quot;)# 查询记录for row in con.execute(&quot;SELECT * FROM todo&quot;): print row 运行结果： 12345$ python auto_increment_error.pyTraceback (most recent call last): File &quot;auto_increment_error.py&quot;, line 14, in &lt;module&gt; );&quot;&quot;&quot;)sqlite3.OperationalError: near &quot;AUTO_INCREMENT&quot;: syntax error 上述两个问题在《AUTO_INCREMENT in sqlite problem with python》中得到了解释和解答：在SQLite中，自增字段需要使用关键字INTEGER PRIMARY KEY。 自增关键字INTEGER PRIMARY KEYSQL语句：12345CREATE TABLE todo( id INTEGER PRIMARY KEY, title TEXT); 或者12345CREATE TABLE todo( id INTEGER PRIMARY KEY NOT NULL, title TEXT); 按照上述SQL语句创建表todo，用INSERT INTO todo (title) VALUES (‘xxx’)或者INSERT INTO todo (id, title) VALUES (NULL, ‘xxx’)插入记录，查询记录后得到的id为自增的整型值。 实验脚本：123456789101112131415161718192021222324252627282930313233#!/usr/bin/python# -*- encoding: utf-8 -*-import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)# 创建表con.execute(&quot;&quot;&quot;CREATE TABLE todo( id INTEGER PRIMARY KEY, title TEXT);&quot;&quot;&quot;)# 创建表：效果相同&apos;&apos;&apos;con.execute(&quot;&quot;&quot;CREATE TABLE todo( id INTEGER PRIMARY KEY NOT NULL, title TEXT);&quot;&quot;&quot;)&apos;&apos;&apos;# 插入记录：shoppingcon.execute(&quot;INSERT INTO todo (title) VALUES (&apos;shopping&apos;);&quot;)# 插入记录：workingcon.execute(&quot;INSERT INTO todo (id, title) VALUES (NULL, &apos;working&apos;);&quot;)# 查询记录for row in con.execute(&quot;SELECT * FROM todo&quot;): print row 运行结果：123$ python integer_primary_key_ok.py(1, u&apos;shopping&apos;)(2, u&apos;working&apos;) 注意：之前看《No autoincrement for Integer Primary key in sqlite3》中有提到“SQLite的自增字段定义为NULL或NOT NULL是有区别的”，根据上面的实验，这个问题好像已经不存在了。 关键字AUTOINCREMENT与内部表sqlite_sequenceSQLite中，在INTEGER PRIMARY KEY的基础上添加AUTOINCREMENT后（即INTEGER PRIMARY KEY AUTOINCREMENT），可以在表的整个生命周期内保证“自增字段”的唯一性（create keys that are unique over the lifetime of the table）。 SQLite内部用一个叫作sqlite_sequence的表来保存所有表的自增字段的取值基准（the largest ROWID），如果清空sqlite_sequence的记录，可以实现将所有表的自增字段的取值归零的效果（这种行为具有破坏性，请谨慎使用）。 关于这一主题，更详细的介绍可以参考《How do I create an AUTOINCREMENT field》和《SQLite Autoincrement》 实验脚本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python# -*- encoding: utf-8 -*-import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)def new_and_show(tbl_name): &quot;&quot;&quot;插入并显示记录&quot;&quot;&quot; # 插入记录到表 con.execute(&quot;INSERT INTO &quot; + tbl_name + &quot; (title) VALUES (&apos;shopping&apos;);&quot;) # 查询表记录 for row in con.execute(&quot;SELECT * FROM &quot; + tbl_name): print rowdef clr(tbl_name): &quot;&quot;&quot;清除表记录&quot;&quot;&quot; con.execute(&quot;DELETE FROM &quot; + tbl_name)print &quot;--表todo--&quot;# 1. 创建表con.execute(&quot;&quot;&quot;CREATE TABLE todo( id INTEGER PRIMARY KEY, title TEXT);&quot;&quot;&quot;)# 2. 插入并显示记录new_and_show(&quot;todo&quot;)# 3. 清除表记录clr(&quot;todo&quot;)# 4. 插入并显示记录new_and_show(&quot;todo&quot;)# 5. 清除表记录clr(&quot;todo&quot;)# 6. 插入并显示记录new_and_show(&quot;todo&quot;)print &quot;--表todo_auto--&quot;# 1. 创建表con.execute(&quot;&quot;&quot;CREATE TABLE todo_auto( id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT);&quot;&quot;&quot;)# 2. 插入并显示记录new_and_show(&quot;todo_auto&quot;)# 3. 清除表记录clr(&quot;todo_auto&quot;)# 4. 插入并显示记录new_and_show(&quot;todo_auto&quot;)# 将所有表的自增列都归零#clr(&quot;sqlite_sequence&quot;)# 5. 清除表记录clr(&quot;todo_auto&quot;)# 6. 插入并显示记录new_and_show(&quot;todo_auto&quot;) 运行结果：123456789$ python autoincrement_diff.py--表todo--(1, u&apos;shopping&apos;)(1, u&apos;shopping&apos;)(1, u&apos;shopping&apos;)--表todo_auto--(1, u&apos;shopping&apos;)(2, u&apos;shopping&apos;)(3, u&apos;shopping&apos;) 如果去掉clr(“sqlite_sequence”)这一行的注释，则运行结果会变成：123456789$ python autoincrement_diff.py--表todo--(1, u&apos;shopping&apos;)(1, u&apos;shopping&apos;)(1, u&apos;shopping&apos;)--表todo_auto--(1, u&apos;shopping&apos;)(2, u&apos;shopping&apos;)(1, u&apos;shopping&apos;) ## 由于clr(&quot;sqlite_sequence&quot;)将表todo_auto的自增字段的取值归零，因此这一行又变成了1 另外，SQLite不支持SQL标准语句“TRUNCATE TABLE tbl_name”，只能使用“DELETE FROM tbl_name”来删除表记录，具体可以参考《SQLite清空表并将自增列归零》 。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加搜索功能]]></title>
    <url>%2F2018%2F07%2F31%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Hexo博客添加搜索功能 参考文章：Hexo博客添加搜索功能 渐渐的随着hexo博客中文章越来越多了之后,平时想要查找一篇文章时,一般都是记得部分标题内容或者某些关键词,而在”归档”下通过标题一页一页的找又非常的麻烦.所以考虑为博客增加搜索功能. 从Next主题网站上我们可以搜索多款搜索插件第三方服务集成 – Next文档,个人感觉 “Local Search” 和 “Algolia” 这两款搜索插件比较和我的心意. 下面简要的介绍为hexo博客添加搜索插件的过程. 升级Next主题版本我的hexo主题安装的是 Next 主题,当前版本为 v5.0.1 .最新版本为 5.1.3. 因为我的hexo主题版本差距太大,而且我在 next 主题目录下的 .git 目录我已经删除了,所以我采用完全更新的方式. 先备份本地的 hexo 主题目录 your-hexo-site/themes/next ,其实只需要备份 _config.yml 一个文件即可,为了保险这里我将整个目录都备份一下. 另外还要注意如果你之前添加了自定义头像及打赏功能等所需图片,添加的图片是在 /themes/next/source/images/ 目录下的,也要记得做好备份. 如果你本地的主题 next 目录下的 .git 目录没有删除,你可以直接通过 git pull 命令来更新:12$ cd themes/next$ git pull 完全更新先删除本地现在的 next 主题目录:12$ cd &lt;your-hexo-site&gt;$ rm -rf ./themes/next 从github下载 hexo 主题文件最新版本:12$ cd &lt;your-hexo-site&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 比照新的主题配置文件_config.yml ,将旧的主题文件中的内容添加到新文件中. 我这里更改的地方有: menu scheme social sidebar highlight_theme tencent_analytics 打赏功能 reward_comment wechatpay alipay 站点建立时间 since 更改后,清除缓存,然后再查看:1234$ hexo clean$ hexo s -gINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开浏览器,查看页面中是否有错误并修改. LocalSearch搜索安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能：123# Local searchlocal_search: enable: true 然后 重新生成 查看:1234$ hexo clean$ hexo s -gINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这样,搜索功能就添加上了. Algolia搜索详情可参考官方教程,这里不再详述. Algolia – Next文档]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TortoiseGit代码版本还原方法]]></title>
    <url>%2F2018%2F07%2F31%2FTortoiseGit%E4%BB%A3%E7%A0%81%E7%89%88%E6%9C%AC%E8%BF%98%E5%8E%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[TortoiseGit代码版本还原方法 参考文章：Git 代码版本还原方法 在使用 Git 管理自己的代码和资料时，难免会遇到意料之外的事。比如误操作，将当前的分支删除；或者重置到某个版本，然后发现自己想要的代码找不到了；又或者需要还原到之前提交的某个版本，但是那个版本已经被重置过，在历史中找不到了。 忙活了大半天，发现辛苦换来的成果都没了，遇到这种情况几乎是要崩溃的，不过幸好我们还有 Git。 一般情况下，如果在版本的分支历史上，还可以找到想要的那个版本，那通常比较简单，只要选择重置到该版本就可以了。 重置类型有三种模式可供选择，soft、mixed 和 hard 的区别如下： soft 不改动工作区和索引假设有一些 commits1A - B - C (master) HEAD 指向 C， 并且暂存区（stage，或称为 index）matches C. 当使用 git reset --soft B 时，master 和 HEAD 指向 B，但是依然保留了 C 添加跟踪的文件，此时会将这些文件放入暂存区中，显示为已缓存。同时工作区中修改的文件，显示为未缓存。 mixed 保持工作区不变，重置索引当使用 git reset --mixed B 时，master 和 HEAD 指向 B，这时候 C 添加跟踪的文件仍然会在，但是会显示为未缓存（不是版本控制），而当前工作目录中的修改内容，仍然会在，显示未缓存的状态 （如果不知道怎么选，默认使用 mixed） hard 重置索引和工作区（丢弃所有本地变更）当使用 git reset --hard B 时，C 添加跟踪的文件，以及当前工作目录中的修改内容，都会丢失。 如果比较悲剧，分支历史上已经找不到想要的那个版本的代码了，但是别急，只要是有提交的代码，Git 都能找回来。 命令行操作查看引用记录1git reflog 会输出类似如下的内容，所有的提交记录都能看到123456789101122d3349 HEAD@&#123;0&#125;: checkout: moving from develop to master22d3349 HEAD@&#123;1&#125;: rebase -i (finish): returning to refs/heads/develop22d3349 HEAD@&#123;2&#125;: rebase -i (start): checkout 22d3349f671986 HEAD@&#123;3&#125;: checkout: moving from master to develop22d3349 HEAD@&#123;4&#125;: checkout: moving from develop to masterf671986 HEAD@&#123;5&#125;: checkout: moving from master to develop22d3349 HEAD@&#123;6&#125;: checkout: moving from rctf to masterf671986 HEAD@&#123;7&#125;: commit: Revertf4d0f6d HEAD@&#123;8&#125;: commit: Flag22d3349 HEAD@&#123;9&#125;: checkout: moving from master to rctf22d3349 HEAD@&#123;10&#125;: commit (initial): Initial Commit 还原到指定版本1git reset --hard f4d0f6d ORIG_HEAD在 .git 目录里除了 HEAD 档案之外，还有另一个叫做ORIG_HEAD的档案，当你在做一些比较危险的操作（例如像merge，rebase 或 reset之类的），Git 就会把HEAD的状态存放在这里，让你随时可以跳回危险动作之前的状态。 虽然 git reflog 指令也可以查到相关资讯，但 reflog 的资料比较杂一点，这个 ORIG_HEAD 会更方便的找到最近一次危险动作之前的SHA-1值。用下面这个命令可以查看危险操作日志，-p 参数后面，-1 表示上一条，-2 表示上两条1git log ORIG_HEAD -p -100 输出类似如下的内容1234567891011commit f671986f9aaa4fc49d8f3eba916d7947dc9f7e46Author: xxxx &lt;xxx@example.com&gt;Date: Sun May 13 12:55:31 2018 +0800 Revertdiff --git a/flag.txt b/flag.txtdeleted file mode 100644index 82a7a33..0000000--- a/flag.txt+++ /dev/null@@ -1 +0,0 @@-xxx&#123;12345&#125; 可视化界面操作我在 Windows 下使用 TortoiseGit，只要右键找到显示引用记录，就能找到所有的操作记录，然后选择想要的版本，重置过去就可以了。即便是现在这一步的重置操作选错了版本也没事，因为这个操作也被记录下来，你还是可以重置到正确的版本。 看到这张图，是不是一股暖流涌上心头，终于找回来了。 曾经尝试过用命令来操作，但是试了很久都没成功，只好放弃，改用 TortoiseGit 来操作。TortoiseGit 在 Windows 下几乎是最好用的 Git GUI 工具了。 自从使用了 Git，只要有 commit 过的代码，再也不担心会丢了，尽情的 commit 吧。]]></content>
      <categories>
        <category>TortoiseGit</category>
      </categories>
      <tags>
        <tag>TortoiseGit</tag>
        <tag>代码还原</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-submodule用法]]></title>
    <url>%2F2018%2F07%2F26%2FGit-submodule%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参考文章git的submodule功能详解 前言项目的版本库在某些情况下需要引用其他版本库中的文件，例如有一套公用的代码库，可以被多个项目调用，这个公用代码库能直接放在某个项目的代码中，而是要独立为一个代码库，那么其他要调用公用的代码库该如何处理？分别把公用的代码库拷贝到各自的项目中会造成冗余，丢弃了公共代码库的维护历史，这些显示不是好的办法，现在要了解的git子模组(git submodule)就解决了这个问题。 Git 子模块功能允许你将一个Git仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。 准备工作首先需要两个版本库例如：1) 一个公共的版本库(例如：libA.git)git@gitlab.szreach.com:fengyang/liba.git 2) 一个引用公共版本库的主版本库(例如：super.git)git@gitlab.szreach.com:fengyang/super.git TortoiseGit上git submodule功能实现添加子模组的步骤####第一步：使用submodule add…添加子模组在需要作添加子模组的Git版本库中右击，选择“TortoiseGit-&gt;Submodule Add…”，在“Repository:”里面输入需要添加子模组的版本库路径，在“Path：”中输入添加子模组存放的目录路径。如下图所示： 此时查看需要添加子模组的Git工作区的目录结构。在根目录下多了一个.gitmodules文件，并且公共代码库被克隆到lib/lib_a目录下。 ####第二步：查看.gitmodules的内容.gitmodules的内容记录着含子模组存放的目录路径及子模组版本库的路径 注：此时工作区尚未提交，完成提交后，子模组才算正式完成在需要作添加子模组的Git版本库中创立。 注：此主版本库(super.git)就变成了一个包含子模组的版本库。 克隆带子模组的版本库的步骤克隆带子模组的git库，并不能自动将子模组的版本库克隆出来，对于只关心项目本身的数据，而不关心项目引用的外部项目数据的用户，这个功能非常好，数据没有冗余而且克隆的速度也很快。 第一步：克隆super主版本库在工作区中克隆主主版本库后，会发现子模组的版本库并没有克隆，只有将存放子模组版本库的目录克隆下来了。 存放子模组版本库的目录路径 第二步：克隆子模组如果需要克隆出子模组形式引用的外部库，首先需要执行Submodule Update操作。 在需要作克隆子模组的Git工作区中右击，选择“TortoiseGit-&gt;Submodule Update…”,点击“OK”即可。 执行Submodule Update…操作后就会把子模组的版本库克隆下来。 对主Git库工作区作commit、checkout、revert、pull、push等更改Git工作区内容的操作时，查看Submodule目录下内容的效果1) 对主Git库工作区作commit操作当在主Git库工作区中变更到达一个适当状态时，我们需要将这些变更提交到Git库，作版本备份和跟踪。 方法： 在工作区内右击，选择“ Commit-&gt; “当前分支名称” ”，在Commit窗口中，选择需要提交的变更path，填写提交说明，点击“Ok”。 结论：在主git工作区作commit操作，只是将主Git工作区的变更历史提交到主Git本地库中，对Submodule没有任何影响。 对主Git库工作区作checkout操作当在主Git库工作区中想要切换到其他某个分支、某个tag、某个commit历史记录。 我们这里举个特殊的例子： 切换到某个commit历史记录(如在主版本库中提交子版本库的历史记录) 方法： 在Git工作区内的某目录上右击，选择“Swicht/Checkout…”在Swicht/Checkout…Checkout窗口中，在Switch to Commmit中列出需要切换的commit历史记录，在此列表中选择需要切换到的commit历史记录，以后点击“Ok”按钮。 注：由于切换到的是在主版本库中提交子版本库的那条历史记录，因此子模组中状态也会改换，也需要在子模组中执行切换。 执行Submodule Update操作即可。 对主Git库工作区作revert操作当在主Git库工作区中这次变更有错误时，就可以使用revert操作来撤销这次次操作。 方法： 在工作区内右击，选择“Revert”，在Revert窗口中，选择需要撤销的变更path，点击“Ok”。 结论：在主git工作区作revert操作，只是将主Git工作区某次的变更操作给撤销，此次操作之前的commit都会被保留，且对Submodule没有任何影响。 对主Git库工作区作push操作当在主Git库工作区中将主Git本地库的数据推送到主Git远程库中。 方法：在工作区的目录上（不要在文件上）右击，选择“Git Sync…” “Local Branch”，”Remote Branch”，“Remote URL”这3栏必须正确才能“推”数据。 结论：在主git工作区作push操作，只是将主Git本地库的变更历史推送到到主Git远程库中，对Submodule没有任何影响。 对主Git库工作区作pull操作当在主Git库工作区中将主Git远程库的拉取到主Git本地库中。 方法：在工作区的目录上（不要在文件上）右击，选择“Git Sync…” “Local Branch”，”Remote Branch”，“Remote URL”这3栏必须正确才能“拉”数据。 结论：在主git工作区作pull操作，只是将主Git远程库的变更历史拉取到到主Git本地库中，对Submodule没有任何影响。 对submodule下的内容进行修改后commit、push，对submodule目录作pull在执行Submodule Update…操作更新出子模组后，都以某个具体的提交版本进行检出，进入子模组目录，会发现其处于非跟踪状态。 显然这种情况下，如果修改lib/lib_a下的文件，提交就会丢失。下面介绍如何在检查的子模组中修改，以及如何更新子模组。 在子模组中切换到master分支(或者其他想要修改的分支)后在进行修改。 切换到master分支，然后在工作区做一些改动。 执行commit后，并且推送到子模组库中后。 回到主版本库中。 在主版本库中查看状态，在主版本库中可以看到子模组已修改，包含了更新的提交。 需要将修改提交在主版本库中进行推送。 对submodule目录作pull当子模组版本库中有新的提交历史记录，就需要做pull操作来更新。 注：对子模组库中做了pull操作，同时需要对调用子模组库的主版本库中也要做Pull操作。 如下图所示： 注意：进入子模组目录，会发现其处于非跟踪状态。显然这种情况下，如果修改lib/lib_a下的文件，提交就会丢失。提示如下： 移除Submodule第一步：用Delete(keep local) 将目录或文件命令从git的索引库中移除子模块目录方法： 在工作区内目录或文件上右击，选择“Delete(keep local)”，在Delete窗口中，点击“Remove”。 Delete(keep local)把目录lib/从git的索引库中移除,但是对目录lib/本身并不进行任何操作。 因此需要彻底删除。 第二步：删除物理文件 第三步：删除.gitmodule文件 第四步：删除.git/config的submodule配置源文件 删除如下图所示红框的部门 第五步：删除后，提交更改]]></content>
      <categories>
        <category>TortoiseGit</category>
      </categories>
      <tags>
        <tag>TortoiseGit</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git cherry-pick用法]]></title>
    <url>%2F2018%2F07%2F26%2FGit-cherry-pick%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[TortoiseGit之cherry-pick使用有这么一个需求，分支节点A作为dev分支，分支节点B和C作为功能分支，某天在B节点上爆发出一个bug，经研究发现该bug是根节点带出的，意味着C上也会有该bug，此时正确的修复手段是从B和C的共同根节点A中拉出分支，对该bug进行修复，而不是分别在B和C上进行代码修改。于此同时也许在A节点上有新的功能增加，此时不能直接把修复bug对应的commit合并到B和C上，而需要用到cherry-pick。参考以下文章： git cherry-pick 把提交到A分支的部分commit 再提交到B分支上 应用环境:有一个主分支 master (这个分支只是用来合并其他通过测试的分支,及上线打版本)另一个分支 dev (开发提交的分支) 当你通过一番挣扎终于搞定一个bug,顺手提交到 git 服务器,心里一阵暗爽. 这时发现你当前所在的分支是 master !!!这个分支不是开发者用来提交代码的,可惜现在剁手也晚了。怎么办?于是你想到,合并分支……合并分支通常会带来各种各样的冲突，而且当前 dev 分支还在开发中,没有进过测试,所以就算合并也是 dev 合并 master 分支。但是车根本太大。这时最好的解决方案就是用 cherry-pick。 使用方法: 先切换到刚才你误操作的分支下 master 1git checkout master 然后找到你的提交信息 1234git logcommit 424037d22c5830ba39b7c46bacd4abcb2abe072dAuthor: bingcaihuang &lt;bingcaihuang@gmail.com&gt;Date: Thu Jul 26 13:31:33 2018 +0800 从提交日志中找到 commitID 1424037d22c5830ba39b7c46bacd4abcb2abe072d 切换到 dev 分支下 1git checkout dev 把 master 下的 bug fixed! 提交重新提交的 dev 分支下 1234git cherry-pick &apos;424037d22c5830ba39b7c46bacd4abcb2abe072d&apos;Finished one cherry-pick.On branch devYour branch is ahead of &apos;origin/dev&apos; by 1 commits. 上面的提示信息告诉我们这个 commit 已经重新提交到了 dev 分支下。注意,这个操作也行会报错,这时需要你手动去合并冲突,然后重新提交。最后 git push Cherry pickingTortoiseGit官方说明书：Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown.Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown.Cherry-picking in TortoiseGit is invoked from the Revision Log Dialog. Within this dialog, select the commit(s) to cherry-pick, then right-click on one of the selected commits to pop up the context menu. Select Cherry Pick this commit… (or Cherry Pick select commits… if more than one commit is selected). The Cherry Pick dialog will be shown. The Cherry Pick dialog is similar to the Rebase dialog. The top table displays one line for each selected commit to cherry-pick. Buttons below it control the actions (Pick, Squash, Edit, Skip) and the order in which multiple commits are picked. Selecting a line shows the files affected by the commit. git cherry-pick 从其他分支检出指定的commit到当前分支 参考文章：git cherry-pick 从其他分支检出指定的commit到当前分支]]></content>
      <categories>
        <category>TortoiseGit</category>
      </categories>
      <tags>
        <tag>TortoiseGit</tag>
        <tag>cherry-pick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo基于GitHub Pages搭建个人博客]]></title>
    <url>%2F2018%2F07%2F24%2F%E4%BD%BF%E7%94%A8Hexo%E5%9F%BA%E4%BA%8EGitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用 Hexo 基于 GitHub Pages 搭建个人博客（一） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（一） GitHub Pages 是 GitHub 提供的免费开源的静态站点托管服务，利用这个服务可以搭建轻量级的博客系统，本文介绍了如何使用 Hexo 结合 GitHub Pages 服务搭建个人博客。最后博客配置文件以及博文md文件保存在Nas的Git中，通过Git维护数据。 安装配置 Git安装 Git使用 GitHub 首先要安装 Git，可根据操作系统下载不同版本的 Git，Windows 下载地址：https://git-scm.com/download/win 安装过程比较简单，选择默认选项配置即可下一步，不再叙述。 配置 Git设置本地机器默认 commit 的昵称与 Email，姓名与 Email 只用于日志标识，实际推送到远程仓库时，要用有操作权限的账号登录。 12git config --global user.name &quot;ehlxr&quot;git config --global user.email &quot;ehlxr@qq.com&quot; 生成 SSH keysSSH Keys 是 GitHub 推荐的公钥、秘钥形式验证用户合法性的机制，添加 SSH Keys 可以省去每次都要输入密码的步骤，下面将演示如何在本地计算机生成 SSH Keys 的公钥、秘钥。 首先打开安装的 Git Bash 运行 ssh-keygen 命令输入以下命令：（替换 &quot;your_email@example.com&quot; 为注册时候的邮箱） 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 保存秘钥文件当出现以下提示时，直接敲回车键选择默认地址即可（保存私钥文件位置，默认保存在当前用户文件夹下的 .ssh 文件夹中，文件名称为 id_rsa ）1Enter file in which to save the key (/c/Users/lt/.ssh/id_rsa): 如果已经存在会提示，输入：y 敲回车替换即可12/c/Users/lt/.ssh/id_rsa already exists.Overwrite (y/n)? 出现以下提示设置密码提示，不用设置密码，敲回车键即可1Enter passphrase (empty for no passphrase): 再次确认密码提示，不用设密码敲回车即可1Enter same passphrase again: 出现以下提示，表明已经成功生成了 SSH Keys 12345678910111213141516Your identification has been saved in /c/Users/lt/.ssh/id_rsa.Your public key has been saved in /c/Users/lt/.ssh/id_rsa.pub.The key fingerprint is:SHA256:dBtq6OOJs1JQat630kGqh320Y0JSb7smaR6c9jjo7h0 your_email@example.comThe key&apos;s randomart image is:+---[RSA 4096]----+| || . || o . o || = .o o o || + + o. S . ||.oo.*.o. ||oo=E +oo ||o.#+Oooo ||+OoO==o |+----[SHA256]-----+ Github 官网 SSH Keys 生成教程 开启 GitHub Pages 服务GitHub 账户注册比较简单，注册免费使用的账户就可以了，这里就不细说了，需要注意的是尽量不要使用 126/163 邮箱注册，我在测试的时候收不到验证码，等收到验证码的时候已经第二天了，早就过期了，我使用 Gmail 和 QQ 邮箱都能很快收到验证码。 添加生成的 SSH Keys 到 GitHub打开生成的 SSH Keys 公钥 登录注册的 GitHub 账户，按照以下图示 1、2、3、4、5、6、7 步骤操作，复制公钥内容粘贴到下图步骤 5 的 Key 输入框中，在 步骤 6 输入一个标题，点击 步骤 7 的 Add SSH key 按钮，这时候会提示你输入 GitHub 账号密码，输入密码确认即可添加成功。 创建 GitHub 仓库按照下图所示操作，仓库名称按照：yourname.github.io 格式创建，这样就可以通过 yourname.github.io 方式访问你的博客。如果创建名称为：myblog , 则博客的访问路径为 yourname.github.io/myblog 填写完仓库名称，其他选项默认，点击 Create repository 即可完成创建。 测试 GitHub Pages 服务接下来在仓库根目录下创建一个 index.html 文件测试 GitHub Pages 服务是否开启成功。打开刚才创建的仓库，因为我们之前已经添加了 SSH Keys，所以选择复制如下图所示的 SSH 仓库连接 在电脑磁盘创建一个文件夹（我创建在：D:/lxr）在 Git Bash 分别输入以下两条命令：123cd /d/lxr/ # 进入创建的文件夹git init # 初始化本地仓库 在本地文件夹中创建 index.html 文件，随便输入一些内容即可，命令如下：1echo &quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot; &gt;&gt; index.html # 创建 index.html 文件 然后分别执行以下命令：1234git add index.html # 添加文件git commit -m &quot;create index.html&quot; # 提交文件git remote add origin git@github.com:ehlxr/ehlxr.github.io.git # 添加 GitHub 仓库地址，注意地址填写自己注册的 GitHub 仓库地址git push -u origin master # push 到 GitHub 浏览器访问：yourname.github.io 如果出现 index.html 输入的内容，即 GitHub Pages 服务开启成功 使用 Hexo 基于 GitHub Pages 搭建个人博客（二） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（二） Node.js 安装Hexo 是基于 Node.js 安装，所以安装 Hexo 之前首先要安装 Node.js。下载地址：https://nodejs.org/en/download/ 根据自己的操作系统，下载对应版本即可。Windons 安装过程比较简单，一直下一步即可安装完成。 CentOS 7 安装 Node.js Hexo 安装打开 Git Bash 输入以下命令开始安装 Hexo1npm install hexo-cli -g 出现以下界面表示安装完成 Hexo配置文件的设置确保你的Hexo的配置文件_config.yml里面有个这个选项配置，并将其置为true1post_asset_folder: true 这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用1hexo new 生成一篇新文章时，会在1\source\_posts 目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等 有了上面的配置，再加上Atom的图片插入插件，Hexo在public文件下生成html文件时，会在相应的目录中把那文章对应的资源文件夹中的图片等附件复制过去。 Hexo 建站安装 Hexo 完成后，在本地磁盘创建一个目录用于存放 Hexo 配置文件和博客源代码，我的 Hexo 存放在 D:/Hexo 目录下。 分别执行下列命令，Hexo 将会在 D:/Hexo 新建所需要的文件1234567891011# 进入 D:/ehlxr 目录cd /d/ehlxr/# 初始化所需要的文件到 Hexo 文件夹hexo init Hexo# 进入 Hexo 文件夹cd Hexo# 安装npm install 分别执行以下命令在本地进行预览 12345# 编译生成博文hexo generate# 启动Hexo服务器hexo server 出现以下画面表示服务启动成功 打开浏览器输入 http://localhost:4000/ 便可以看到最原始的博客了 Hexo 部署到 GitHub Pages更新 Hexo 安装文件夹中 _config.yml 文件，如图 更新 _config.yml 文件中的 deploy 节点，如图所示，可添加多个地址（如一个 GitHub、Coding、oschina），冒号后面要有空格，这是一个坑 分别执行以下命令即可完成部署12345npm install hexo-deployer-git --save # 安装 hexo-deployer-githexo clean # 可简写为 hexo clhexo generate # 可简写为 hexo ghexo deploy # 可简写为 hexo d 访问 https://yourname.github.io 即可看到博客模板的内容，对于 Hexo 的一些详细设置可以参考 Hexo 官方文档 。本站使用的 Hexo 主题是 NexT，详细设置可参考 Next 主题官方网站。 使用以下命令就可以新建一篇博客文章1hexo new &quot;开始blog，哈哈&quot; 打开 Hexo 目录下的 source\_posts 目录就可以看见创建的文章了，如图所示 文章是 MarkDown 格式文件（关于 Markdown 语法可参考 Markdown 语法说明 (简体中文版)），编辑文章后保存，可以先启动本地 Hexo Server 查看效果，然后执行部署命令就完成了博客文章的发布 Markdown 编辑器我推荐使用 小书匠 至此，使用 Hexo 基于 GitHub Pages 搭建个人博客就介绍完了。 使用 Hexo 基于 GitHub Pages 搭建个人博客（三） 参考文章：使用 Hexo 基于 GitHub Pages 搭建个人博客（三） 主题基本配置记录一下 Next 主题的基本配置、设置「阅读全文」、关闭新建页面的评论功能、页面文章的篇数、宽度调节、设置「JavaScript 第三方库」等内容、在线字体替换（选择关闭，加快访问速度） 主题安装Next 主题安装与所有 Hexo 主题安装一样。当克隆或者下载（Next 主题 GitHub 地址）完成主题文件后，拷贝至站点目录的 themes 目录下，一般命名为 next，打开站点配置文件， 找到 theme 字段，并将其值更改为 next 即可。 1theme: next 主题宽度调节编辑 themes/next/source/css/_variables/custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 以上方法不适用 Pisces Scheme Pisces Scheme 编辑 themes/next/source/css/_schemes/Picses/_layout.styl 文件，更改以下 css 选项定义值： 123.header&#123; width: 1150px; &#125;.container .main-inner &#123; width: 1150px; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125; 多说评论安装多说注册多说，登录后在首页选择 “我要安装”。 创建站点按要求填写如下图所示表单： 注意： 多说域名 这一栏填写的即是你的 duoshuo_shortname，在下一步主题配置中需要使用到。 主题配置多说创建站点完成后，在 主题配置文件 中新增 duoshuo_shortname 字段，值设置成上一步创建站点中填写的 多说域名 即可。 开启多说热评文章在 主题配置文件 中，设置 duoshuo_hotartical 配置项的值为 true，即可开启多说热评文章。 多说评论样式调整登录多说后，在首页右上角点击 “后台管理”，选择站点名称打开多说后台管理页面，选择“设置” 下拉找到 “自定义 CSS” 输入框，填写以下CSS样式，效果参考本站文章结尾评论样式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 统计我使用 LeanCloud 统计文章阅读数，使用不蒜子统计站点的 PV 和 UV 数。 文章阅读次数统计（LeanCloud)参考为 NexT 主题添加文章阅读量统计功能 不蒜子统计站点访问统计编辑 主题配置文件 中的 busuanzi_count 的配置项，配置以下内容：1234567891011121314151617# count values only if the other configs are falseenable: true# custom uv span for the whole sitesite_uv: truesite_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;site_uv_footer:# custom pv span for the whole sitesite_pv: truesite_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;site_pv_footer:# custom pv span for one page onlypage_pv: falsepage_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;page_pv_footer: site/page_pv/uv_header 和 site/page_pv/uv_footer 为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。 博客主题配置修改_config.yml文件打开NexT主题的根目录下的_config.yml文件，修改：1234leancloud_visitors: enable: true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 配置LeanCloud实际使用过程中LeanCloud已经改版，下面列出配置LeanCloud的过程。在注册完成LeanCloud帐号并验证邮箱之后，我们就可以登录我们的LeanCloud帐号，进行一番配置之后拿到AppID以及AppKey这两个参数即可正常使用文章阅读量统计的功能了。 创建应用我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台，如下图所示： 在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的: 创建应用完成后，在应用列表中选择刚创建的HexoBlog应用，点击创建Class：在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。点击左侧右上角的齿轮图标，新建Class：在弹出的选项中选择创建Class来新建Class用来专门保存我们博客的文章访问量等数据:点击创建Class之后，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为Counter: 由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。 创建完成之后，点击设置，选择应用Key:在弹出的界面中，选择左侧的应用Key选项，即可发现我们创建应用的AppID以及AppKey，有了它，我们就有权限能够通过主题中配置好的Javascript代码与这个应用的Counter表进行数据存取操作了: 复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:1234leancloud_visitors: enable: true app_id: zB9W7fUpG8e9iQF9I018I0bj-aaaaaaaa app_key: RkIarEbWMsL4NVGQPKkJaaaa 这个时候重新生成部署Hexo博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。 设置 RSS安装 hexo-generator-feed在站点的根目录下执行以下命令：1$ npm install hexo-generator-feed --save 启用 RSS编辑 站点配置文件，新增以下内容到任意位置：123456789# RSS订阅支持plugin:- hexo-generator-feed# Feed Atomfeed:type: atompath: atom.xmllimit: 20 内容分享使用 JiaThis 作为内容分享服务，具体步骤如下：编辑 站点配置文件， 添加字段 jiathis，值为 true 即可。 搜索服务在站点的根目录下执行以下命令：1$ npm install hexo-generator-search --save 编辑 站点配置文件，新增以下内容到任意位置：12345search:path: search.xmlfield: postformat: htmllimit: 10000 背景效果介绍博客背景动态效果图和点击小红心效果的相关设置。 添加 JS 文件把 js 文件 love.js 和 particle.js 放在\themes\next\source\js\src文件目录下。 引用添加的 JS 文件更新\themes\next\layout\_layout.swig文件，在末尾（在前面引用会出现找不到的 bug）添加以下 js 引入代码：1234&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 图片模式新建博文新建博文，设置type: &quot;picture&quot;，使用{\% gp x-x \%} ... {\% endgp \%}标签引用要展示的图片地址，如下所示：12345678910111213141516---title: Naruto-Picturescategories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 999---&#123;% gp 5-3 %&#125;![](/images/post/18210.jpg)![](/images/post/196232.jpg)![](/images/post/224147.jpg)![](/images/post/199301.jpg)![](/images/post/213318.jpg)&#123;% endgp %&#125; 图片展示效果{\% gp 5-3 \%}：设置图片展示效果，参考 theme/next/scripts/tags/group-pictures.js 注释示意图。 修复图片展示主题目前首页可以正常显示步骤 8.2 设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125; 博文压缩目前知道的有两个插件可以压缩博文，hexo-all-minifier 插件和 gulp 插件。hexo-all-minifier 插件虽然使用比较简单，而且可以压缩图片，但是发现对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用第二种压缩手段。 hexo-all-minifier 配置使用安装 hexo-all-minifier，在站点的根目录下执行以下命令：1$ npm install hexo-all-minifier --save hexo g 生产博文的时候就会自动压缩 HTML、JS、图片，详情参考插件介绍 gulp 插件配置使用hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在 package.json 同级目录下，新建 gulpfile.js 并填入以下内容：12345678910111213141516171819202122232425262728293031323334var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 博文置顶修改 hexo-generator-index 插件替换文件：node_modules/hexo-generator-index/lib/generator.js 为：generator.js 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：123456789---title: Naruto 图集categories: [图片]tags: [picture,naruto]date: 2016-09-02 14:36:04keywords: picture,narutotype: &quot;picture&quot;top: 10--- 头像圆形旋转头像圆形修改修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转修改修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码：123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213141516171819.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 头像循环旋转效果修改修改 sidebar-author.styl 文件，添加如下代码：12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下：12345678910111213141516171819202122232425.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码：12345678910img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125; 完整 sidebar-author.styl 文件参考地址。 参考文章： 【Hexo搭建独立博客全纪录】（一）使用Git和Github【Hexo搭建独立博客全纪录】（二）使用Markdown【Hexo搭建独立博客全纪录】（三）使用Hexo搭建博客如何用 Atom + GitHub 做知识管理]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QFileSystemModel的应用文件浏览器]]></title>
    <url>%2F2018%2F07%2F23%2FQFileSystemModel%E7%9A%84%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[QTreeView + QFileSystemModel rename的实现，qtreeview 参考文章：QTreeView + QFileSystemModel rename的实现，qtreeview 以前在写Markdown编辑器的时候, 写了一个基于QTreeView+QFileSystemModel的简单资源浏览器, 现在想给其增加一个rename的功能. 其实实现rename还是比较简单的, 首先在QTreeView中设置setEditTriggers(QAbstractItemView::EditKeyPressed);这样就可以按键盘上的F2来来进行rename. 但是如果想做成有一个右键菜单上有rename, 如下图: 那该怎么做呢. 这里需要加一个menu,当然并不是重点, 重点在于如何才会触发rename这个操作, 在前面我们设置好setEditTriggers之后按键盘F2是可以触发rename的.但是我们并不知道在按下F2之后发生了什么.当然我们可以完全不比理会按下F2之后发生了什么, 既然按下F2可以进行rename, 那么我们就产生一个按下F2的事件也是可以实现目的的代码片段如下: 123456789101112connect(menu_, &amp;ProjectExplorerMenu::signalRename, [this]()&#123; QString path = model_-&gt;filePath(currentIndex()); if(path.isNull()) &#123; qDebug() &lt;&lt; &quot;file path is null&quot;; return; &#125; //真逗比但有效... QKeyEvent event(QEvent::KeyPress, Qt::Key_F2, Qt::NoModifier); keyPressEvent(&amp;event);&#125;); 这里面当menu选中rename这一项的时候发出signalRename的信号, 在对应的槽中实例化了一个QKeyEvent对象, 并将其key设置为Qt::key_F2, 即产按下F2的这个事件, 然后把这个事件传给处理键盘按下的事件过滤器keyPressEvent. 就此目标实现. 但是这样做并不是太干净,想做得更干净一点可以查QTreeView的源码. 在QTreeView的keyPressEvent中: 123456789101112131415161718192021222324252627282930313233void QTreeView::keyPressEvent(QKeyEvent *event)&#123; Q_D(QTreeView); QModelIndex current = currentIndex(); //this is the management of the expansion if (d-&gt;isIndexValid(current) &amp;&amp; d-&gt;model &amp;&amp; d-&gt;itemsExpandable) &#123; switch (event-&gt;key()) &#123; case Qt::Key_Asterisk: &#123; QStack&lt;QModelIndex&gt; parents; parents.push(current); while (!parents.isEmpty()) &#123; QModelIndex parent = parents.pop(); for (int row = 0; row &lt; d-&gt;model-&gt;rowCount(parent); ++row) &#123; QModelIndex child = d-&gt;model-&gt;index(row, 0, parent); if (!d-&gt;isIndexValid(child)) break; parents.push(child); expand(child); &#125; &#125; expand(current); break; &#125; case Qt::Key_Plus: expand(current); break; case Qt::Key_Minus: collapse(current); break; &#125; &#125; QAbstractItemView::keyPressEvent(event);&#125; 代码很简单没几行, 处理了按下键盘上+,-,*三个按键. +号展开, -号收缩, *号递归展开其他的键盘事件扔给其基类去处理(不看代码我都不知道原来已经有这样的处理……..), 再来看看QAbstractItemView中对F2做了什么特别的处理这里代码就比较多了有几百行, 代码虽长但是F2处理的部分还是很简单的: 123456789101112void QAbstractItemView::keyPressEvent(QKeyEvent *event)&#123; ... switch (event-&gt;key()) &#123; case Qt::Key_F2: if (!edit(currentIndex(), EditKeyPressed, event)) event-&gt;ignore(); break; ... &#125; ...&#125; 原来按下F2的时候是使用了edit这个函数来进行处理的, 由此修改我们之前直接生成一个QKeyEvent实例并传递给keyPressEvent的代码可以更改为: 1234567891011connect(menu_, &amp;ProjectExplorerMenu::signalRename, [this]()&#123; QString path = model_-&gt;filePath(currentIndex()); if(path.isNull()) &#123; qDebug() &lt;&lt; &quot;file path is null&quot;; return; &#125; QKeyEvent event(QEvent::KeyPress, Qt::Key_F2, Qt::NoModifier); edit(currentIndex(), EditKeyPressed, &amp;event);&#125;); 呵呵很多时候文档里面没查到的东西, 看看代码就知道了, 源码之下无秘密! QFileSystemModel QDirModel 示例代码，使用方法 参考文章：QFileSystemModel QDirModel 示例代码， 使用方法 QFileSystemModel 查看，添加和删除目录 实现代码dialog.h 123456789101112131415161718192021222324#ifndef DIALOG_H #define DIALOG_H #include &lt;QDialog&gt; #include &lt;QtGui&gt; class Dialog : public QDialog &#123; Q_OBJECT public: Dialog(QWidget *parent = 0); private slots: void createDirectory(); void remove(); private: QFileSystemModel *model; QTreeView *treeView; &#125;; #endif // DIALOG_H dialog.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;dialog.h&quot; Dialog::Dialog(QWidget *parent) : QDialog(parent) &#123; setWindowTitle(&quot;QFileSystemModel&quot;); model = new QFileSystemModel; model-&gt;setReadOnly(false); model-&gt;setRootPath(QDir::currentPath()); treeView = new QTreeView; treeView-&gt;setModel(model); treeView-&gt;header()-&gt;setStretchLastSection(true); treeView-&gt;header()-&gt;setSortIndicator(0, Qt::AscendingOrder); treeView-&gt;header()-&gt;setSortIndicatorShown(true); treeView-&gt;header()-&gt;setClickable(true); QModelIndex index = model-&gt;index(QDir::currentPath()); treeView-&gt;expand(index); treeView-&gt;scrollTo(index); treeView-&gt;resizeColumnToContents(0); QPushButton *createButton = new QPushButton(tr(&quot;Create Dir&quot;)); QPushButton *removeButton = new QPushButton(tr(&quot;Remove Dir&quot;)); connect(createButton, SIGNAL(clicked()), this, SLOT(createDirectory())); connect(removeButton, SIGNAL(clicked()), this, SLOT(remove())); QHBoxLayout *hLayout = new QHBoxLayout; hLayout-&gt;addWidget(createButton); hLayout-&gt;addWidget(removeButton); QVBoxLayout *vLayout = new QVBoxLayout; vLayout-&gt;addWidget(treeView); vLayout-&gt;addLayout(hLayout); setLayout(vLayout); &#125; void Dialog::createDirectory() &#123; QModelIndex index = treeView-&gt;currentIndex(); if( !index.isValid() ) return; QString dirName = QInputDialog::getText(this, tr(&quot;create Dir&quot;), tr(&quot;Dir name&quot;)); if( !dirName.isEmpty() ) &#123; if( !model-&gt;mkdir(index, dirName).isValid() ) QMessageBox::information(this, tr(&quot;Create Dir&quot;), tr(&quot;Failed to create Dir&quot;)); &#125; &#125; void Dialog::remove() &#123; QModelIndex index = treeView-&gt;currentIndex(); if( !index.isValid() ) return; bool ok; if( model-&gt;fileInfo(index).isDir() ) ok = model-&gt;rmdir(index); else ok = model-&gt;remove(index); if(!ok) QMessageBox::information(this, tr(&quot;Remove&quot;), tr(&quot;Failed to remove Dir&quot;).arg(model-&gt;fileName(index))); &#125; main.cpp 123456789101112#include &quot;dialog.h&quot; #include &lt;QApplication&gt; int main(int argc, char *argv[]) &#123; QApplication a(argc, argv); Dialog w; w.setSizeIncrement(400,300); w.show(); return a.exec(); &#125; A Cross-platform Faster File System Model than QFileSystemModel 参考文章：A Cross-platform Faster File System Model than QFileSystemModel BackgroundYou know that, QDirModel is obsolete and Qt recommend to use QFileSystemModel. However, QFileSystemModel is not fast enough as windows explorer. Here I will create an explorer as fast as windows explorer. Model Related ClassesFileSystemItem: This class represent an item (dir/file/folder) in the model. Here source listing of this class. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &quot;filesystemmodel.h&quot;#include &lt;QDir&gt;#include &lt;QFileIconProvider&gt;#include &lt;QDateTime&gt;#define SEPARATOR QString(&quot;/&quot;)// This class represents a row in FileSystemModelclass FileSystemItem&#123;public: FileSystemItem(const QFileInfo&amp; fileInfo,FileSystemItem* parent = 0) &#123; mParent = parent; mFileInfo = fileInfo; if(parent)&#123; parent-&gt;addChild(this); // NOTE: absoluteFilePath method of QFileInfo class cause the file system // query hence causes slower performance, We are going to keep the // absolutepath of an item. Absolute path means the absolute path of parent // plus a separator plus filename of this item. if(0 == parent-&gt;parent())&#123; // for drives, there is no filename, so we used canonicalPath mAbsFilePath = fileInfo.canonicalPath(); &#125; else&#123; mAbsFilePath = parent-&gt;absoluteFilePath() + SEPARATOR + fileInfo.fileName(); &#125; &#125; else&#123; // Path of root item, which is not visible; mAbsFilePath = &quot;&quot;; &#125; &#125; ~FileSystemItem() &#123; qDeleteAll(mChildren); &#125; FileSystemItem* childAt(int position) &#123; return mChildren.value(position,0); &#125; int childCount() const &#123; return mChildren.count(); &#125; // returns the position of this son among his siblings int childNumber() const &#123; if (mParent)&#123; return mParent-&gt;mChildren.indexOf(const_cast&lt;FileSystemItem*&gt;(this)); &#125; return 0; &#125; FileSystemItem* parent() &#123; return mParent; &#125; QString absoluteFilePath()const &#123; return mAbsFilePath; &#125; QString fileName()const &#123; if(mParent)&#123; // for drives, there is no filename, so we used canonicalPath if(0 == mParent-&gt;parent())&#123; return mFileInfo.canonicalPath(); &#125; else&#123; return mFileInfo.fileName(); &#125; &#125; return &quot;&quot;; &#125; QFileInfo fileInfo()const &#123; return mFileInfo; &#125; void addChild(FileSystemItem *child) &#123; if(!mChildren.contains(child))&#123; mChildren.append(child); &#125; &#125; // This is a recursive method which tries to match a path to a specifiq // FileSystemItem item which has the path; // Here startIndex is the position of the separator FileSystemItem* matchPath(const QStringList&amp; path, int startIndex = 0) &#123; foreach(FileSystemItem* child, mChildren)&#123; QString match = path.at(startIndex); if(child-&gt;fileName() == match)&#123; if(startIndex + 1 == path.count())&#123; return child; &#125; else&#123; return child-&gt;matchPath(path,startIndex + 1); &#125; &#125; &#125; return 0; &#125;private: FileSystemItem* mParent; QList&lt;FileSystemItem*&gt; mChildren; QFileInfo mFileInfo; QString mAbsFilePath;&#125;;// End of FileSystemItem class FileSystemModel: This class is the Model itself. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266class FileSystemModel : public QAbstractItemModel&#123;Q_OBJECTpublic: enum Column&#123;NAME, SIZE, TYPE, DATE, LASTCOLUMN&#125;;FileSystemModel(QObject* parent) : QAbstractItemModel(parent),mIconFactory(new QFileIconProvider())&#123; // Now it is time to fix the headers mHeaders &lt;&lt; &quot;Name&quot; &lt;&lt; &quot;Size&quot; &lt;&lt; &quot;Type&quot; &lt;&lt; &quot;Date Modified&quot;; // Create the root item [NOTE: Root item is not visible, but is the parent // of all drives] mRootItem = new FileSystemItem(QFileInfo(),0); mCurrentPath = &quot;&quot;; QFileInfoList drives = QDir::drives(); foreach(QFileInfo drive, drives)&#123; new FileSystemItem(drive,mRootItem); &#125;&#125;~FileSystemModel()&#123; delete mRootItem; delete mIconFactory;&#125;QVariant headerData(int section, Qt::Orientation orientation, int role) const&#123; if(orientation == Qt::Horizontal)&#123; switch(role)&#123; // in case of DisplayRole, just return the header text case Qt::DisplayRole: return mHeaders.at(section); break; // in case of TextAlignmentRole, only SIZE column will be right align, // others will be left align case Qt::TextAlignmentRole: return int(SIZE) == section ? Qt::AlignRight : Qt::AlignLeft; break; &#125; &#125; return QVariant();&#125;Qt::ItemFlags flags(const QModelIndex &amp;index) const&#123; if (!index.isValid()) return 0; // Our model is read only. return Qt::ItemIsEnabled | Qt::ItemIsSelectable;&#125;int columnCount(const QModelIndex &amp; /* parent */) const&#123; return LASTCOLUMN; // here it is; 4.&#125;int rowCount(const QModelIndex &amp;parent) const&#123; FileSystemItem *parentItem = getItem(parent); return parentItem-&gt;childCount();&#125;QVariant data(const QModelIndex &amp;index, int role) const&#123; // invalid work, invalid return if (!index.isValid())&#123; return QVariant(); &#125; // in case of TextAlignmentRole, only SIZE column will be right align, // others will be left align if(int(SIZE) == index.column() &amp;&amp; Qt::TextAlignmentRole == role)&#123; return Qt::AlignRight; &#125; // At present, I don&apos;t want pay attention other than DisplayRole &amp; DecorationRole if (role != Qt::DisplayRole &amp;&amp; role != Qt::DecorationRole)&#123; return QVariant(); &#125; FileSystemItem *item = getItem(index); if(!item)&#123; return QVariant(); &#125; // if the role is for decoration &amp; column is zero, we send the item&apos;s icon if(role == Qt::DecorationRole &amp;&amp; index.column() == int(NAME) )&#123; return mIconFactory-&gt;icon(item-&gt;fileInfo()); &#125; QVariant data; Column col = Column(index.column()); switch(col)&#123; case NAME: data = item-&gt;fileName(); break; case SIZE: if(item-&gt;fileInfo().isDir())&#123; data = &quot;&quot;; // we don&apos;t want to show zero. &#125; else&#123; data = item-&gt;fileInfo().size(); &#125; break; case TYPE: data = mIconFactory-&gt;type(item-&gt;fileInfo()); break; case DATE: data = item-&gt;fileInfo().lastModified().toString(Qt::LocalDate); break; default: data = &quot;&quot;; break; &#125; return data;&#125;QModelIndex index(int row, int column, const QModelIndex &amp;parent) const&#123; // As the NAME column is a tree, we will only create index which parent is NAME column if (parent.isValid() &amp;&amp; parent.column() != int(NAME)) return QModelIndex(); FileSystemItem *parentItem = getItem(parent); // if there is a parent index, we want to work if(parentItem)&#123; FileSystemItem *childItem = parentItem-&gt;childAt(row); if (childItem)&#123; return createIndex(row, column, childItem); &#125; &#125; return QModelIndex();&#125;QModelIndex index(const QString&amp; path, int column) const&#123; if(path.length() &gt; 0)&#123; FileSystemItem *item = mRootItem-&gt;matchPath(path.split(SEPARATOR)); if(item)&#123; return createIndex(item-&gt;childNumber(),column,item); &#125; &#125; return QModelIndex();&#125;QModelIndex parent(const QModelIndex &amp;index) const&#123; // invalid work, invalid return if(!index.isValid())&#123; return QModelIndex(); &#125; FileSystemItem* childItem = getItem(index); // If there is no child, there is no index if(!childItem)&#123; return QModelIndex(); &#125; FileSystemItem *parentItem = childItem-&gt;parent(); // if there is no parent or parent is invisible, there is no index if (!parentItem || parentItem == mRootItem)&#123; return QModelIndex(); &#125; return createIndex(parentItem-&gt;childNumber(), NAME, parentItem);&#125;bool isDir(const QModelIndex &amp;index)&#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item &amp;&amp; item != mRootItem)&#123; return item-&gt;fileInfo().isDir(); &#125; return false;&#125;// NOTE: absoluteFilePath method of QFileInfo class cause the file system// query hence causes slower performance, We are going to keep the// absolutepath of an item. Absolute path means the absolute path of parent// plus a separator plus filename of this item.QString absolutePath(const QModelIndex &amp;index)&#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item &amp;&amp; item != mRootItem)&#123; return item-&gt;absoluteFilePath(); &#125; return &quot;&quot;;&#125;QString currentPath()const&#123; return mCurrentPath;&#125;QModelIndex setCurrentPath(const QString&amp; path)&#123; mCurrentPath = path; // find the file system item FileSystemItem *item = mRootItem-&gt;matchPath(path.split(SEPARATOR)); // if there is a item and item&apos;s child is zero, we are going to find the // entries in the directory if(item &amp;&amp; item != mRootItem &amp;&amp; item-&gt;childCount() == 0)&#123; populateItem(item); &#125; return index(path);&#125;private:void populateItem(FileSystemItem *item)&#123; QDir dir(item-&gt;absoluteFilePath()); QFileInfoList all = dir.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot); // loop through all the item and construct the childs foreach(QFileInfo one, all)&#123; new FileSystemItem(one,item); &#125;&#125;FileSystemItem *getItem(const QModelIndex &amp;index) const&#123; // just return the internal pointer we set at creating index if the index is valid if(index.isValid()) &#123; FileSystemItem *item = static_cast&lt;FileSystemItem*&gt;(index.internalPointer()); if(item) &#123; return item; &#125; &#125; return mRootItem;&#125;private: FileSystemItem* mRootItem; QString mCurrentPath; QStringList mHeaders; QFileIconProvider* mIconFactory;&#125;; FileSystemSortProxyModel: Sort/Proxy Model 123456789101112131415161718192021222324252627class FileSystemSortProxyModel : public QSortFilterProxyModel&#123;Q_OBJECTpublic:FileSystemSortProxyModel(QObject *parent) : QSortFilterProxyModel(parent)&#123;&#125;protected:bool lessThan(const QModelIndex &amp;left, const QModelIndex &amp;right) const&#123; FileSystemModel* fsModel = dynamic_cast&lt;FileSystemModel*&gt;(sourceModel()); // To keep the the folder always on the up, we need to do the followings // while the compare indice are folder &amp; file exclusively. if(fsModel)&#123; if((fsModel-&gt;isDir(left) &amp;&amp; !fsModel-&gt;isDir(right)))&#123; return sortOrder() == Qt::AscendingOrder; &#125; else if( (!fsModel-&gt;isDir(left) &amp;&amp; fsModel-&gt;isDir(right)))&#123; return sortOrder() == Qt::DescendingOrder; &#125; &#125; return QSortFilterProxyModel::lessThan(left,right);&#125;&#125;; View classDirBrowser: Now the view class. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class DirBrowser : public QTableView&#123;Q_OBJECTpublic:DirBrowser(QWidget *parent) : QTableView(parent)&#123; grabKeyboard(); /* IMPORTANT Construct the QFileSystemModel. This is relatively faster that QDirModel. ****** TODO ****** However, QFileSystemModel is not fast enough as windows system explorer. We have to consider platform specifiq API in this case, like FindFirstFile or FindFirstFileEx with looping FindNextFile. In this case we have to completely make a View class to show contents on this. I have worked with this APIs at past, yet need some R&amp;D&apos;s on this. In this case, there are challenges like finding the item&apos;s icon &amp; item&apos;s text color. */ //mFSModel = new QFileSystemModel(this); mFSModel = new FileSystemModel(this); //mFSModel-&gt;setRootPath(QDir::currentPath()); // This will populate the filesystem mSortModel = new FileSystemSortProxyModel(this); mSortModel-&gt;setSourceModel(mFSModel); this-&gt;setShowGrid(false); this-&gt;verticalHeader()-&gt;hide(); this-&gt;setModel(mSortModel); this-&gt;setSortingEnabled(true); /* Now, binds the necessary signals &amp; corresponding slots. One thing ro remember is that, we are the setting the signal ConnectionType to AutoConnection (default). So if a signal is emitted in another thread, yet the slot will run on invoked objects thread. */ // Binds the doubleClicked signal to handleDirItemDoubleClicked slot of this class connect(this,SIGNAL(doubleClicked(QModelIndex)),SLOT(handleDirItemDoubleClicked(QModelIndex)));&#125;private slots:void handleDirItemDoubleClicked(const QModelIndex &amp;index)&#123; if(mFSModel-&gt;isDir(mSortModel-&gt;mapToSource(index)))&#123; updateCurrentPath(index); &#125;&#125;protected:void keyPressEvent(QKeyEvent *e)&#123; // if bakcspace key is pressed, view the dir browser to updates // parent folder if(e-&gt;key() == Qt::Key_Backspace)&#123; // If parent model-index is valid, up one level; Otherwise // back to topmost level if(this-&gt;rootIndex().parent().isValid())&#123; updateCurrentPath(this-&gt;rootIndex().parent()); &#125; else&#123; this-&gt;setRootIndex(mSortModel-&gt;mapFromSource(mFSModel-&gt;setCurrentPath(&quot;&quot;))); &#125; &#125;&#125;private:void updateCurrentPath(const QModelIndex &amp;index)&#123; if(index.isValid())&#123; // update the model for current path mFSModel-&gt;setCurrentPath(mFSModel-&gt;absolutePath(mSortModel-&gt;mapToSource(index))); // update the view as necessarily this-&gt;setRootIndex(mSortModel-&gt;mapFromSource(mFSModel-&gt;index(mFSModel-&gt;currentPath()))); &#125;&#125;private: FileSystemModel* mFSModel; FileSystemSortProxyModel* mSortModel;&#125;; How to make “Browse for folder” dialog? 参考文章：How to make “Browse for folder” dialog? I’m trying to make a folder selection dialog which looks like this: The images come from this thread: can the Open File dialog be used to select a Folder? I tried both QFileDialog::getExistingDirectory() and making an instance of QFileDialog and setting the properties. It just shows the Open File dialog with hidden files. Header file: 12345678910111213141516171819202122232425#pragma once#include &lt;QtWidgets/QDialog&gt;class QTreeView;class QFileSystemModel;class QLineEdit;class QPushButton;class CDirSelectionDlg : public QDialog &#123; Q_OBJECTpublic: CDirSelectionDlg(const QString initialPath, QWidget *parent = nullptr); QDir directory() const;private: void onCurrentChanged(); QTreeView *m_treeView; QFileSystemModel *m_model; QLineEdit *m_folderName; QPushButton *m_OKbutton; QString m_initialPath;&#125;; Source file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;DirSelectionDlg.h&quot;#include &lt;QLabel&gt;#include &lt;QBoxLayout&gt;#include &lt;QDialogButtonBox&gt;#include &lt;QTreeView&gt;#include &lt;QFileSystemModel&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;CDirSelectionDlg::CDirSelectionDlg(const QString initialPath, QWidget *parent) : QDialog(parent), m_initialPath(initialPath)&#123; setMinimumSize(200, 300); resize(400, 430); m_model = new QFileSystemModel(this); auto rootIdx = m_model-&gt;setRootPath(m_initialPath); m_treeView = new QTreeView(this); m_treeView-&gt;setModel(m_model); m_treeView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); m_treeView-&gt;setHeaderHidden(true); m_treeView-&gt;setSortingEnabled(true); m_treeView-&gt;sortByColumn(0, Qt::AscendingOrder); for(int i = 1; i &lt; m_model-&gt;columnCount(); i ++) // don&apos;t show Size, Type, etc. m_treeView-&gt;setColumnHidden(i, true); m_treeView-&gt;scrollTo(rootIdx); m_treeView-&gt;selectionModel()-&gt;setCurrentIndex(rootIdx, QItemSelectionModel::Current | QItemSelectionModel::Select); connect(m_treeView-&gt;selectionModel(), &amp;QItemSelectionModel::selectionChanged, this, &amp;CDirSelectionDlg::onCurrentChanged); auto buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel); connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;CDirSelectionDlg::accept); connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;CDirSelectionDlg::reject); m_OKbutton = buttonBox-&gt;button(QDialogButtonBox::Ok); auto label = new QLabel(tr(&quot;Folder:&quot;)); m_folderName = new QLineEdit(this); m_folderName-&gt;setReadOnly(true); m_folderName-&gt;setText(QFileInfo(m_initialPath).fileName()); auto pathLayout = new QHBoxLayout(); pathLayout-&gt;addWidget(label); pathLayout-&gt;addSpacing(10); pathLayout-&gt;addWidget(m_folderName); auto mainLayout = new QVBoxLayout(); mainLayout-&gt;addWidget(m_treeView); mainLayout-&gt;addSpacing(10); mainLayout-&gt;addLayout(pathLayout); mainLayout-&gt;addSpacing(10); mainLayout-&gt;addWidget(buttonBox); setLayout(mainLayout);&#125;void CDirSelectionDlg::onCurrentChanged()&#123; auto fileInfo = m_model-&gt;fileInfo(m_treeView-&gt;selectionModel()-&gt;currentIndex()); m_folderName-&gt;setText(fileInfo.fileName()); m_OKbutton-&gt;setEnabled(fileInfo.isDir()); m_OKbutton-&gt;setDefault(fileInfo.isDir());&#125;QDir CDirSelectionDlg::directory() const&#123; return QDir(m_model-&gt;fileInfo(m_treeView-&gt;selectionModel()-&gt;currentIndex()).absoluteFilePath());&#125; QTreeView和QFileSystemModel 参考文章：QTreeView和QFileSystemModel 用Qt来显示一个文件目录是很简单的，如下：例子1：查找显示所有的图片 12345678910111213141516QFileSystemModel *model = new QFileSystemModel(); model-&gt;setRootPath(&quot;/&quot;); //model-&gt;setFilter(QDir::Dirs|QDir::NoDotAndDotDot); //只显示文件夹 // 设置过滤器 QStringList filter; filter &lt;&lt; &quot;*.png&quot; &lt;&lt; &quot;*.jpg&quot; &lt;&lt; &quot;*.bmp&quot; &lt;&lt; &quot;*.gif&quot;; model-&gt;setNameFilters(filter); // 没有通过过滤器的文件disable还是隐藏,true为disable false为隐藏 model-&gt;setNameFilterDisables(false); mTreeView = new QTreeView(); mTreeView-&gt;setAnimated(false); mTreeView-&gt;setSortingEnabled(true); mTreeView-&gt;setModel(model); QDirModel已经不建议使用了，应使用QFileSystemModel 设置一些特殊属性的过滤 setFilter 如只显示文件夹或系统文件 显示项的名字过滤器这个非常有用，如我们想显示所有的”png,jpg,bmp,gif”图片 setNameFilterDisables这个效果如下图： setNameFilterDisables(false)表示不符合名字过滤要求的隐藏而不是disable 例子2：创建一个简单的可以添加文件夹删除文件夹的资源管理 实现也很简单： 1234567891011121314151617181920212223242526model = new QFileSystemModel(); model-&gt;setRootPath(QDir::currentPath()); mTreeView = new QTreeView(); mTreeView-&gt;setAnimated(false); mTreeView-&gt;setSortingEnabled(true); mTreeView-&gt;setModel(model); mTreeView-&gt;setRootIndex(model-&gt;index(QDir::currentPath())); QPushButton* mkdirButton = new QPushButton(tr(&quot;Make directory&quot;), this); QPushButton* rmButton = new QPushButton(tr(&quot;Remove&quot;), this); QHBoxLayout* buttonLayout = new QHBoxLayout; buttonLayout-&gt;addWidget(mkdirButton); buttonLayout-&gt;addWidget(rmButton); QVBoxLayout* layout = new QVBoxLayout(); layout-&gt;addWidget(mTreeView); layout-&gt;addLayout(buttonLayout); setLayout(layout); setWindowTitle(&quot;File system...&quot;); resize(960,640); //connect(mTreeView, SIGNAL(doubleClicked(QModelIndex)), this, SLOT(on_treeView_doubleClicked(QModelIndex))); connect(mkdirButton, SIGNAL(clicked()), this, SLOT(mkdir())); connect(rmButton, SIGNAL(clicked()), this, SLOT(rm())); 添加目录： 1234567891011121314151617void Dialog::mkdir() &#123; QModelIndex index = mTreeView-&gt;currentIndex(); if ( !index.isValid() ) &#123; return; &#125; QString name = QInputDialog::getText(this, tr(&quot;Create directory&quot;), tr(&quot;Directory name&quot;)); if ( !name.isEmpty() ) &#123; if ( !model-&gt;isDir(index) ) &#123; index = model-&gt;parent(index); &#125; if ( !model-&gt;mkdir(index, name).isValid() ) &#123; QMessageBox::information(this, tr(&quot;Create directory failed...&quot;), tr(&quot;Failed to create directory&quot;)); &#125; &#125; &#125; 删除目录和文件 12345678910111213141516171819void Dialog::rm() &#123; QModelIndex index = mTreeView-&gt;currentIndex(); if ( !index.isValid() ) &#123; return; &#125; bool ok; QFileInfo info = model-&gt;fileInfo(index); if ( info.isDir() ) &#123; ok = model-&gt;rmdir(index); &#125; else &#123; ok = model-&gt;remove(index); &#125; if ( !ok ) &#123; QMessageBox::information(this, tr(&quot;Removed&quot;), tr(&quot;Filed to remove %1&quot;).arg(model-&gt;fileName(index))); &#125; &#125; GitHub上的开源项目 file-browser]]></content>
      <categories>
        <category>Qt - Gui</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>QFileSystemModel</tag>
        <tag>Model/View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt中实现QThread线程同步QFtp]]></title>
    <url>%2F2018%2F07%2F23%2FQt%E4%B8%AD%E5%AE%9E%E7%8E%B0QThread%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5QFtp%2F</url>
    <content type="text"><![CDATA[Qt中实现QThread线程同步QFtp 参考文章：Qt中实现QThread线程同步QFtp 在Qt中实现QThread线程同步QFtp ，对于QFtp，它是一个用来实现FTP协议的类，详情查阅资料。接触Qt没有多长时间，但简单几个小例子已经让我感受到Qt在C++运用方面的强大。写了一个小程序，需要在一个单独的线程中使用QFtp来获取FTP服务器上面的文件。FTP是FileZilla。 有两个问题我比较关心： QThread到底如何使用 QFtp是Async（异步）操作，也就是说例如connectToHost这样的函数都是立刻返回，当操作完成后QFtp会发出signal。然而既然我的Ftp操作是在一个单独的线程，我想写一个函数downloadFtpFile() 来完成从connect到login到下载文件等一系列的操作，然后再返回。相当于我需要Sync（同步）的操作，所以需要等待（block）每个Ftp命令的结果。 在该文章最后有一个推荐的使用QThread的方法。我在这里想补充一点：obj.moveToThread(&amp;thread); 这句话将obj从主线程移动到了thread对象所在的线程。但如果obj的对象里面有其他的变量，那么这些变量是在主线程中生成的。所以如果这些变量中有类变量，不能将obj的this指针作为parent传给他们。 对于第二个问题，我使用了QSemaphore类来完成我的block和同步操作：在slot函数里面接收QFtp命令执行结果的signal，释放信号，同时downloadFtpFile()函数里在调用完每一个QFtp异步命令后等待信号。在有点令人失望的是QSemaphore在通过tryAcquire()等待信号的时候是不处理事件event的。但是我需要在等待的时候程序也能触发slot，告诉我当前命令的执行情况。所以我使用了一个小循环，里面调用qApp-&gt;processEvents();来让我的slot函数被触发。下面是代码例子（只是样例，并不完全符合C++语法）： 首先是我的下载Ftp文件的函数： 12345678910111213141516171819202122232425262728293031323334353637383940downloadFtpFile() //该函数在单独线程里执行 &#123; int m_idFtpOp; // 该变量用来存放每一个QFtp命令ID int nVal; QFtp*pFtp = newQFtp(this); // 生成QFtp工具对象 connect(pFtp, SIGNAL(listInfo(QUrlInfo)), this, SLOT(slotFtpListInfo(QUrlInfo))); // 我们需要listinfo，因为我们需要下载ftp所有当前目录文件 connect(pFtp, SIGNAL(commandFinished(int, bool)), this, SLOT(slotFtpCmdFinished(int, bool))); // 每个QFtp命令完成之后，会发出commandFinished信号，我们在槽函数中处理该信号 m_idFtpOp = pFtp-&gt;connectToHost(&lt;FTP地址&gt;, 21); // 连接到远程FTP Server bRet = false; nVal = 100; while (bRet == false) // 使用nVal变量来做一个10000ms（10s）的超时 &#123; nVal--; if (nVal == 0) break; qApp-&gt;processEvents(); // 这里每100ms处理一次event，使slot函数能够被调用 bRet = m_SemOp.tryAcquire(1, 100); // 等待信号100ms &#125; if (!bRet || m_bFtpOpError) // 如果超时，或者slot函数中将m_bFtpOpError置成true，则关闭Ftp，返回错误 &#123; pFtp-&gt;abort(); pFtp-&gt;deleteLater(); return ERRCODE_FCC_FTP_CONN_TIMEOUT; &#125;&#125;下面是槽函数slotFtpCmdFinished(int id, bool error)&#123; if (m_idFtpOp == id) // 如果返回的id是当前正在操作的命令 &#123; if (error) m_bFtpOpError = true; else m_bFtpOpError = false; m_SemOp.release(); // 释放信号（使downloadFtpFile函数中m_SemOp.tryAcquire()返回true） &#125;&#125; 以上的代码只演示了对QFtp第一个命令connectToHost的等待过程。下面的login，list，get等操作都使用这个方法。 注意：在此例中，QFtp是在当前线程生成的，所以信号listInfo(QUrlInfo)的connect方式是direct连接。如果QFtp是在另一个线程生成（比如说是在函数downloadFtpFile所在类的构造函数中），那么第一：不能将this指针作为parent传给QFtp对象，第二：需要使用qRegisterMetaType(“QUrlInfo”);来注册QUrlInfo类，因为信号发射与接收在不通的线程中，信号使用queued的方式。如果不注册QURlInfo类，会在运行时动态报告错误。 总结：本文介绍的是在Qt中如何实现QThread线程同步QFtp ，看过本文之后，如果对于QThread不了解的话，那么请参考Qt中QThread使用方法这篇文章。使用本文介绍的方法，可以在独立的线程中用同步的方式使用QFtp。在某些场合，尤其是采用应答机制的系统中，这样的实现可以很大程度上简化程序流程。]]></content>
      <categories>
        <category>Qt - 网络</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>线程</tag>
        <tag>QThreas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC研究之QLocalServer和QLocalSocket]]></title>
    <url>%2F2018%2F07%2F23%2FIPC%E7%A0%94%E7%A9%B6%E4%B9%8BQLocalServer%E5%92%8CQLocalSocket%2F</url>
    <content type="text"><![CDATA[IPC研究之QLocalServer和QLocalSocket 参考文章：IPC研究之QLocalServer和QLocalSocket 在Qt中，提供了多种IPC方法，作者所用的是QLocalServer和QLocalSocket。看起来好像和Socket搭上点边，实则底层是windows的name pipe。这应该是支持双工通信的。 QLocalServer用来监听某个管道。可以这样建立一个监听 12345678910111213141516171819202122232425262728QLocalServer *localServer;localServer = new QLocalServer(this);localServer-&gt;setMaxPendingConnections(MAX_CONNECTION);if (localServer-&gt;listen(&quot;commandpipe&quot;))&#123; qDebug() &lt;&lt; &quot;listen commandpipe namepipe sucessful.&quot;;&#125;else&#123; qDebug() &lt;&lt; &quot;failed to listen commandpipe. &quot;;&#125;connect(localServer, SIGNAL(newConnection()), this, SLOT(DealConnection()));void IPCServer::DealConnection()&#123; QLocalSocket *socket = localServer-&gt;nextPendingConnection(); socket-&gt;waitForReadyRead(); QDataStream ds(socket); ds.setVersion(QDataStream::Qt_4_6); QString qstr; ds &gt;&gt; qstr; qDebug() &lt;&lt; &quot;Server received: &quot; &lt;&lt; qstr; qDebug() &lt;&lt; &quot;Server processing...&quot;; ds &lt;&lt; qstr.append(&quot; processed&quot;); qDebug() &lt;&lt; &quot;Server send &quot; &lt;&lt; qstr;&#125; 在这里主要采用的是QDataStream读取socket是的内容。读取完了之后，又使用这个socket再把内容转发回去。 12345678910111213QLocalSocket这一块包含连接，和发送信息这一块。QLocalSocket _socket = new QLocalSocket(this);_socket-&gt;connectToServer(&quot;commandpipe&quot;);qDebug() &lt;&lt; &quot;socket connect to namepipe&quot;;QDataStream ds(_socket);ds.setVersion(QDataStream::Qt_4_6);ds &lt;&lt; QString(&quot;hello&quot;);_socket-&gt;waitForBytesWritten();qDebug() &lt;&lt; &quot;send one command&quot;;_socket-&gt;waitForReadyRead();QString bbq;ds &gt;&gt; bbq;qDebug() &lt;&lt; &quot;received servered &quot; &lt;&lt; bbq; 注意，这边我一开始发送的时候是使用的发送char *，但接收的时候却是用QString，结果就不对了。因为QString是unicode编码的。所以出错了。不过现在己经正常了。。。。现在Shark中的Service，IPC，都己经走通了。下面主要还有编码格式，QWebKit模块，数据库模块需要完成。]]></content>
      <categories>
        <category>Qt - 网络</category>
      </categories>
  </entry>
</search>
